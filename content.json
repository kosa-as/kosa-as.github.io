{"posts":[{"title":"C++中std::functional的实现","text":"std::functional的基本原理： 将任意可调用对象包装为一个类型安全、可复制、可赋值的对象 不需要知道其底层类型（即擦除原始类型） 只要它们满足函数签名即可传参执行 std：：functional原理分析： 可调用对象： 类型 举例 可传给 std::function 说明 普通函数指针 int(*)(int,int) ✅ 最基础 Lambda [=](int x){ return x+1; } ✅ 最常用 函数对象 struct F { int operator()(); }; ✅ 可定制行为 静态成员函数 static int f() ✅ 和普通函数等价 成员函数指针 &amp;Class::method ❌（需要包装） 必须配合对象使用 std::bind 结果 bind(f, 1, _1) ✅ 预设参数 std::mem_fn 结果 mem_fn(&amp;C::f) ✅ 成员函数包装 std::function 本身 function&lt;void()&gt; ✅ 高阶封装 类型擦除： std::decay_t&lt;T&gt; 是 C++ 类型萃取中非常常用的工具，它会把一个类型 退化（decay） 成适用于函数参数传递的形式，其行为类似于函数参数的默认类型转换规则。可以理解为：std::decay_t&lt;T&gt; 会去掉引用、cv 限定符、数组/函数类型退化为指针等。 Function的实现12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273#pragma once#include &lt;memory&gt;#include &lt;utility&gt;#include &lt;type_traits&gt;template &lt;typename&gt;class Function; //模板特化，R(Args...)表示一个可调用对象，R是返回类型，Args...是参数类型template &lt;typename R, typename... Args&gt;class Function&lt;R(Args...)&gt; { //ICallable是一个抽象类，定义了一个纯虚函数invoke，用于包裹可调用对象 class ICallable { public: virtual R invoke(Args&amp;&amp;... args) = 0; virtual std::unique_ptr&lt;ICallable&gt; clone() const = 0; virtual ~ICallable() = default; }; //CallableImpl是一个具体类，继承自ICallable，用于包裹可调用对象 template &lt;typename F&gt; class CallableImpl : public ICallable { F func; public: explicit CallableImpl(F&amp;&amp; f) : func(std::forward&lt;F&gt;(f)) {} R invoke(Args&amp;&amp;... args) override { return func(std::forward&lt;Args&gt;(args)...); } std::unique_ptr&lt;ICallable&gt; clone() const override { return std::make_unique&lt;CallableImpl&lt;F&gt;&gt;(F(func)); } }; std::unique_ptr&lt;ICallable&gt; callable;public: // 默认构造函数 Function() noexcept = default; template &lt;typename F, typename = std::enable_if_t&lt;!std::is_same&lt;std::decay_t&lt;F&gt;, Function&gt;::value&gt;&gt; //构造函数，接受一个可调用对象F，并将其包裹在CallableImpl中 Function(F&amp;&amp; f) : callable(std::make_unique&lt;CallableImpl&lt;std::decay_t&lt;F&gt;&gt;&gt;(std::forward&lt;F&gt;(f))) {} // 移动构造和赋值 Function(Function&amp;&amp; other) noexcept = default; Function&amp; operator=(Function&amp;&amp; other) noexcept = default; // 拷贝构造函数 Function(const Function&amp; other) : callable(other.callable ? other.callable-&gt;clone() : nullptr) {} // 拷贝赋值运算符 Function&amp; operator=(const Function&amp; other) { if (this != &amp;other) { callable = other.callable ? other.callable-&gt;clone() : nullptr; } return *this; } R operator()(Args... args) { if (!callable) { throw std::bad_function_call(); } return callable-&gt;invoke(std::forward&lt;Args&gt;(args)...); } explicit operator bool() const { return static_cast&lt;bool&gt;(callable); }}; 代码说明ICallable是所有可调用对象的抽象包裹wrapper类，是一个基类。在Function中，通过*ICallable指针（或者智能指针）来调用派生类中的invoke函数，来实现最后的执行 1234567template &lt;typename R, typename... Args&gt; class ICallable { public: virtual R invoke(Args&amp;&amp;... args) = 0;//执行函数 virtual std::unique_ptr&lt;ICallable&gt; clone() const = 0;//基类并不知道子类是什么样子的，添加一个辅助克隆函数 virtual ~ICallable() = default;//析构函数，必须要申明为虚函数}; CallableImpl是基于ICallable的派生类，里面实现了具体的方法。 123456789101112131415template &lt;typename R, typename... Args&gt; template &lt;typename F&gt;class CallableImpl : public ICallable { F func; public: explicit CallableImpl(F&amp;&amp; f) : func(std::forward&lt;F&gt;(f)) {}//单参构造函数，使用完美转发 R invoke(Args&amp;&amp;... args) override { return func(std::forward&lt;Args&gt;(args)...);//使用func(args...) } std::unique_ptr&lt;ICallable&gt; clone() const override { return std::make_unique&lt;CallableImpl&lt;F&gt;&gt;(F(func));//深拷贝函数，返回本派生类的一个深拷贝对象 } }; 然后是Function内容的实现： 首先私有变量采用了unique_ptr的设计，来管理类型为基类指针但是指向子类的指针。 单参构造函数：explicit Function(F&amp;&amp; f)，在上面使用了SFINAE（substitute failure is not an error），即在进行模板匹配的时候，如果发生了模板不匹配，则不认为是一种错误，转而匹配其他的构造函数。（在其他的设计中也有体现，比如std：：lock_guard和std::unique_lock,两者都要求传入的类实现lock和unlock方法。） 讲到构造函数匹配的问题：下面是构造函数的匹配规则 匹配类别 优先级 非模板函数 最高 模板函数（精确匹配） 高 模板函数（万能引用 T&amp;&amp;） 较低（仅在无其他更优时选） 可变参数模板 (...) 最低 为什么要实现辅助的clone函数呢？ 在这里可见，在赋值构造和赋值拷贝中，调用的是callable实际指向对象的clone函数，如果不这样，默认的赋值构造与拷贝实现的是浅拷贝，那么会引发一系列的问题 为什么要重载R operator()(Args... args)呢？ 通过重载这个运算符，来包裹invoke函数，那么就可以直接使用f()的方式调用函数，实现可调用对象的完美还原（不改变使用方式） 12345678910111213141516171819202122232425262728293031323334353637383940414243444546template &lt;typename&gt;//模板特化，R(Args...)表示一个可调用对象，R是返回类型，Args...是参数类型template &lt;typename R, typename... Args&gt;class Function&lt;R(Args...)&gt; { //ICallable是一个抽象类，定义了一个纯虚函数invoke，用于包裹可调用对象 class ICallable; //CallableImpl是一个具体类，继承自ICallable，用于包裹可调用对象 template &lt;typename F&gt; class CallableImpl : public ICallable; std::unique_ptr&lt;ICallable&gt; callable;public: // 默认构造函数 Function() noexcept = default; template &lt;typename F, typename = std::enable_if_t&lt;!std::is_same&lt;std::decay_t&lt;F&gt;, Function&gt;::value&gt;&gt; //构造函数，接受一个可调用对象F，并将其包裹在CallableImpl中,同时使用类型擦除，来进行包裹 Function(F&amp;&amp; f) : callable(std::make_unique&lt;CallableImpl&lt;std::decay_t&lt;F&gt;&gt;&gt;(std::forward&lt;F&gt;(f))) {} // 移动构造和赋值 Function(Function&amp;&amp; other) noexcept = default; Function&amp; operator=(Function&amp;&amp; other) noexcept = default; // 拷贝构造函数 Function(const Function&amp; other) : callable(other.callable ? other.callable-&gt;clone() : nullptr) {} // 拷贝赋值运算符 Function&amp; operator=(const Function&amp; other) { if (this != &amp;other) { callable = other.callable ? other.callable-&gt;clone() : nullptr; } return *this; } R operator()(Args... args) { if (!callable) { throw std::bad_function_call(); } return callable-&gt;invoke(std::forward&lt;Args&gt;(args)...); } explicit operator bool() const { return static_cast&lt;bool&gt;(callable); }};","link":"/2025/05/02/C++%E4%B8%ADfunctional%E7%9A%84%E5%AE%9E%E7%8E%B0/"},{"title":"6.S081-Fall2021 的实现","text":"MIT 6.S081This repository contains my solution to the labs for MIT’s 6.S081 operating system. How to use it ?First, you need to clone this repository by 1git clone https://github.com/kosa-as/xv6-labs-2021.git Then cd into the file, you are now in the master branch of the projects, to see my answer to a specific lab, e.g. util, syscall …… , you just checkout into that branch by for example 1git checkout util and now you are in the utils branch which contains my solution to the specific lab. if you want to have a clean copy of the original lab handout, just go to the course website and follow the lab guidance. Also, you can watch the course videos on the course website. Hope you enjoy your OS journey. If you want to push to your own GitHub repository, run: 1git remote set-url &lt;remote-name&gt; &lt;new-URL&gt; Then push to the remote repository as usual. Lab ReportsFor each lab, I wrote a brief report on my implementation, explaining the important part of my code and how to complete the lab step by step. (I wrote these reports in Chinese) Lab Utilities Lab System Calls Lab Page Tables Reading materialsI highly recommend you read the xv6 book before watching the course videos and doing the labs.","link":"/2025/07/11/6.S081-Fall2021/"},{"title":"C++关键字解析","text":"1.sizeof和strlen的区别strlen测量的是字符串的实际长度,源代码如下 123456size_t strlen(const char *str) { size_t length = 0; while (*str++) ++length; return length;} sizeof测量的是对象或者表达式类型占用的字节大小 总而言之，一个测量的是实际长度，到’/0’结束，而另一个则是测量实际占用的大小。 2.static的用法 应用场景 类型 作用 局部 static 变量 函数内部 变量生命周期贯穿整个程序，但作用域仅限函数 文件内部 static 变量 文件作用域 限制变量可见性，避免命名冲突 文件内部 static 函数 文件作用域 仅在当前编译单元可见，隐藏实现细节 类的 static 变量 类成员 所有对象共享 类的 static 函数 类成员 不依赖对象，访问静态数据 静态工具类 = delete 防止实例化 线程安全的 static 变量 C++11 确保多线程环境下安全初始化 static 的核心作用： ✅ 控制作用域（文件/函数级别）✅ 延长生命周期（局部 static 变量）✅ 共享数据（类 static 成员）✅ 提升封装性（防止全局变量污染） 3.const的用法 用法 作用 const int a = 10; 常量变量，不可修改 const int* p; 指针指向的值不可修改 int* const p; 指针本身不可修改 const int* const p; 指针本身和指向的值都不可修改 void func(const int x); 传值参数不可修改 void func(const int* p); 传指针参数，指向的值不可修改 void func(const int&amp; ref); 传引用参数，引用值不可修改 class A { const int data; }; 类的成员变量不可修改，需构造函数初始化 void show() const; const 成员函数，不能修改类成员变量 const int&amp; getData() const; const 返回值，防止修改 4.const和define的区别 特性 #define const 作用 预处理文本替换 定义常量变量 类型检查 ❌ 无类型检查，可能引发错误 ✅ 有类型检查，更安全 作用域 ❌ 无作用域，作用于整个文件 ✅ 遵循 C++ 作用域规则 内存占用 ❌ 仅进行文本替换，不占用变量存储空间 ✅ 变量存储在只读数据区 可调试性 ❌ 不能在调试器中查看 ✅ 可以查看变量值 const 指针支持 ❌ 不能用于指针 ✅ 可用于指针，如 const int* p 适用场景 定义简单的文本宏（如 #define DEBUG） 定义具有类型的常量 在C++11之后，推荐使用constexpr来完成一些define定义的值。意味编译时常量，在编译时完成计算来提高程序性能 5.inline函数的作用和使用inline 关键字用于建议编译器在调用处直接展开函数代码，以减少函数调用的开销，提高运行效率。它适用于短小、频繁调用的函数。 类内部定义的函数默认是inline的 1234class Math {public: int square(int x) { return x * x; }//✅默认inline}; 6.malloc和new的区别 特性 new / new[] malloc() / calloc() 语言 C++ C（C++ 兼容） 分配类型 适用于对象，调用构造函数 仅分配原始内存，不会调用构造函数 释放方式 delete / delete[] free() 返回类型 直接返回正确类型指针 返回 void*，需要手动转换类型 初始化 new 会初始化对象（默认构造或指定初始化） malloc 不会初始化（calloc 会零初始化） 异常处理 new 失败时抛出 std::bad_alloc 异常 malloc 失败时返回 NULL，需要手动检查 安全性 更安全，支持 RAII（如 std::unique_ptr） 可能导致类型错误，易发生内存泄漏 7.free和delete的区别 特性 delete / delete[] free() 适用语言 C++ C（C++ 兼容） 适用对象 new 分配的对象 malloc/calloc/realloc 分配的内存 析构函数 ✅ 调用析构函数 ❌ 不会调用析构函数 作用范围 对象销毁 + 释放内存 仅释放内存 使用方式 delete p; / delete[] p; free(p); 安全性 更安全，支持类对象的管理 仅适用于 C 语言风格的内存管理 类型安全 不需要强制转换 需要强制转换 void* 8.volatile关键字的使用与场景volatile关键字在编程中用于确保变量的可见性和防止编译器优化，其核心作用是告诉编译器每次访问变量时必须直接从内存中读取或写入，而不是使用寄存器中的缓存值。常用于嵌入式开发从硬件寄存器中读取数据 作用： 禁止编译器优化确保每次对变量的读写操作都直接作用于内存，而非寄存器中的临时值，避免因优化导致意外行为。 保证可见性当变量可能被外部因素（如硬件、其他线程、信号处理函数）修改时，确保程序能读取到最新值 9.C语言中struct和CPP语言中struct的区别 特性 C语言中的 struct C++中的 struct C++中的 class 默认访问控制 公有 (public) 公有 (public) 私有 (private) 成员函数 不支持 支持 支持 构造函数和析构函数 不支持 支持 支持 继承和多态 不支持 支持 支持 简单来说，C++中的struct和class非常相似，区别主要在于默认的访问控制权限，struct默认是public，而class默认是private。（在继承的时候也是如此）因此struct被用于保存数据结构，而class则用于描述抽象对象。 10.extern关键字extern 是 C 和 C++ 中的一个关键字，主要用于声明变量或函数的外部链接，意味着该变量或函数是在其他地方定义的，而不是当前文件中定义的。 11.explicit关键字用来声明类构造函数是显式调用的，而非隐式调用，可以阻止调用构造函数时进行隐式转换和赋值初始化。只可用于修饰单参构造函数，因为无参构造函数和多参构造函数本身就是显式调用的，再加上 explicit 关键字也没有什么意义。 声明 explicit 的构造函数，从而可以阻止编译器执行非预期 (往往也不被期望) 的类型转换，因为某些非预期的类型转换可能会引起意向不到的错误。 举例： 1234567891011121314151617181920#include &lt;iostream&gt;#include &lt;cstring&gt;using namespace std;class A{public: int var; A(int tmp) { var = tmp; }};int main(){ A ex = 10; // 发生了隐式转换 return 0;}// 在上述过程中，A ex = 10实际上是先执行了A ex1(10), A ex = ex1。先将10转为A类型的对象，然后将该对象转为ex 12.#define vs typedef 特性 #define typedef 本质 预处理指令，文本替换 类型定义，编译时处理 类型检查 无类型检查，仅仅是字符串替换 受C语言类型系统约束，更加安全 指针类型 可能导致意外错误（如 INT_PTR a, b） 遵循类型规则（如 INT_PTR_T a, b） 适用场景 定义常量、宏函数 定义类型别名，适用于结构体、指针等 可调试性 代码不易调试（文本替换可能引入问题） 更加直观，类型更加明确 使用 #define 仅当你需要定义常量或者宏函数时，如 #define PI 3.14。 使用 typedef 适用于定义复杂类型的别名，如 typedef struct、指针、数组等。 因此，typedef 在处理类型时比 #define 更安全、直观，而 #define 更适用于常量和宏。 13.memmovememmove 是 C 标准库中的一个内存操作函数，声明在 &lt;string.h&gt; 头文件中。它的作用是将一块内存区域的数据复制到另一块内存区域，即使两块区域存在重叠，也能保证数据不会被破坏。因为在发生重叠的时候，就开始倒序复制，就可以避免这个问题 14.auto类型推导 (1) auto 类型推导规则 auto 根据右值类型推导，但去掉 const 和引用。 即基础类型推导，推导结果和初始化表达式一致，忽略引用和const修饰符。如果要保留这些特性，那么需要加上&amp;和const auto&amp; 保持引用类型，适用于引用变量。 const auto&amp; 可保持 const 限定，避免去掉 const。 auto* 适用于指针类型，但 const 规则同样适用。 decltype(auto) 会保持表达式的原始类型。 (2) auto vs decltype(auto) 表达式 推导类型 auto x = a;(a 是 const int) int auto&amp; x = a; int&amp; const auto x = a; const int decltype(auto) x = a; const int decltype(auto) x = b; (b 是 int&amp;) int&amp; C++ 的 auto 极大地增强了代码的简洁性，同时遵循模板推导规则，可以合理地推导类型，减少冗余代码。但在使用时，仍需注意 const、引用和指针的影响，以避免意外的类型变更","link":"/2025/02/25/C++%E5%85%B3%E9%94%AE%E5%AD%97%E8%A7%A3%E6%9E%90/"},{"title":"在C++20的标准下实现自己的vector容器","text":"首先介绍一下vector的基本功能：vector是一个线性容器，他是一种动态数组，其内存管理是动态的，但元素的访问方式类似于静态数组（即通过索引直接访问） 相关知识介绍： std::allocator: 在所有的标准stl容器中，都是使用allocator来管理内存，这种管理方式只会申请原始内存，即没有初始化。（不同于new，申请内存的同时会在堆上构建 ==不使用new的原因是默认的new效率更低，同时使用allocator可以更好的控制对象的生命周期，允许在已分配的内存中按需构造析构对象==）。同时使用std::allocator_traits&lt;std::allocator&lt;T&gt;&gt;::construct和std::allocator_traits&lt;std::allocator&lt;T&gt;&gt;::destory来显示的构造或者析构对象。 类的基本知识：在C++ 11之后，新建一个类，哪怕没有声明任何一个函数，编译器会默认实现六个函数，分别是：默认构造函数，默认析构函数，拷贝构造函数，移动构造函数，拷贝赋值函数，移动赋值函数。 迭代器：在类中，再去定义一个迭代器类，来封装一个容器内对象类型的指针，同时重载一些运算符的实现 动态内存：vector在堆上新申请一片内存，当这个内存被用满之后，那么vector就要重新去申请一片内存，然后把之前的元素全部放入。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697#include &lt;memory&gt;#include &lt;stdexcept&gt;#include &lt;initializer_list&gt;#include &lt;algorithm&gt;#include &lt;iostream&gt;template &lt;typename T&gt;class Vector {private: T* data; size_t vec_size; size_t vec_capacity; std::allocator&lt;T&gt; allocator; // 扩容函数声明 void reserve(size_t new_capacity); // 快速排序函数声明 template&lt;typename Compare&gt; void quick_sort(typename Vector&lt;T&gt;::iterator first, typename Vector&lt;T&gt;::iterator last, Compare cmp);public: class iterator { T* ptr; public: explicit iterator(T* ptr) : ptr(ptr) {} T&amp; operator*() const { return *ptr; }//解引用操作符 T* operator-&gt;() const { return ptr; }//成员访问操作符 iterator&amp; operator++() { ++ptr; return *this; }//前缀加 iterator operator++(int) { iterator tmp = *this; ++(*this); return tmp; }//后缀加 iterator&amp; operator--() { --ptr; return *this; }//前缀减 iterator operator--(int) { iterator tmp = *this; --(*this); return tmp; }//后缀减 bool operator==(const iterator&amp; other) const { return ptr == other.ptr; } bool operator!=(const iterator&amp; other) const { return ptr != other.ptr; } iterator operator+(size_t n) const { return iterator(ptr + n); } iterator operator-(size_t n) const { return iterator(ptr - n); } }; class const_iterator : public iterator { public: explicit const_iterator(const T* ptr) : iterator(ptr) {} const T&amp; operator*() const { return iterator::operator*(); } const T* operator-&gt;() const { return iterator::operator-&gt;(); } }; // 构造函数声明 Vector() noexcept; explicit Vector(size_t n); Vector(size_t n, const T&amp; val); Vector(std::initializer_list&lt;T&gt; init); Vector(iterator begin, iterator end); Vector(const Vector&lt;T&gt;&amp; other); Vector(Vector&lt;T&gt;&amp;&amp; other) noexcept; // 赋值运算符声明 Vector&amp; operator=(const Vector&lt;T&gt;&amp; other); Vector&amp; operator=(Vector&lt;T&gt;&amp;&amp; other) noexcept; // 析构函数声明 ~Vector(); // 迭代器函数声明 iterator begin(); const_iterator const_begin() const; iterator end(); const_iterator const_end() const; // 访问元素函数声明 T&amp; operator[](size_t index); T&amp; at(size_t index); // 容量和大小函数声明 [[nodiscard]] size_t capacity() const; void set_capacity(size_t new_capacity); [[nodiscard]] bool empty() const; [[nodiscard]] size_t size() const; // 清空函数声明 void clear(); // 添加元素函数声明 void push_back(const T&amp; value); // 添加元素函数声明,移动添加 void push_back(T&amp;&amp; value); // 添加元素函数声明，直接构造 template&lt;typename... Args&gt; void emplace_back(Args&amp;&amp;... args); // 查找元素函数声明 const_iterator find(const T&amp; value) const; // 插入元素函数声明 void insert(iterator pos, const T&amp; value); // 删除元素函数声明 void erase(iterator pos); void pop_back(); // 访问首尾元素函数声明 T&amp; front() const; T&amp; back() const; // 交换函数声明 void swap(Vector&amp; other); // 友元函数声明 template &lt;typename U&gt; friend std::ostream&amp; operator&lt;&lt;(std::ostream&amp; os, const Vector&lt;U&gt;&amp; vec); // 快速排序函数声明 template&lt;typename Compare = std::less&lt;T&gt;&gt; void sort(iterator first, iterator last, Compare cmp = Compare()); // 函数重写 template&lt;typename Compare = std::less&lt;T&gt;&gt; void sort(Compare cmp = Compare());}; vector的私有属性1234T* data;//指向管理的数据的指针size_t vec_size;//容器内数据的数量size_t vec_capacity;//分配内容可容纳的对象的数量std::allocator&lt;T&gt; allocator;//容器内存管理器 vector的迭代器12345678910111213141516171819202122class iterator { T* ptr; public: explicit iterator(T* ptr) : ptr(ptr) {} T&amp; operator*() const { return *ptr; } T* operator-&gt;() const { return ptr; } iterator&amp; operator++() { ++ptr; return *this; }//前缀加 iterator operator++(int) { iterator tmp = *this; ++(*this); return tmp; }//后缀加 iterator&amp; operator--() { --ptr; return *this; }//前缀减 iterator operator--(int) { iterator tmp = *this; --(*this); return tmp; }//后缀减 bool operator==(const iterator&amp; other) const { return ptr == other.ptr; } bool operator!=(const iterator&amp; other) const { return ptr != other.ptr; } iterator operator+(size_t n) const { return iterator(ptr + n); } iterator operator-(size_t n) const { return iterator(ptr - n); }};class const_iterator : public iterator { public: explicit const_iterator(const T* ptr) : iterator(ptr) {} const T&amp; operator*() const { return iterator::operator*(); } const T* operator-&gt;() const { return iterator::operator-&gt;(); }}; 在C++11之后，除了iterator之后，还实现了const_iterator。迭代器内实现了各种常见指针操作的重载 vector的扩容操作在执行push_back，emplace_back, insert等操作后，vector可能需要扩容，此时需要调用reserve函数去堆上申请一块新的内存空间。在vector扩容的时候，通常扩充为之前的1.5~2倍大小 1234567891011121314151617181920212223template &lt;typename T&gt;void Vector&lt;T&gt;::set_capacity(size_t new_capacity) { if (new_capacity &lt;= vec_capacity) return; // 只在需要扩容时执行 reserve(new_capacity);}// 扩容函数实现template &lt;typename T&gt;void Vector&lt;T&gt;::reserve(size_t new_capacity) { if (new_capacity &lt;= vec_capacity) return; // 只在需要扩容时执行 T* new_data = std::allocator_traits&lt;std::allocator&lt;T&gt;&gt;::allocate(allocator, new_capacity); // 移动现有元素 for (size_t i = 0; i &lt; vec_size; i++) { std::allocator_traits&lt;std::allocator&lt;T&gt;&gt;::construct(allocator, &amp;new_data[i], std::move(data[i])); std::allocator_traits&lt;std::allocator&lt;T&gt;&gt;::destroy(allocator, &amp;data[i]); } // 释放旧内存 if (data) { std::allocator_traits&lt;std::allocator&lt;T&gt;&gt;::deallocate(allocator, data, vec_capacity); } data = new_data; vec_capacity = new_capacity;} vector的构造函数1234567Vector() noexcept;explicit Vector(size_t n);Vector(size_t n, const T&amp; val);Vector(std::initializer_list&lt;T&gt; init);Vector(iterator begin, iterator end);Vector(const Vector&lt;T&gt;&amp; other);Vector(Vector&lt;T&gt;&amp;&amp; other) noexcept; 首先是默认构造Vector() noexcept, noexcept表示不会抛出异常 然后是单参构造函数explicit Vector(size_t n),在C++11之前，对于单参构造函数，都要用explicit来避免隐式转化。在C++11之后，也可以堆多参构造函数使用 拷贝构造函数Vector(const Vector&lt;T&gt;&amp; other); 12345678template &lt;typename T&gt;Vector&lt;T&gt;::Vector(const Vector&lt;T&gt;&amp; other) : data(nullptr), vec_size(0), vec_capacity(0) { reserve(other.vec_size); for (size_t i = 0; i &lt; other.vec_size; ++i) { std::allocator_traits&lt;std::allocator&lt;T&gt;&gt;::construct(allocator, &amp;data[i], other.data[i]); } vec_size = other.vec_size;} 移动构造函数Vector&lt;T&gt;::Vector(Vector&lt;T&gt;&amp;&amp; other) noexcept : 123456789101112// 移动构造函数实现template &lt;typename T&gt;Vector&lt;T&gt;::Vector(Vector&lt;T&gt;&amp;&amp; other) noexcept : data(other.data), vec_size(other.vec_size), vec_capacity(other.vec_capacity), allocator(std::move(other.allocator)) { // 防止 other 析构时释放我们刚&quot;偷&quot;来的内存 other.data = nullptr; other.vec_size = 0; other.vec_capacity = 0;} 初始化列表构造 Vector(std::initializer_list&lt;T&gt; init);: 1234567891011// 初始化列表构造函数实现template &lt;typename T&gt;Vector&lt;T&gt;::Vector(std::initializer_list&lt;T&gt; init) : data(nullptr), vec_size(0), vec_capacity(0) { if (init.size() &gt; 0) { reserve(init.size()); for (size_t i = 0; i &lt; init.size(); ++i) { std::allocator_traits&lt;std::allocator&lt;T&gt;&gt;::construct(allocator, &amp;data[i], *(init.begin() + i)); } vec_size = init.size(); }} 迭代器构造函数Vector(iterator begin, iterator end); 12345678910// 迭代器构造函数实现template &lt;typename T&gt;Vector&lt;T&gt;::Vector(iterator begin, iterator end) : data(nullptr), vec_size(0), vec_capacity(0) { size_t count = end - begin; reserve(count); for (size_t i = 0; i &lt; count; ++i) { std::allocator_traits&lt;std::allocator&lt;T&gt;&gt;::construct(allocator, &amp;data[i], *(begin + i)); } vec_size = count;} vector的析构函数调用clear()函数，清空allocator分配的内存 123456789101112131415161718// 析构函数实现template &lt;typename T&gt;Vector&lt;T&gt;::~Vector() { clear();}// 清空函数实现template &lt;typename T&gt;void Vector&lt;T&gt;::clear() { for (size_t i = 0; i &lt; vec_size; i++) { std::allocator_traits&lt;std::allocator&lt;T&gt;&gt;::destroy(allocator, &amp;data[i]); } if (data) { std::allocator_traits&lt;std::allocator&lt;T&gt;&gt;::deallocate(allocator, data, vec_capacity); } data = nullptr; vec_size = 0; vec_capacity = 0;} vector添加元素的操作 push_back:有两种方法，一种是拷贝构造，一种是移动构造 12345678910111213141516171819template &lt;typename T&gt;void Vector&lt;T&gt;::push_back(const T&amp; value) {//拷贝原对象 if (vec_size == vec_capacity) { size_t new_capacity = (vec_capacity == 0) ? 1 : 2 * vec_capacity; reserve(new_capacity); } std::allocator_traits&lt;std::allocator&lt;T&gt;&gt;::construct(allocator, data+vec_size, value); ++vec_size;}template &lt;typename T&gt;void Vector&lt;T&gt;::push_back(T&amp;&amp; value) {//利用右值直接构造 if (vec_size == vec_capacity) { size_t new_capacity = (vec_capacity == 0) ? 1 : 2 * vec_capacity; reserve(new_capacity); } std::allocator_traits&lt;std::allocator&lt;T&gt;&gt;::construct(allocator, data+vec_size, std::move(value)); ++vec_size;} emplace_back 123456789101112131415161718// 添加元素函数实现，直接构造template &lt;typename T&gt;template&lt;typename... Args&gt;void Vector&lt;T&gt;::emplace_back(Args&amp;&amp;... args) { if (vec_size == vec_capacity) { size_t new_capacity = (vec_capacity == 0) ? 1 : 2 * vec_capacity; reserve(new_capacity); } // 使用完美转发构造新元素 std::allocator_traits&lt;std::allocator&lt;T&gt;&gt;::construct( allocator, data + vec_size, std::forward&lt;Args&gt;(args)... ); ++vec_size;} insert：利用迭代器实现了元素的定点插入 1234567891011121314// 插入元素函数实现template &lt;typename T&gt;void Vector&lt;T&gt;::insert(iterator pos, const T&amp; value) { size_t index = pos - begin(); if (vec_size == vec_capacity) { size_t new_capacity = (vec_capacity == 0) ? 1 : 2 * vec_capacity; reserve(new_capacity); } for (size_t i = vec_size; i &gt; index; --i) { std::allocator_traits&lt;std::allocator&lt;T&gt;&gt;::construct(allocator, &amp;data[i], std::move(data[i-1])); } std::allocator_traits&lt;std::allocator&lt;T&gt;&gt;::construct(allocator, &amp;data[index], value); ++vec_size;} vector中排序的使用这里使用了比较器模板，在 C++ 中，比较器模板允许你为算法（如排序、查找、优先级队列等）提供自定义的比较规则，同时保持代码的泛用性和高性能。以下是实现比较器模板的详细方法及示例： 比较器可以是 函数指针、函数对象（仿函数） 或 Lambda 表达式。它们需要满足以下条件： 接受两个相同类型的参数。 返回 bool 类型，表示两个元素的顺序关系。 这里在类中比较器模板的申明中，指定了Compare = std::less&lt;T&gt; 12345678910111213141516171819202122232425262728293031323334353637// 快速排序函数实现template &lt;typename T&gt;template &lt;typename Compare&gt;void Vector&lt;T&gt;::quick_sort(typename Vector&lt;T&gt;::iterator first, typename Vector&lt;T&gt;::iterator last, Compare cmp) { if (first &gt;= last) return; // 选择基准元素（此处选择中间元素） T pivot = *(first + (last - first) / 2); iterator left = first; iterator right = last - 1; // 分区操作 while (left &lt;= right) { while (cmp(*left, pivot)) ++left; while (cmp(pivot, *right)) --right; if (left &lt;= right) { std::swap(*left, *right); ++left; --right; } } // 递归排序 quick_sort(first, right + 1, cmp); quick_sort(left, last, cmp);}// 快速排序函数实现template &lt;typename T&gt;template &lt;typename Compare&gt;void Vector&lt;T&gt;::sort(iterator first, iterator last, Compare cmp) { quick_sort(first, last, cmp);}template &lt;typename T&gt;template &lt;typename Compare&gt;void Vector&lt;T&gt;::sort(Compare cmp) { quick_sort(begin(), end(), cmp);} ​","link":"/2025/05/02/C++%E5%AE%9E%E7%8E%B0Vector%E5%AE%B9%E5%99%A8/"},{"title":"在C++20的标准下实现一个线程池","text":"线程池是提前声明好的，是一种预先创建线程并重复利用它们来执行多个任务的并发编程技术。他可以对线程进行准确的资源控制，同时减少线程创建销毁的开销，并且对任务进行统一的管理。本文将讲一下如何实现一个简单的线程安全的线程池。首先是前置知识的介绍 线程std::thread和std::jthread std：：thread是在C++11中引入，一个 std::thread 对象代表了一个真实运行中的线程句柄（handle）。因此在使用thread的时候，必须要使用join（等待线程结束）或者detach（放弃对这个线程的管理）来告诉操作系统，这个线程句柄接下来要怎么处理。 std：：jthread是在C++20中引入，在std：：thread的基础上，实现了stop_token即取消支持。同时在离开作用域的时候，无需使用join，std：：jthread会自己实现join，来避免忘记使用join的情况 std：：thread和std：：jthread的共同之处： 均不支持拷贝赋值和拷贝构造，但是支持移动赋值和移动构造。原因也很简单，std：：thread所持有的句柄是单例的，只允许移动不准拷贝。 在使用时，接受可调用对象来调用单参构造函数，创建一个新的线程 互斥量std::mutex std::mutex的引入是用来保护共享数据免受从多个线程同时访问的同步原语。在CPP中，常见于使用std::lock_guard和std::unique_lock,来保证临界区的正常访问。 std::lock_guard: 简单固定，在创建锁的时候即立即固定，在生命周期结束的时候立即自动解锁。不提供unlock，lock选项，也不允许移动。 std：：unique_lock:提供lock和unlock的选项，同样的不允许拷贝赋值和拷贝构造，但是可以移动。它是独占式的拥有互斥量。 条件变量std::condition_variable条件变量std::condition_variable的出现是用于唤醒等待线程从而避免死锁。如果不采用条件变量，那么在等待进入临界区的时候，使用while(true)检查，不仅造成了CPU资源的浪费，同时还容易造成死锁。 在开发中，std::condition_variable 是与 std::mutex 一起使用的同步原语，它能用于阻塞一个线程，或同时阻塞多个线程，直至另一线程修改共享变量（条件）并通知 std::condition_variable。 cv.notify_one()和cv.notify_all()：通知一个或者所有在等待的线程，检查在wait中的条件。 条件变量的等待：cv.wait() void wait(std::unique_lock&lt;std::mutex&gt;&amp; lock );:没有实现避免虚假唤醒（这是一定存在的，它是一种内核的行为。及没有发生notify但是却被唤醒）的方法，必须在while循环中使用 template&lt; class Predicate &gt;` void wait( std::unique_lock&lt;std::mutex&gt;&amp; lock, Predicate pred ); //实现了避免虚假唤醒的方法，接受一个谓词类型作为参数，来判断是否发生了虚假唤醒 期物std::future类模板 std::future 提供访问异步操作结果的机制，（通过 std::async、std::packaged_task 或 std::promise 创建的）异步操作能提供一个 std::future 对象给该异步操作的创建者 特性 std::async std::packaged_task std::promise 用途 自动运行异步任务并返回 future 封装函数任务，手动启动，返回 future 显式设置结果，获取 future 控制执行时机 否（由实现决定是否新线程） 是（手动调用） 是（你决定何时设置结果） 可传入函数 ✅ 是 ✅ 是 ❌ 否，只设置值 多用于哪种场景 一次性异步任务 自定义调度策略的异步任务 跨线程通信，或异步中断返回 原子量std：：atomicstd::atomic&lt;T&gt; 提供原子性访问，即不会被线程调度打断，也不会产生数据竞争。它支持的操作如 .store()、.load()、.exchange()、.compare_exchange_weak() 等都能保证线程安全。 在使用std：：atomic的时候，默认的内存顺序是 mememory_order_seq_cst最强顺序，全局顺序一致性，编译器和CPU都不能重排序 模式 类比关系 含义 relaxed 自扫门前雪 不管别人，自己原子执行即可 release 发出公告 把前面的写操作同步给别人 acquire 等待公告 拿到别人发布的写操作 seq_cst 一切都按顺序排队 所有线程看到同样的顺序 单例模式单例模式是指这个类只能有一个实例存在，并且通常在工具类中使用，比如数据库链接，线程池。要实现单例模式是不是要将构造和析构函数私有，然后所有的移动，拷贝赋值构造都被delete，提供一个getinstance方法来返回全局唯一的静态的类的实例 懒汉式：在第一次调用时才构造实例；节省资源，适用于高启动性能要求或可能从不使用的单例类 12345678910111213class LazySingleton {public: static LazySingleton&amp; getInstance() { static LazySingleton instance; // 局部静态变量线程安全（C++11） return instance; } LazySingleton(const LazySingleton&amp;) = delete; LazySingleton&amp; operator=(const LazySingleton&amp;) = delete;private: LazySingleton() = default;}; 饿汉式：类加载时就初始化实例，不等用的时候才创建；实例在程序开始时就存在，一定不会为 null； 1234567891011121314class EagerSingleton {public: static EagerSingleton&amp; getInstance() { return instance; } EagerSingleton(const EagerSingleton&amp;) = delete; EagerSingleton&amp; operator=(const EagerSingleton&amp;) = delete;private: EagerSingleton() = default; static EagerSingleton instance; // 饿汉式，程序启动时创建};EagerSingleton EagerSingleton::instance; // 定义并初始化 具体实现的线程池代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105#include &lt;vector&gt;#include &lt;queue&gt;#include &lt;thread&gt;#include &lt;mutex&gt;#include &lt;condition_variable&gt;#include &lt;future&gt;#include &lt;functional&gt;#include &lt;atomic&gt;#include &lt;memory&gt;class SingletonThreadPool { std::vector&lt;std::thread&gt; workers;//线程池 std::queue&lt;std::function&lt;void()&gt;&gt; tasks;//任务队列 std::mutex queue_mutex;//入任务队列的锁 std::condition_variable condition;//条件变量，控制任务被执行 std::atomic&lt;bool&gt; stop;//线程池是否结束 explicit SingletonThreadPool(size_t threads) : stop(false) { for (size_t i = 0; i &lt; threads; ++i) { workers.emplace_back([this] { while (true) {//线程要一直保持活跃状态 std::function&lt;void()&gt; task; {//这是使用一个代码块来保证unique_lock生命周期的正常结束 std::unique_lock&lt;std::mutex&gt; lock(this-&gt;queue_mutex); this-&gt;condition.wait(lock, [this] {//谓词函数，当线程池被停止，或者有任务的时候去执行任务 return this-&gt;stop.load() || !this-&gt;tasks.empty(); }); if (this-&gt;stop.load() &amp;&amp; this-&gt;tasks.empty()) return; task = std::move(this-&gt;tasks.front());//移动所有权，调用了移动赋值函数 this-&gt;tasks.pop(); }//unique_lock会自动释放掉 task();//function重载了()运算符，等价于：INVOKE&lt;R&gt;(f, std::forward&lt;Args&gt;(args)...) } });//直接传入一个可调用的对象（lambda函数），使用emplace_back来直接原地构造一个thread对象 } }public: //单例模式不需要任何的拷贝移动构造函数 SingletonThreadPool&amp; operator= (const SingletonThreadPool &amp;) = delete; SingletonThreadPool(const SingletonThreadPool &amp;) = delete; SingletonThreadPool(SingletonThreadPool &amp;&amp;) = delete; SingletonThreadPool&amp; operator= (SingletonThreadPool &amp;&amp;) = delete; //析构函数必须在public中声明，否则unique_ptr无法析构 ~SingletonThreadPool() { stop.store(true); condition.notify_all();//让所有未执行完的线程全部执行完 for (std::thread &amp;worker : workers)//必须用&amp;，否则会造成资源泄漏 if (worker.joinable()) worker.join();//回收所有的线程 } static SingletonThreadPool* get_thread_pool(size_t threads) { static std::unique_ptr&lt;SingletonThreadPool&gt; ptr(new SingletonThreadPool(threads)); //这里不可以使用make_unique，因为所有的构造函数都是private的，必须使用移动构造的方式赋值给unique_ptr return ptr.get(); } template&lt;class F, class... Args&gt; auto submit(F&amp;&amp; f, Args&amp;&amp;... args) -&gt; std::future&lt;std::invoke_result_t&lt;F, Args...&gt;&gt; { //invoke_result_t是对invoke(F,Args)的放回结果做预测，通过这种方式来去确定future包裹的是什么 using return_type = std::invoke_result_t&lt;F, Args...&gt;; //使用std::packaged_task封装函数任务，来自定义获取异步调用的结果 auto task = std::make_shared&lt;std::packaged_task&lt;return_type()&gt;&gt;( std::bind(std::forward&lt;F&gt;(f), std::forward&lt;Args&gt;(args)...)//将函数和参数绑定，实现一个可调用对象 ); std::future&lt;return_type&gt; res = task-&gt;get_future(); { std::lock_guard&lt;std::mutex&gt; lock(queue_mutex); if (stop.load()) throw std::runtime_error(&quot;submit on stopped ThreadPool&quot;); tasks.emplace([task]() { (*task)(); }); //lambda函数中使用参数来捕获了task，使用*task来获取包裹的可调用对象，在使用()来执行 } condition.notify_one();//通知一个线程，有新的任务加入 return res;//返回执行结果 }};// ==================== 使用示例 ====================#include &lt;iostream&gt;#include &lt;chrono&gt;int main() { auto pool = SingletonThreadPool::get_thread_pool(4); std::vector&lt;std::future&lt;int&gt;&gt; results; for (int i = 0; i &lt; 8; ++i) { results.emplace_back( pool-&gt;submit([i] { std::this_thread::sleep_for(std::chrono::milliseconds(100)); std::cout &lt;&lt; &quot;Task &quot; &lt;&lt; i &lt;&lt; &quot; done\\n&quot;; return i; }) ); } for (auto &amp;&amp;result : results) std::cout &lt;&lt; result.get() &lt;&lt; std::endl; return 0;}","link":"/2025/05/02/C++%E5%B9%B6%E8%A1%8C%E5%92%8C%E5%B9%B6%E5%8F%91/"},{"title":"C++智能指针和内存管理","text":"RAIIRAII即Resource Acquisition is Initialization（资源获取即初始化） 在智能指针中添加了引用计数的概念，引用计数这种计数是为了防止内存泄露而产生的。 基本想法是对于动态分配的对象，进行引用计数，每当增加一次对同一个对象的引用，那么引用对象的引用计数就会增加一次， 每删除一次引用，引用计数就会减一，当一个对象的引用计数减为零时，就自动删除指向的堆内存。 std::unique_ptrstd::unique_ptr 是一种智能指针，它通过指针持有并管理另一对象（对其负责），并在 unique_ptr 离开作用域时释放该对象。 在发生下列两者之一时，用关联的删除器释放对象：（总结就是这个unique_ptr不在指向这个对象） 管理它的 unique_ptr 对象被销毁。 通过 operator= 或 reset() 赋值另一指针给管理它的 unique_ptr 对象。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118#include &lt;cassert&gt;#include &lt;cstdio&gt;#include &lt;fstream&gt;#include &lt;iostream&gt;#include &lt;memory&gt;#include &lt;stdexcept&gt;// 用于下面运行时多态演示的辅助类struct B{ virtual ~B() = default; virtual void bar() { std::cout &lt;&lt; &quot;B::bar\\n&quot;; }};struct D : B{ D() { std::cout &lt;&lt; &quot;D::D\\n&quot;; } ~D() override{ std::cout &lt;&lt; &quot;D::~D\\n&quot;; } void bar() override { std::cout &lt;&lt; &quot;D::bar\\n&quot;; }};// 消费 unique_ptr 的函数能以值或以右值引用接收它std::unique_ptr&lt;D&gt; pass_through(std::unique_ptr&lt;D&gt; p){ p-&gt;bar(); return p;}// 用于下面自定义删除器演示的辅助函数void close_file(std::FILE* fp){ std::fclose(fp);}// 基于 unique_ptr 的链表演示struct List{ struct Node { int data; std::unique_ptr&lt;Node&gt; next; }; std::unique_ptr&lt;Node&gt; head; ~List() { // 循环按顺序销毁各列表节点，默认析构函数将会递归调用其 “next” 指针的析构函数， // 这在足够大的链表上可能造成栈溢出。 while (head) { auto next = std::move(head-&gt;next); head = std::move(next); } } void push(int data) { head = std::make_unique&lt;Node&gt;(data, std::move(head-&gt;next)); }};int main(){ std::cout &lt;&lt; &quot;1) 独占所有权语义演示\\n&quot;; { // 创建一个（独占）资源 std::unique_ptr&lt;D&gt; p = std::make_unique&lt;D&gt;(); // 转移所有权给 “pass_through”，而它再通过返回值将所有权转移回来 std::unique_ptr&lt;D&gt; q = pass_through(std::move(p)); // “p” 现在是已被移动的“空”状态，等于 nullptr assert(!p); } std::cout &lt;&lt; &quot;\\n&quot; &quot;2) 运行时多态演示\\n&quot;; { // 创建派生类资源并通过基类指向它 std::unique_ptr&lt;B&gt; p = std::make_unique&lt;D&gt;(); // 动态派发如期工作 p-&gt;bar(); } std::cout &lt;&lt; &quot;\\n&quot; &quot;3) 自定义删除器演示\\n&quot;; std::ofstream(&quot;demo.txt&quot;) &lt;&lt; 'x'; // 准备要读取的文件 { using unique_file_t = std::unique_ptr&lt;std::FILE, decltype(&amp;close_file)&gt;; unique_file_t fp(std::fopen(&quot;demo.txt&quot;, &quot;r&quot;), &amp;close_file); if (fp) std::cout &lt;&lt; static_cast&lt;char&gt;(std::fgetc(fp.get())) &lt;&lt; '\\n'; } // 在此调用 “close_file()”（如果 “fp” 为空） std::cout &lt;&lt; &quot;\\n&quot; &quot;4) 自定义 lambda 表达式删除器和异常安全性演示\\n&quot;; try { std::unique_ptr&lt;D, void(*)(D*)&gt; p(new D, [](D* ptr) { std::cout &lt;&lt; &quot;由自定义删除器销毁...\\n&quot;; delete ptr; }); throw std::runtime_error(&quot;&quot;); // “p” 是普通指针的情况下此处就会泄漏 } catch (const std::exception&amp;) { std::cout &lt;&lt; &quot;捕获到异常\\n&quot;; } std::cout &lt;&lt; &quot;\\n&quot; &quot;5) 数组形式的 unique_ptr 演示\\n&quot;; { std::unique_ptr&lt;D[]&gt; p(new D[3]); } // “D::~D()” 被调用 3 次} std::shared_ptrstd::shared_ptr 是一种智能指针，它能够记录多少个 shared_ptr 共同指向一个对象，从而消除显式的调用 delete，当引用计数变为零的时候就会将对象自动删除。 使用make_shared&lt;T&gt;(T&amp;&amp;... args),通过传入一个对象（make_shared内使用了完美转发）来获取这个对象类型的shared_ptr指针。 std::shared_ptr 可以通过 get() 方法来获取原始指针，通过 reset() 来减少一个引用计数， 并通过use_count()来查看一个对象的引用计数。 std::shared_ptr 是一种通过指针保持对象共享所有权的智能指针。多个 shared_ptr 对象可持有同一对象。下列情况之一出现时销毁对象并解分配其内存： 最后剩下的持有对象的 shared_ptr 被销毁； 最后剩下的持有对象的 shared_ptr 被通过 operator= 或 reset() 赋值为另一指针。 但是在下面代码，存在着内存泄漏的问题： 1234567891011121314151617181920212223#include &lt;memory&gt;#include &lt;iostream&gt;struct A;struct B;struct A { std::shared_ptr&lt;B&gt; pointer; ~A() { std::cout &lt;&lt; &quot;A 被销毁&quot; &lt;&lt; std::endl; }};struct B { std::shared_ptr&lt;A&gt; pointer; ~B() { std::cout &lt;&lt; &quot;B 被销毁&quot; &lt;&lt; std::endl; }};int main() { auto a = std::make_shared&lt;A&gt;(); auto b = std::make_shared&lt;B&gt;(); a-&gt;pointer = b; b-&gt;pointer = a;}//离开作用域的时候，std::shared_ptr都会被析构，但是Control block中的引用计数不为0，导致对象没有被析构从而引发内存泄漏 std::weak_ptrstd::weak_ptr 是一种智能指针，它持有被 std::shared_ptr 管理的对象的非拥有性“弱”引用。在访问引用的对象前必须先转换为 std::shared_ptr。（使用lock()） weak_ptr不持有对象的生命周期，不算入引用计数 但是可以用weak_ptr判断对象是否过期 std::weak_ptr 实现临时所有权：当某个对象只有存在时才需要被访问，且随时可能被他人删除时，可以使用 std::weak_ptr 来跟踪该对象，需要获得临时所有权时，将其转换为 std::shared_ptr。如果此时销毁了原始 std::shared_ptr，则对象的生命周期将被延长，直到临时 std::shared_ptr 也被销毁为止。 123456789101112131415161718192021222324252627282930#include &lt;memory&gt;#include &lt;iostream&gt;struct A;struct B;struct A { std::shared_ptr&lt;B&gt; pointer; void print() { std::cout &lt;&lt; &quot;A&quot; &lt;&lt;std::endl; } ~A() { std::cout &lt;&lt; &quot;A 被销毁&quot; &lt;&lt; std::endl; }};struct B { std::weak_ptr&lt;A&gt; pointer; void print() { std::cout &lt;&lt; &quot;B&quot; &lt;&lt;std::endl; } ~B() { std::cout &lt;&lt; &quot;B 被销毁&quot; &lt;&lt; std::endl; }};int main() { auto a = std::make_shared&lt;A&gt;(); auto b = std::make_shared&lt;B&gt;(); a-&gt;pointer-&gt;print(); //b-&gt;pointer-&gt;print(); error: base operand of '-&gt;' has non-pointer type 'std::weak_ptr&lt;A&gt;' b-&gt;pointer.lock()-&gt;print();} 引用计数的实现在cpp中，使用shared_ptr的时候，编译器会创建一个Control Block，控制块的实现思想主要是通过封装 引用计数 和 删除器 来确保对象的生命周期由多个智能指针共享时，能够安全、有效地管理资源的分配和释放。 控制块的概念 控制块是一个管理 shared_ptr 引用计数和其他元数据的结构。它包含了： 强引用计数（use_count）：追踪有多少个 shared_ptr 实例引用了这个对象。 弱引用计数（weak_count）：追踪有多少个 weak_ptr 引用了该对象，确保只有所有强引用计数为零时，控制块才会被销毁。 删除器（deleter）：负责销毁被管理的对象。当引用计数归零时，删除器会被调用来销毁对象。 分配器（allocator）：如果 shared_ptr 使用了自定义分配器，控制块也会包含该分配器的状态。 控制块的结构设计 控制块通常是一个独立的结构体或类，它和被管理对象的内存分开存储。这样设计的好处是能确保内存和对象的生命周期是独立管理的，避免了直接将对象和引用计数存在同一块内存中可能导致的效率问题。 下面是一个简单的control block的实现 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190#ifndef SHARED_PTR_H#define SHARED_PTR_H#pragma once#include &lt;iostream&gt;#include &lt;functional&gt;#include &lt;memory&gt;#include &lt;stdexcept&gt;// Forward declarationtemplate &lt;typename T&gt;class shared_ptr;struct ControlBlock { size_t ref_count; void* ptr; std::function&lt;void(void*)&gt; deleter; ControlBlock() : ref_count(0), ptr(nullptr), deleter([](void*){}) {} ControlBlock(size_t ref_count, void* ptr) : ref_count(ref_count), ptr(ptr), deleter([](void* p) {}) {} ControlBlock(size_t ref_count, void* ptr, std::function&lt;void(void*)&gt; d) : ref_count(ref_count), ptr(ptr), deleter(std::move(d)) {} ~ControlBlock() = default;};template &lt;typename T&gt;class shared_ptr { ControlBlock* control_block; T* ptr; void release();public: // Constructors shared_ptr() noexcept : control_block(nullptr), ptr(nullptr) {} explicit shared_ptr(T* p); shared_ptr(const shared_ptr&amp; other) noexcept; shared_ptr(shared_ptr&amp;&amp; other) noexcept; template &lt;typename... Args&gt; static shared_ptr&lt;T&gt; make_shared(Args&amp;&amp;... args); // Destructor ~shared_ptr(); // Assignment operators shared_ptr&amp; operator=(const shared_ptr&amp; other) noexcept; shared_ptr&amp; operator=(shared_ptr&amp;&amp; other) noexcept; // Pointer operations T&amp; operator*() const; T* operator-&gt;() const; T* get() const noexcept; void reset(T* p = nullptr); [[nodiscard]] size_t use_count() const noexcept; // Type conversion explicit operator bool() const noexcept; // Swap two smart pointers void swap(shared_ptr&amp; other) noexcept; // Comparison operations bool operator==(const shared_ptr&amp; other) const noexcept; bool operator!=(const shared_ptr&amp; other) const noexcept;};template &lt;typename T&gt;shared_ptr&lt;T&gt;::shared_ptr(T* p) : control_block(new ControlBlock(1, p)), ptr(p) {}template &lt;typename T&gt;shared_ptr&lt;T&gt;::shared_ptr(const shared_ptr&amp; other) noexcept : control_block(other.control_block), ptr(other.ptr) { if (control_block) { control_block-&gt;ref_count++; }}template &lt;typename T&gt;shared_ptr&lt;T&gt;::shared_ptr(shared_ptr&amp;&amp; other) noexcept : control_block(other.control_block), ptr(other.ptr) { other.control_block = nullptr; other.ptr = nullptr;}template &lt;typename T&gt;template &lt;typename... Args&gt;shared_ptr&lt;T&gt; shared_ptr&lt;T&gt;::make_shared(Args&amp;&amp;... args) { return shared_ptr&lt;T&gt;(new T(std::forward&lt;Args&gt;(args)...));}template &lt;typename T&gt;shared_ptr&lt;T&gt;::~shared_ptr() { release();}template &lt;typename T&gt;void shared_ptr&lt;T&gt;::release() { if (control_block) { control_block-&gt;ref_count--; if (control_block-&gt;ref_count == 0) { if (ptr) { control_block-&gt;deleter(ptr); } delete control_block; } }}template &lt;typename T&gt;shared_ptr&lt;T&gt;&amp; shared_ptr&lt;T&gt;::operator=(const shared_ptr&amp; other) noexcept { if (this != &amp;other) { release(); control_block = other.control_block; ptr = other.ptr; if (control_block) { control_block-&gt;ref_count++; } } return *this;}template &lt;typename T&gt;shared_ptr&lt;T&gt;&amp; shared_ptr&lt;T&gt;::operator=(shared_ptr&amp;&amp; other) noexcept { if (this != &amp;other) { release(); control_block = other.control_block; ptr = other.ptr; other.control_block = nullptr; other.ptr = nullptr; } return *this;}template &lt;typename T&gt;T&amp; shared_ptr&lt;T&gt;::operator*() const { // Dereference operator if (ptr == nullptr) { throw std::runtime_error(&quot;Attempting to dereference a null pointer&quot;); } return *ptr;}template &lt;typename T&gt;T* shared_ptr&lt;T&gt;::operator-&gt;() const { // Arrow operator for accessing members return ptr;}template &lt;typename T&gt;T* shared_ptr&lt;T&gt;::get() const noexcept { return ptr;}template &lt;typename T&gt;void shared_ptr&lt;T&gt;::reset(T* p) { release(); ptr = p; control_block = new ControlBlock(1, p, [](void* p) { delete static_cast&lt;T*&gt;(p); });}template &lt;typename T&gt;size_t shared_ptr&lt;T&gt;::use_count() const noexcept { if(control_block) { return control_block-&gt;ref_count; } return 0;}template &lt;typename T&gt;bool shared_ptr&lt;T&gt;::operator==(const shared_ptr&amp; other) const noexcept { return ptr == other.ptr;}template &lt;typename T&gt;bool shared_ptr&lt;T&gt;::operator!=(const shared_ptr&amp; other) const noexcept { return ptr != other.ptr;}template &lt;typename T&gt;shared_ptr&lt;T&gt;::operator bool() const noexcept { return ptr != nullptr;}template &lt;typename T&gt;void shared_ptr&lt;T&gt;::swap(shared_ptr&amp; other) noexcept { std::swap(control_block, other.control_block); std::swap(ptr, other.ptr);}#endif //SHARED_PTR_H","link":"/2025/05/02/C++%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88%E5%92%8C%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/"},{"title":"C++编译与内存相关","text":"1.cpp文件从解析到执行发生了什么？ 预处理：.cpp文件经过预处理生成文本文件.i格式的文件。在这个过程中，对原始的cpp文件中删除注释，展开宏等等。以方便进行下一步处理 编译+汇编：依据在预处理阶段生成的.i文件，进行词法、语法分析和语义检查，之后使用机器字进行替代，转为由汇编语言组成的.o文件 链接：根据编译阶段生成的.o文件，以及静态链接库.a或者动态链接库.so。这由链接方式决定。将.o文件和其执行所需要的库文件进行链接，生成最终的可执行文件。此时也是在这个阶段，.o文件被组合为一个单独的可执行文件，并且生成一个ELF格式的文件。这个ELF文件包括了：可执行代码（.text段），数据（.data段），未初始化数据（.bss段），动态链接信息（如果需要），调试信息（如果启用）。**最终可执行文件的格式就是ELF文件。**ELF文件中保存的内容是编译后运行前生成的内容 加载：在程序执行时，操作系统的加载器会将ELF文件加载到内存中。加载器会根据ELF文件的头部信息（如程序头表和节区头表）确定各个段（如 .text、.data等）的内存位置，并将它们加载到内存中。随后，程序开始执行。 2.函数调用过程中内存发生了什么？现有如下代码： 12345678910void foo(int a) { int b = a + 1; // 函数执行完毕}int main() { int x = 10; foo(x); // 调用foo函数 return 0;} 栈帧： 栈帧是每个函数调用时在栈中分配的内存区域，它包含了函数的返回地址、调用者的栈帧指针、局部变量、参数等信息。栈帧的管理是栈内存结构的核心，每次发生新的函数调用，都会由新的栈帧被创建。通常存在寄存器 %rbp中 栈顶： 栈顶指向的是栈内存顶部的区域，它是栈中当前活动的地址位置。通常存在寄存器 %rsp中 发生函数调用时：首先新创建一个新的栈帧，然后将调用者调用的函数结束后的下一条指令的地址压入栈中（返回地址）。然后在将调用者的栈帧的栈指针压入栈中，以及一些上下文的寄存器状态。之后在从右到左依次向栈中压入函数参数，之后在压入一些局部变量。遵循着这样的顺序。 3.申请堆内存产生的内存碎片 由于程序申请堆内存空间是动态的，而堆内存的管理是操作系统或者内存管理程序分配或者回收的，因此不可避免的会产生内存碎片。 如何解决内存碎片： 内存池技术：提前分配好内存，用内存池来管理 垃圾回收机制：标记和整理内存来回收未使用的内存，以此来减少碎片 最佳适配算法：动态分配时选择最适合需求大小的内存块，避免过多的小碎片 合并内存空间：释放内存时，尝试将相邻的空闲内存块合并成更大的块 4.CPP的内存对齐 每种数据类型都有一个对齐要求，即它的起始地址必须是该对齐值的倍数。 要求内存对其可以减少访问内存的延时，来提升性能。 5.智能指针的介绍与使用 std::unique_ptr:是一种独占式的智能指针，意味着同一时刻只能有一个 unique_ptr 指向某个对象。同时 unique_ptr不允许赋值，只能通过 std::move转移所有权。当独占式指针超出作用域后，会自动销毁。 std::share_ptr:是一种共享的只能指针，多个 shared_ptr 可以共同拥有同一个对象，智能指针内部会使用引用计数来追踪有多少 shared_ptr 指向同一个对象。当这个引用计数为0的时候，就会释放掉共享指针 std::weak_ptr：是一种弱指针，std::weak_ptr 不影响对象的引用计数，它用于观察一个由 shared_ptr 管理的对象。用于避免由于循环引用（指两个struct中互相有指针互相引用，导致互相持有无法释放，用 weak_ptr就可以解决这个问题）导致 shared_ptr无法释放 总结：std::unique_ptr通过判断在不在作用域来销毁，而 std::share_ptr通过内部的引用计数来判断是否需要销毁。 在使用智能指针的时候，尽量避免手动new，这样会需要两次手动内存分配 6.大端与小端 大端存储：高字节在高位，符合人类手写习惯。适用于网络通讯协议 小端存储：低字节在低位，更适合计算机的运算。常见于x86_64机器 7.内存泄漏 内存泄漏：指的是程序动态分配的内存未被释放，导致内存长期占用，最终可能导致内存耗尽、程序崩溃等问题。比如new了一个堆空间，但是一直没有delete 如何避免内存泄漏： 避免手动管理内存，使用智能指针（C++） 使用 RAII 资源管理（C++）：将资源（内存、文件、锁、数据库连接等）与对象的生命周期绑定，确保资源在对象销毁时自动释放，防止资源泄漏。 解决循环引用问题和避免悬垂指针 8.include include “ “和include&lt;&gt;的区别：include “ “首先从当前源文件所在目录或用户指定的目录中搜索头文件，如果找不到，则去库文件中寻找。而include&lt;&gt;则是直接去库文件中寻找对应的头文件","link":"/2025/05/02/C++%E7%BC%96%E8%AF%91%E4%B8%8E%E5%86%85%E5%AD%98%E7%9B%B8%E5%85%B3/"},{"title":"C++语言特性相关","text":"1.左值引用右值引用左值（Lvalue，Locator Value）指的是可以被取地址的值，即在表达式结束后仍然存在的对象。例如，变量、数组元素、对象等都是左值。 左值引用用于绑定左值，并且通常用于传递和修改可变对象。 123int a = 10;int&amp; ref = a; // ref 绑定到 aref = 20; // 修改 ref 也会影响 a 右值（Rvalue，Right-hand value）指的是无法取地址的临时值，通常是表达式计算的结果，如字面量、临时变量等。 右值引用使用 &amp;&amp; 语法，用于绑定右值，使得右值可以被高效地移动，而不是复制。 12int&amp;&amp; rref = 10; // 10 是右值，可以绑定到右值引用std::cout &lt;&lt; rref &lt;&lt; std::endl; // 输出 10 左值引用 vs 右值引用 左值引用 &amp; 右值引用 &amp;&amp; 绑定对象 只能绑定左值 只能绑定右值 修改对象 可以修改 可以修改 适用场景 传递可变对象 移动语义、避免拷贝 常见用法 普通变量引用、函数参数 移动构造、移动赋值 2.左值引用和右值引用的转化 std::move():是一个转换工具，用于将左值强制转换为右值，从而触发移动语义 std::forward&lt;T&gt;():主要用于泛型编程，保证在模板参数传递时，保留左右值的原始属性，实现完美转发。 std::move_if_noexcept():在某些情况下，如果移动构造可能抛出异常，我们可能更希望使用拷贝构造。std::move_if_noexcept 可用于这种情况 3.指针的大小与用法 指针的大小和编译器的目标平台的位数，而与所指向的数据类型无关。如果是32位的机器，则指针的大小则是4Byte，如果是64位机器，那么指针的大小是8Byte。 指针存储变量的内存地址，使用 &amp; 获取地址，使用 * 解引用指针以访问数据。 指针作为函数参数：实现传址调用，允许函数直接修改原始数据。函数指针：用于回调机制或策略模式等 4.指针和引用的区别总结对比表 特性 指针 引用 是否需要初始化 不需要，可以为空 必须初始化 是否能重新指向 可以 不可以 是否可为空 可以指向 nullptr 不可以 是否有独立内存 是，占用内存存储地址 否，与原变量共用内存 是否可修改值 通过 * 解引用后可修改 可修改（除非 const 修饰） 典型应用场景 动态内存分配、数据结构 参数传递、引用更安全的别名 5.指针常量和常量指针常量指针（const T*）：指向的值不能修改，但指针本身的指向可以更改。（即只能读，不能修改） 指针常量（T* const）：指针本身的指向不能更改，但指向的值可以修改。 6.函数指针的定义函数指针 (Function Pointer) 是指向函数的地址的指针。与普通指针不同，函数指针指向的是可执行代码段中的函数入口地址，而非数据 函数指针的基本语法 定义函数指针的一般形式为： 1返回类型 (*指针变量名)(参数类型列表); 7.CPP中函数传递参数的方法在 C++ 中，函数传递参数的方式主要有以下几种： 值传递（Pass by Value） 形参是实参的副本，在函数内对参数的修改不会影响原始数据。 适用于基本数据类型，但对于大对象会导致不必要的拷贝开销。 1void func(int x) { x = 10; } 引用传递（Pass by Reference） 形参是实参的引用，函数内的修改会直接影响原始数据。 适用于需要修改参数的情况，或者避免拷贝大对象以提升效率。 1void func(int&amp; x) { x = 10; } 指针传递（Pass by Pointer） 形参是指向实参的指针，可以在函数内修改原数据。 需要检查指针是否为空，避免空指针访问错误。 1void func(int* x) { if (x) *x = 10; } 常量引用传递（Pass by Const Reference） 适用于大对象的只读传递，既避免了拷贝，又保证了数据不会被修改。 1void func(const std::string&amp; str) { std::cout &lt;&lt; str; } 右值引用传递（Pass by Rvalue Reference）（C++11及以上） 允许传递右值（临时对象），通常用于移动语义（move semantics），提高效率。 1void func(std::string&amp;&amp; str) { std::cout &lt;&lt; str; } 智能指针传递（Pass by Smart Pointer）（C++11及以上） 通过 std::shared_ptr 或 std::unique_ptr 传递对象，管理内存生命周期。 1void func(std::shared_ptr&lt;int&gt; ptr) { std::cout &lt;&lt; *ptr; } 不同的方式适用于不同的场景，应根据性能需求和数据安全性来选择合适的参数传递方式。 8.迭代器迭代器（Iterator）是 C++ STL（标准模板库） 中用于遍历容器（如 vector、list、map 等）的一种通用接口。迭代器提供了一种类似指针的方式来访问容器中的元素，同时又能适应不同类型的容器。 C++ 提供了 五种迭代器，分别适用于不同类型的容器和操作： 迭代器类型 说明 适用容器 输入迭代器 (InputIterator) 只能 从前向后读取 数据 istream_iterator 输出迭代器 (OutputIterator) 只能 向前写入 数据 ostream_iterator 前向迭代器 (ForwardIterator) 可读可写，可单向移动 forward_list 双向迭代器 (BidirectionalIterator) 可读可写，可双向移动 list、map、set 随机访问迭代器 (RandomAccessIterator) 可读可写，可随机跳转 vector、deque 常见 STL 容器的迭代器 容器 begin() end() 迭代器类型 vector vector&lt;int&gt;::iterator vector&lt;int&gt;::iterator 随机访问 list list&lt;int&gt;::iterator list&lt;int&gt;::iterator 双向 map map&lt;int, int&gt;::iterator map&lt;int, int&gt;::iterator 双向 set set&lt;int&gt;::iterator set&lt;int&gt;::iterator 双向 9.野指针和悬空指针野指针 vs 悬空指针 类别 定义 产生原因 如何修正 野指针 未初始化的指针，指向未知地址 1. 没有初始化 2. 释放后未置空 3. 超出作用域 初始化指针为 nullptr 悬空指针 指向已释放的无效内存 1. 释放后仍然访问 2. 作用域结束后访问 3. 二次释放 释放后将指针置空 10.类型转化static_cast vs dynamic_cast 特性 static_cast dynamic_cast 转换时间 编译时 运行时 是否安全检查 ❌ 无检查 ✅ 运行时检查 适用范围 基本类型、多态类型、void* 仅适用于多态类型 转换失败时 未定义行为 返回 nullptr（指针）/ 抛异常（引用） 速度 ⚡ 高效 🐢 慢（因运行时检查） 四种转换方式对比 转换类型 转换方式 运行时检查 适用范围 推荐使用情况 static_cast 编译时转换 ❌ 无 兼容类型转换 ✅ 用于安全转换，如 int → double dynamic_cast 运行时转换 ✅ 有 多态类型（有虚函数） ✅ 适用于父子类转换，确保安全 const_cast 移除/添加 const ❌ 无 指针/引用 ✅ 需要修改 const 变量时 reinterpret_cast 低级转换 ❌ 无 指针/整数/位级转换 ⚠️ 极少使用，仅用于底层编程","link":"/2025/02/25/C++%E8%AF%AD%E8%A8%80%E7%89%B9%E6%80%A7%E7%9B%B8%E5%85%B3/"},{"title":"C++语言运行期的强化","text":"lambda表达式 基础：lambda表达式的基本语法如下： 123[捕获列表](参数列表) mutable(可选) 异常属性 -&gt; 返回类型 {// 函数体} 在其中，捕获列表起到了传递外部数据的作用，根据传递的行为，捕获列表可以分为以下几种： 值捕获：与参数传值类似，值捕获的前提是变量可以拷贝，不同之处则在于，被捕获的变量在 Lambda 表达式被创建时拷贝， 而非调用时才拷贝。（在Lambda表达式被传建的时候，会对捕获的变量保存一个内部的拷贝，在修改捕获变量的值不会影响结果） 1234567891011void lambda_value_capture() { int value = 1; auto copy_value = [value] { return value; }; value = 100; auto stored_value = copy_value(); std::cout &lt;&lt; &quot;stored_value = &quot; &lt;&lt; stored_value &lt;&lt; std::endl; // 这时, stored_value == 1, 而 value == 100. // 因为 copy_value 在创建时就保存了一份 value 的拷贝} 引用捕获：引用捕获保存的是引用，获取最新的捕目标的值 1234567891011void lambda_reference_capture() { int value = 1; auto copy_value = [&amp;value] { return value; }; value = 100; auto stored_value = copy_value(); std::cout &lt;&lt; &quot;stored_value = &quot; &lt;&lt; stored_value &lt;&lt; std::endl; // 这时, stored_value == 100, value == 100. // 因为 copy_value 保存的是引用} 隐式捕获：让编译器自己去猜测要捕获的变量 [] 空捕获列表 [name1, name2, …] 捕获一系列变量 [&amp;] 引用捕获, 从函数体内的使用确定引用捕获列表 [=] 值捕获, 从函数体内的使用确定值捕获列表 函数对象包装器 std::function：std::function 是一种通用、多态的函数封装， 它的实例可以对任何可以调用的目标实体进行存储、复制和调用操作， 它也是对 C++ 中现有的可调用实体的一种类型安全的包裹（相对来说，函数指针的调用不是类型安全的）， 换句话说，就是函数的容器。 std::bind和 std::placeholder,std::bind 则是用来绑定函数调用的参数的， 它解决的需求是我们有时候可能并不一定能够一次性获得调用某个函数的全部参数，通过这个函数， 我们可以将部分调用参数提前绑定到函数身上成为一个新的对象，然后在参数齐全后，完成调用。而 std::placeholder则是占位函数，用于表明调用时用户来提供函数 123456789101112131415161718192021#include &lt;iostream&gt;#include &lt;functional&gt;class MyClass {public: void print(int x) { std::cout &lt;&lt; &quot;Value: &quot; &lt;&lt; x &lt;&lt; std::endl; }};int main() { MyClass obj; // 绑定成员函数，需要提供实例对象 auto boundFunc = std::bind(&amp;MyClass::print, &amp;obj, std::placeholders::_1); // 调用绑定的函数，相当于 obj.print(42) boundFunc(42); return 0;} 右值引用 左值：左值是表达式（不一定是赋值表达式）后依然存在的持久对象 右值：右值指表达式结束后就不再存在的临时对象 纯右值：纯粹的右值，要么是纯粹的字面量，例如 10, true； 要么是求值结果相当于字面量或匿名临时对象，例如 1+2。非引用返回的临时变量、运算表达式产生的临时变量、 原始字面量、Lambda 表达式都属于纯右值 将亡值：即将被销毁、却能够被移动的值 右值引用和左值引用: 要拿到一个将亡值，就需要用到右值引用：T &amp;&amp;，其中 T 是类型。 右值引用的声明让这个临时值的生命周期得以延长、只要变量还活着，那么将亡值将继续存活 1234567891011121314151617181920212223242526272829#include &lt;iostream&gt;#include &lt;string&gt;void reference(std::string&amp; str) { std::cout &lt;&lt; &quot;左值&quot; &lt;&lt; std::endl;}void reference(std::string&amp;&amp; str) { std::cout &lt;&lt; &quot;右值&quot; &lt;&lt; std::endl;}int main(){ std::string lv1 = &quot;string,&quot;; // lv1 是一个左值 // std::string&amp;&amp; r1 = lv1; // 非法, 右值引用不能引用左值 std::string&amp;&amp; rv1 = std::move(lv1); // 合法, std::move可以将左值转移为右值 std::cout &lt;&lt; rv1 &lt;&lt; std::endl; // string, const std::string&amp; lv2 = lv1 + lv1; // 合法, 常量左值引用能够延长临时变量的生命周期 // lv2 += &quot;Test&quot;; // 非法, 常量引用无法被修改 std::cout &lt;&lt; lv2 &lt;&lt; std::endl; // string,string, std::string&amp;&amp; rv2 = lv1 + lv2; // 合法, 右值引用延长临时对象生命周期 rv2 += &quot;Test&quot;; // 合法, 非常量引用能够修改临时变量 std::cout &lt;&lt; rv2 &lt;&lt; std::endl; // string,string,string,Test reference(rv2); // 输出左值 return 0;} 完美转发在作参数转发的时候，保证左值和右值可以被正确的传递 1234567891011121314151617181920212223242526272829#include &lt;iostream&gt;#include &lt;utility&gt;void reference(int&amp; v) { std::cout &lt;&lt; &quot;左值引用&quot; &lt;&lt; std::endl;}void reference(int&amp;&amp; v) { std::cout &lt;&lt; &quot;右值引用&quot; &lt;&lt; std::endl;}template &lt;typename T&gt;void pass(T&amp;&amp; v) { std::cout &lt;&lt; &quot; 普通传参: &quot;; reference(v); std::cout &lt;&lt; &quot; std::move 传参: &quot;; reference(std::move(v)); std::cout &lt;&lt; &quot; std::forward 传参: &quot;; reference(std::forward&lt;T&gt;(v)); std::cout &lt;&lt; &quot;static_cast&lt;T&amp;&amp;&gt; 传参: &quot;; reference(static_cast&lt;T&amp;&amp;&gt;(v));}int main() { std::cout &lt;&lt; &quot;传递右值:&quot; &lt;&lt; std::endl; pass(1); std::cout &lt;&lt; &quot;传递左值:&quot; &lt;&lt; std::endl; int v = 1; pass(v); return 0;} 无论传递参数为左值还是右值，普通传参都会将参数作为左值进行转发； 由于类似的原因，std::move 总会接受到一个左值，从而转发调用了 reference(int&amp;&amp;) 输出右值引用。 唯独 std::forward 即没有造成任何多余的拷贝，同时完美转发(传递)了函数的实参给了内部调用的其他函数","link":"/2025/05/02/C++%E8%AF%AD%E8%A8%80%E8%BF%90%E8%A1%8C%E6%9C%9F%E7%9A%84%E5%BC%BA%E5%8C%96/"},{"title":"Linux中的中断和异常","text":"中断和异常的初步介绍在逻辑电路的层面，中断被定义为一个信号，用来改变处理器的指令执行顺序。这里的中断被分为同步中断和异步中断： 同步中断：由处理器自发产生，它一定发生在一条指令执行完之后 异步中断：有其它设备按照处理器的时钟随机产生 既然发生了中断，就说明需要对应的中断处理程序==中断处理程序不是进程，它更应该被视为一种CPU对硬件事件的响应机制，是一种软硬件结合的“执行路径抽象”==，出于性能的需求，中断处理程序必须满足：简短，高效且不可阻塞的。其中中断有不同的种类，所有的中断都用无符号八位数来标识，这个标识被英特尔称为向量。 上面所说的是学习用的通俗理解，在现代的Linux内核中，中断真正的处理往往采用：中断上下文 + 延迟处理机制 方式的结合，来高效的处理中断。在本文的最后会给出现代Linux内核处理的详细解释和介绍。 注意，在上面的中断是包括了同步中断和异步中断，后面，在intel开发手册中，将同步中断定义为异常，异步中断则定义为中断。中断具体指代什么，要在具体的语境中去理解。 异常异常是CPU在执行指令的时候，探测到的一个反常的问题。异常可以分为三种：故障(fault)，陷阱(trap)，错误(error)。 异常处理异常处理的流程可以概括为：程序执行中触发异常 → CPU 根据中断向量跳转 → 自动保存部分上下文并切换到内核态 → 执行trap入口 → 调用C语言trap处理函数 → 执行具体异常处理逻辑 → 恢复上下文 → 返回用户态。 在执行期间，如果发生除零错误、page fault、非法指令或系统调用等情况，CPU会立即响应异常。对于系统调用这种人为触发的trap，也会走统一的异常处理路径。 触发异常后，CPU会自动保存部分关键上下文（如PC、CS、EFLAGS），并切换到内核栈和内核态，再根据中断向量表跳转到对应trap handler入口。 trap handler汇编代码会进一步保存所有通用寄存器内容，并最终调用高级语言编写的trap处理函数（如Linux中的do_page_fault等）。处理函数会根据异常类型决定是修复（如分配页框）还是终止进程。 处理完成后，内核恢复用户态上下文，并使用iret/sysret等指令返回用户态，继续程序执行（如果未被终止）。 中断中断则是由外部的硬件设备所引起的，中断分为两种，可屏蔽中断和不可屏蔽中断。其中，IO设备所产生的中断都是可屏蔽中断。 中断处理每个能发出中断请求的硬件设备都会通过一条 IRQ 线连接到 PIC（可编程中断控制器）。PIC 监视这些 IRQ 线，当检测到有中断信号时，会将对应的中断向量编号准备好，并通过 INTR 线向 CPU 发送中断请求。 CPU 收到 INTR 信号后，会发出 INTA（中断确认）信号，PIC 会将中断向量号发送到数据总线。CPU 读取该向量号后，用它去中断描述符表（IDT）中查找并跳转到对应的中断服务程序。 后续处理中断的流程（切换内核态、保存上下文、执行 handler、恢复现场）与异常处理类似，但中断源于外设，异常则是程序执行错误引发。 ==注：这里的PIC是单一CPU上的概念，现在更多使用的是APIC，即高级可编程中断控制器。即APIC接收所有的IRQ线，然后通过ICC（中断控制通信总线）来在SMP（Symmetric Multi-Processing，对称多处理器）下和其他的CPU通讯== 值得注意的是，并不是所有的IRQ和硬件设备都是一一对应的，IRQ的数量是有限的，会出现一个IRQ映射到多个可以发出中断请求的硬件设备的情况。例如IRQ43既可以分配给声卡，也可以分配给USB端口。而处理这种情况主要有两种方式： IRQ共享：每个硬件设备被抽象为一个 IRS（中断请求源），当中断控制器检测到某个 IRQ 线（或 MSI 中断）触发时，它会将对应的中断号传递给 CPU。内核通过中断号在 irq_desc[] 中查找到对应的中断处理程序列表，然后调用已注册的 ISR（中断服务例程）。如果该中断号上注册了多个共享 ISR，则会遍历这些 ISR，以确定哪个设备实际触发了中断。 IRQ动态分配：引入了虚拟IRQ的概念，一条IRQ线可能在最后时刻才会与一个设备驱动程序相关联。通过动态分配的方式，使得IRQ可以挂载更多的硬件设备，并且支持热插拔。 中断处理程序和异常处理程序的嵌套首先要明确的一点是，在进行中断处理程序或者异常处理程序的时候，CPU是处于中断上下文的，这个时候禁用了调度器，所以无法发生进程切换。关于中断处理程序和异常处理程序的嵌套： 中断处理程序可以被更高级的中断处理程序打断 异常处理程序可以被中断处理程序打断，反之则不可以 Linux中的中断处理在 Linux 内核中，中断处理被设计成一个分层体系，除了硬件触发的硬中断（硬中断处理程序），即中断上下文中的上半部分处理，还包括延迟执行的软中断（SoftIRQ） 和 tasklet，它们被广泛用于中断上下文中的下半部分处理。 部分 名称 执行位置 特点 上半部分 硬中断处理程序（ISR） 中断上下文 响应快，执行短，不可阻塞 下半部分 软中断（SoftIRQ）、tasklet、工作队列（workqueue） 进程上下文或中断上下文（非抢占） 延迟处理，功能丰富 在 Linux 中，中断处理被划分为“上半部分”和“下半部分”两层结构，其中上半部分（即中断服务例程，ISR）主要负责快速响应中断事件，通常只执行一些必要且简短的操作。具体而言，它的核心职责包括：清除中断标志位以避免中断抖动、保存设备状态（如读入寄存器值）、以及调度下半部分处理逻辑的入口函数（如tasklet_schedule()或 raise_softirq()）。 由于 ISR 运行在中断上下文中，不允许阻塞或进行复杂处理，Linux 要求其尽可能快速返回，以避免中断屏蔽时间过长、影响系统整体响应性能。 因此，真正的业务逻辑处理——例如网络数据包解析、磁盘数据传输、状态更新等，通常放在下半部分执行。这些延迟执行的处理可以通过软中断（softirq）、tasklet 或工作队列（workqueue）实现，分别适用于不同的实时性、可阻塞性和并发需求。这样设计既保证了中断响应的实时性，也提升了系统的并发处理能力和整体调度灵活性。","link":"/2025/05/29/Linux%E4%B8%AD%E7%9A%84%E4%B8%AD%E6%96%AD%E5%92%8C%E5%BC%82%E5%B8%B8/"},{"title":"C++面向对象","text":"1.面向对象的三大特性：封装，继承，多态 2.重载、**重写 和 **隐藏 对比项 重载（Overloading） 重写（Overriding） 隐藏（Hiding） 作用域 同一个类 继承体系（子类 vs. 父类） 继承体系（子类 vs. 父类） 函数名 相同 相同 相同 参数列表 必须不同 必须相同 可相同或不同 返回类型 可以不同，但不影响重载 不能改变（C++11 允许协变返回类型） 可以不同 访问方式 直接调用 通过基类指针或引用调用 直接调用 虚函数 无关 必须是 virtual 无关 影响 编译期选择不同方法 运行时调用子类方法（动态绑定） 隐藏父类同名方法，必须使用 Base::func() 访问 重载（Overloading） 发生在同一个类，参数不同，返回值可以不同，属于编译期多态。 重写（Overriding） 发生在继承体系，子类重写基类的虚函数，必须函数签名（用于在重载时标识不同的函数）一致，属于运行时多态。 隐藏（Hiding） 发生在继承体系，但不是虚函数重写，而是子类定义了同名函数，隐藏了父类版本，调用父类方法需要 Base::func()。 在实践中，虚函数重写是 OOP 里最重要的特性，它允许多态行为，而隐藏可能导致代码难以维护，因此建议避免让子类的方法隐藏父类的方法，除非有特殊需求。 3.多态及其实现办法 多态分为运行时多态（通过虚函数实现）和编译时多态（通过函数重载和模板实现）。 运行时多态执行的核心步骤 （运行时多态，虚函数必须为 virtual,否则可能会引起内存泄漏） 对象构造时初始化虚函数指针（vptr，存储在对象的实例内存中） 当对象被构造时，编译器会隐式地在对象内存中插入一个指向**虚函数表（vtable）**的指针（vptr）。 vptr 的值由对象的实际类型决定。例如： Base 类型的对象，vptr 指向 Base 的虚函数表。 Derived 类型的对象，vptr 指向 Derived 的虚函数表。 虚函数表（vtable）的结构 （存储在只读数据段中，并且全局唯一） 每个有虚函数的类都有一个对应的虚函数表（静态存储区）。 虚函数表是一个函数指针数组，每个条目指向该类的虚函数实现。 若派生类覆盖了基类的虚函数，则虚函数表中对应的条目会被替换为派生类的函数地址。 通过基类指针或引用调用虚函数 当通过基类指针或引用调用虚函数时，编译器会生成代码： 从对象的 vptr 找到对应的虚函数表。 根据虚函数在表中的索引（由编译器确定）找到函数地址。 调用该函数地址指向的实现。 4.虚函数和纯虚函数在虚函数中，基类需要提供默认实现，并且基类是可以实例化的。但是在纯虚函数中，基类不提供实现（但是可以定义，但是使用必须显示的使用），同时基类不允许被实例化，并且派生类必须覆盖，要给出纯虚函数的实现，否则仍然是抽象类。（只要类中有一个纯虚函数，那么这个类就不能被初始化） 纯虚函数更多的应用在接口之中，来实现接口和实现的分离，充分体现面向对象的特性。此外，纯虚函数也和虚函数一样，要指定虚构函数，并且为`virtual` 为什么纯虚类的构造函数必须是`virtual`的：因为多态对象的析构是从派生类开始到基类结束的，只有这样才能保证内存被正确的释放。在析构时，需要动态调用来保证资源的全部释放。 5.多继承在 CPP中，与 Java不同的一点是 CPP允许多继承。 123class Derived : public Base1, public Base2 { // ...}; 但是在多继承中，常见的问题是二义性问题，和棱形问题 菱形问题： 当一个派生类从两个或多个基类继承，而这些基类又共同继承自同一个基类时，会导致二义性 和数据冗余 。用虚继承可以解决这个问题 二义性问题： 如果多个基类有同名成员，直接访问会引发编译错误。用显式指定基类的作用域可以解决这个问题。 6.深拷贝和浅拷贝 深拷贝：会重新复制内容并且分配内存，并且每个对象独立管理其对应的内存（类似于 unique_ptr） 浅拷贝：只会复制指针的地址，并且多个对象共享同一块内存。但是可能会导致double free，悬垂指针的问题。 此外资源管理类 必须遵循”Rule of Three “： 如果定义了析构函数、拷贝构造函数或赋值运算符中的任意一个，通常需定义全部三个 7.Base* ptr = new Derived()的一些理解 首先是Base* ptr，这表明ptr是静态类型Base*,并且是保存在栈空间上的 然后ptr指向的是堆空间上的Derive()对象。这表明动态类型是Derived() 这里，由于Derived是继承的Base，因此在Derived的堆空间中，结构是这样的（如果Base有虚函数），同时Base中的属性也会被继承下来（无论是否private）只不过在Derived中无法访问。 12345678堆上的 Derived 对象：+------------------+| vptr(指向Derived) |+------------------+| base_data |+------------------+| derived_data |+------------------+ 注意，这里的Base* ptr只能访问Base类中的属性和方法。当访问Base中的虚函数时，编译器会因为访问虚函数，因此触发动态调用，使用虚函数表指针去虚函数表中寻找 8.单继承和多继承的虚函数表单继承 只有 1 张 vtable，对象中只有 1 个 vptr。 调用虚函数时，vptr 访问 vtable，跳转到函数地址。 多继承 每个 Base 类有独立的 vtable，Derived 有多个 vptr。 访问 Base1 相关函数时，走 vptr1 → vtable_for_Base1。 访问 Base2 相关函数时，走 vptr2 → vtable_for_Base2。 9.如何禁止构造函数的使用 方法 适用场景 是否允许子类实例化 = delete 彻底禁止构造 ❌ private 构造函数 外部不能创建对象，但 friend 可创建 ❌ protected 构造函数 允许子类创建对象，但基类不可实例化 ✅ static 方法 通过 static 方法创建对象（单例模式） ❌ 抽象类（纯虚函数） 作为基类强制继承 ✅ 10.什么是默认构造函数默认构造函数是没有参数或所有参数都有默认值的构造函数。如果程序员没有显式定义构造函数，编译器会自动提供一个默认构造函数。 没有参数 或者 所有参数都有默认值。 用于创建对象时自动调用，初始化对象的成员变量。 如果没有显式定义，编译器会自动生成一个（但不会初始化成员变量）。 如果定义了其它带参数的构造函数，编译器不会再提供默认构造函数（C++11 之后）。 11.如何提高构造函数的效率使用成员初始化列表构造效率最高的原因：避免了默认构造和赋值的双重开销，而是直接调用构造函数 1234567891011class Example { std::string s;public: // 初始化列表：直接调用 std::string 的构造函数 Example() : s(&quot;Hello&quot;) {} // 构造函数体内赋值：先默认构造 s，再赋值 Example() { s = &quot;Hello&quot;; // 生成临时字符串对象，再赋值给 s }}; 优势从上面就显而易见 优化方法 适用场景 优化点 使用成员初始化列表 =&gt; A() : x(10), y(3.14) {} 成员变量的初始化 避免默认构造 + 赋值 避免不必要的构造 =&gt; void foo(A a) { } // ❌ void foo(const A&amp; a) { } // ✅ 传参、返回值 传引用、RVO 优化 使用 explicit 防止隐式转换 避免额外构造 避免 new 动态分配 资源管理 使用栈分配或智能指针 优化容器初始化 std::vector 等容器 直接初始化，避免扩容 使用 = default 编译器优化 让编译器自动优化 使用 std::move 资源移动优化 避免不必要的拷贝 12.类对象初始化顺序首先按照继承的顺序进行基类的初始化 –&gt; 然后按照成员变量的申明顺序初始化，和构造函数初始化列表中的顺序无关 –&gt; 然后进行构造函数体的执行 构造函数初始化列表指的是： 123Derived() : m2(&quot;m2&quot;), m1(&quot;m1&quot;) { // 初始化列表顺序：m2 → m1（实际顺序仍按声明） cout &lt;&lt; &quot;Derived constructor\\n&quot;;} 13.友元函数的作用和使用场景 运算符重载：当需要重载 &lt;&lt;或者 &gt;&gt;的时候，由于左操作数是 ostream 或 istream 跨类访问私有成员 工具函数需要访问私有数据 需要注意的是： 友元函数的注意事项 破坏封装性友元函数会暴露类的内部实现，需谨慎使用，避免过度依赖。 友元关系不可传递若类 A 是类 B 的友元，类 B 是类 C 的友元，类 A 不会自动成为 类 C 的友元。 友元声明的位置友元函数的声明必须出现在类的内部（通常在 public 或 private 区域，但权限不影响友元的访问能力）。 友元函数不是成员函数 友元函数不属于类的成员，没有 this 指针。 调用时直接通过函数名，而非对象（如 exchange(a, b)）。 友元类可以将整个类声明为友元： 123class A { friend class B; // 类 B 的所有成员函数都可以访问 A 的私有成员}; 14.静态绑定和动态绑定 绑定时机 编译时 运行时 函数类型 非虚函数、重载函数、模板函数 虚函数（virtual functions） 性能 无额外开销 需查虚函数表，有轻微开销 灵活性 固定，无法动态改变行为 灵活，支持多态 15.cpp模板编程C++ 模板编程是泛型编程的核心技术，允许你编写与类型无关的通用代码。模板编程也是一种多态 函数模板：用于创建通用函数，自动推导参数类型 类模板：用于创建通用类（如容器） 模板特化：为特定类型提供定制化实现 模板元编程：在编译期执行计算，例如计算阶乘 12345678910template &lt;int N&gt;struct Factorial { static const int value = N * Factorial&lt;N-1&gt;::value;};template &lt;&gt;struct Factorial&lt;0&gt; { // 终止条件 static const int value = 1;};// 使用std::cout &lt;&lt; Factorial&lt;5&gt;::value; // 输出 120（编译期计算） 16.如何避免不必要的拷贝来提高效率 使用引用或者指针来传递值 -&gt; 避免不必要的大型对象拷贝 针对资源管理类使用 std::move来移动所属权 尽可能的避免使用临时对象 17.实例化一个对象需要哪几个阶段 阶段 描述 1. 分配内存 在栈上或堆上分配存储空间 2. 调用构造函数 初始化对象、调用基类构造函数 3. 执行初始化 初始化成员变量，拷贝/移动构造等 4. 使用对象 调用方法、访问成员变量 5. 调用析构函数 释放资源，执行清理操作 对象的实例化并不仅仅是构造函数的调用，而是一个完整的生命周期管理过程 18.如何让类中的函数无法访问类的成员变量 方法 是否能访问成员变量 适用场景 static 成员函数 ❌ 无法访问 工具类、无状态函数 内部 private 类 ❌ 无法访问 数据封装，防止误操作 PIMPL 设计模式 ❌ 无法访问 API 设计，隐藏实现细节 friend 友元类 ✅ 友元可访问 需要控制访问权限 如果目标是让类的普通成员函数无法访问数据成员，最佳方案是使用 static 方法 或 隐藏数据（PIMPL、内部类）。 19.怎么限制类的对象只能创建在栈上或者堆上 限制在堆上： 将构造函数以及析构函数设为私有，同时提供一个静态的工厂函数用来返回在堆上创建的对象。（注意，这样做必须要手动释放堆空间，调用delete()直接delete this即可） 限制在栈上： 删除 new和 delete关键字，来禁止在堆上创建 12void* operator new(size_t) = delete; // 禁止 newvoid operator delete(void*) = delete; // 禁止 delete 20.类的默认私有继承和公有继承在继承中，父类的所有属性和操作都会被继承到子类中，但是由于继承的默认是私有继承，导致无法直接访问父类的方法。（在下面的代码中，如果是 class Test : Derived那么Test的实例t无法直接调用 t.Derived::foo()）。而在类中的 private,protected,public修饰的操作或者属性，仅仅用于类的不同访问者的访问权限。 123456789101112131415161718192021222324252627282930313233#include &lt;iostream&gt;using namespace std;class Base {public: virtual void foo() = 0; virtual void bar() = 0; virtual ~Base() = default;};class Derived : Base { // 需要 public 继承public: void foo() override { // override 关键字增强可读性 cout &lt;&lt; &quot;Derived::foo&quot; &lt;&lt; endl; } void bar() final { // 需要 override 来表明继承自 Base cout &lt;&lt; &quot;Derived::bar&quot; &lt;&lt; endl; }};class Test : public Derived{ // 需要 public 继承public: void foo() override { cout &lt;&lt; &quot;Test::foo&quot; &lt;&lt; endl; }};int main() { Derived d; d.foo(); d.bar(); Test t; t.foo(); t.Derived::foo(); // 这行仍然是合法的，但没有必要 return 0;}","link":"/2025/02/25/C++%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"},{"title":"Linux的进程","text":"进程的地址空间​ 处于隔离性的要求，每个进程所使用的地址为虚拟地址（VA），其中地址为0x0000000000000000 ~ 0xffffffffffffffff（合理取64位计算机为例）。进程的地址空间分为用户态地址和内核态地址，其中用户态和内核态的地址范围如下。 地址范围 所属 描述 0x0000000000000000 ~ 0x00007fffffffffff 用户态 每个进程私有，可访问 0xffff800000000000 ~ 0xffffffffffffffff 内核态 全系统共享，只有内核代码可访问 用户态的地址空间分布 我们可以将一个用户态进程的地址空间划分如下（从低地址到高地址） 12345678910111213141516+-------------------------+| 用户栈（Stack） | ← 通常从高地址向低地址增长+-------------------------+| mmap 区域（共享库、匿名映射） |+-------------------------+| 堆（Heap） | ← 从 brk 指向的起始地址向上增长+-------------------------+| BSS 段（未初始化全局/静态变量）|+-------------------------+| 数据段（Data） | ← 已初始化的全局/静态变量+-------------------------+| 代码段（Text） | ← 程序指令+-------------------------+| 空洞 / 对齐区域 |+-------------------------+| NULL | ← 通常地址空间的最低部分（保护访问） 用户态地址空间各段的解释： 区域 说明 代码段（.text） 存储可执行代码（只读、可执行） 数据段（.data） 存储已初始化的全局变量或静态变量（可读写） BSS段（.bss） 存储未初始化的全局变量或静态变量（占虚拟空间，运行时初始化为0） 堆（heap） 由 malloc() 等函数动态分配内存，向高地址扩展，由 brk() 或 mmap() 控制 mmap 映射区 用于映射共享库（如 libc.so）、匿名内存（如 mmap(NULL,...)）等，地址位置灵活（同时也是用户态线程栈的保存位置） 用户栈（stack） 默认大小通常为 8MB（可调），由内核在启动线程时创建，从高地址向低地址扩展 VDSO / vsyscall 提供某些用户态可调用的内核函数（如 gettimeofday()），提升性能 NULL 保留页 地址空间的最低页通常不映射，用于捕获非法指针访问（如 NULL dereference） 内核态的地址空间分布 12345678910111213141516171819202122232425262728用户空间（每进程私有）:0x0000_0000_0000_0000 ...0x0000_7fff_ffff_ffff ← 用户空间结束-------------------- 以下为所有进程全局共享的内核空间 --------------------内核空间（全局共享）:0xffff_8000_0000_0000 ← 内核空间起始 |- 直接映射区（physmap, linear mapping） | 0xffff_8000_0000_0000 ~ 0xffff_c7ff_ffff_ffff |- vmemmap 区（struct page 映射区，页框管理的数据结构） | 0xffff_ea00_0000_0000 ~ 0xffff_eeff_ffff_ffff |- vmalloc 区（动态虚拟内存分配，用于内存的动态分配） | 0xffff_c800_0000_0000 ~ 0xffff_dfff_ffff_ffff |- 模块映射区 | 0xffff_e000_0000_0000 ~ 0xffff_efff_ffff_ffff |- ioremap 区（PCI/IO设备动态映射，实际位于vmalloc子区） |- 内核镜像区（.text/.data/.bss, KASLR后地址随机） | 0xffffffff_80000000 ~ 0xffffffff_ffffffff |- fixmap 区 | 0xffff_fff0_0000_0000 ~ 0xffff_fff0_0fff_ffff |- vsyscall 区（已废弃，仅保留仿真） | 0xffff_ffff_fffc_0000 ~ 0xffff_ffff_fffd_0000 |- EFI/ACPI保留区（部分机器有） | 0xffff_ffe0_0000_0000 ~ 0xffff_ffff_ffff_ffff |- 其它保留或架构相关区块0xffff_ffff_ffff_ffff ← 虚拟地址上限 内核态各段的解释 区域 描述 直接映射物理内存区域（Direct mapping） 将所有物理内存直接线性映射进虚拟地址空间，常用宏 __va() 与 __pa() 转换 vmalloc 区 vmalloc() 申请的非连续物理页区域，适合分配大对象。实现虚拟地址到离散的物理地址的映射 模块映射区 加载的内核模块、驱动代码位置 内核代码段 &amp; 数据段 内核自身代码与静态数据区域（内核本身的代码，不可以修改） fixmap 区 用于映射特定设备地址或中断向量表，具有固定虚拟地址 ioremap 映射区 IO 设备的 MMIO 寄存器映射到的虚拟地址 进程的实体表示在Linux内核中，进程的实体表示是使用task_struct这一数据结构来表示的，在Linux中，Linux 采用 1:1 的线程实现模型，每个用户态线程对应一个内核态线程，内核通过 task_struct 来统一表示进程和线程，线程因此也被称作“轻量级进程”（Lightweight Process, LWP） 。轻量级进程会共享主进程的mm_struct，fs_struct，signal_struct等等这些内容，他们各自的task_struct是各不相同的。 下面是一个task_struct的基本结构： 1234567891011task_struct├── 基本标识：pid, tgid, comm, state├── 调度信息：prio, se, policy├── 内存信息：mm, active_mm├── 线程组信息：group_leader, thread_group├── 父子关系：real_parent, children├── 信号处理：signal, sighand├── 文件系统：fs, files├── 权限/命名空间：cred, nsproxy├── 调试/审计：audit_context, start_time├── 架构相关：thread_struct 基本标识：pid是进程的唯一标识，而tgid则是所在线程组组长的pid（主线程的pid） 调度信息：prio是优先级，se则是实际的调度实体，而policy则是调度的策略 内存信息：mm用户态内存描述符，是一个指向mm_struct的指针，active_mm则是线程当前使用的mm_struct，这是因为内核线程会借用其他进程的，VMA是虚拟内存区域，用来描述进程虚拟地址空间中一段连续虚拟内存区域的数据结构，可以管理进程的虚拟地址空间到物理地址的映射关系，采用了红黑树的数据结构来管理。 线程组信息：group_leader指向线程组的组长，thread_group则是线程组的内部链表 信号处理：signal是指向 signal_struct的，线程组共享; sighand则是指向sighand_struct（信号处理函数表） 文件系统：files指向files_struct，表明打开文件表;而fs则是维护文件系统的信息 进程的状态 从操作系统的宏观角度： 创建：正在创建进程，还未就绪 就绪：已准备好、等待被调度上 CPU 运行：正在 CPU 上执行 阻塞：等待 I/O 或资源，不能运行 终止：执行完毕或被终止，等待资源释放 从Linux内核的具体实现角度： TASK_RUNNING：可运行，可能在 CPU 上，也可能在 runqueue 中等待 TASK_INTERRUPTIBLE：可被信号打断的睡眠，常见于等待资源、I/O TASK_UNINTERRUPTIBLE：不可被信号打断的睡眠，如 I/O 阻塞 EXIT_ZOMBIE：已退出，变成僵尸进程，等待父进程回收 __TASK_STOPPED：被 SIGSTOP 暂停 __TASK_TRACED：被调试器（如 gdb）暂停、单步等状态 进程的创建在Linux中，进程的创建主要有，fork，vfork以及clone三种方式来创建进程。 系统调用 本质功能 地址空间复制 子进程执行时父进程状态 适用场景 fork() 创建一个子进程，复制当前进程 写时复制（Copy-on-write） 父子进程并发执行 一般进程创建 vfork() 类似 fork，但不复制地址空间 共享地址空间（临时） 父进程被阻塞直到子进程 exec() 或 _exit() 创建后立即执行 exec clone() 最灵活的创建机制，用于创建线程 可选共享（通过标志控制） 父子可以并发执行 多线程、容器、线程池 fork() 和 vfork() 最终都会调用 clone()，区别在于传入的参数不同；所有这三者最终调用内核中的 copy_process() 函数来构建新的 task_struct 进程的切换简而言之，进程的切换就是保留当前进程的上下文，然后加载目标进程的上下文。 从更深入的角度解释则是： 1234567891011[当前CPU]↓保存 current-&gt;thread_struct 中的寄存器/堆栈↓切换 mm_struct（地址空间）↓current = next↓恢复 next-&gt;thread_struct 中的寄存器/堆栈↓ret 恢复程序计数器，跳转回用户/内核执行 进程的回收在前面的介绍中已经知道，所有用户态进程都由 init /systemd 派生，所有内核线程都由 kthreadd 创建。因此，这里进程的回收将从子进程的角度展开介绍。 当子进程调用 exit() 正常退出，或因异常（如段错误）终止时，会进入内核的 do_exit() 函数。 在 do_exit() 中，内核会关闭打开的文件描述符，调用 exit_mm() 释放虚拟内存资源（仅限拥有 mm_struct 的用户进程），释放信号处理器资源，同时将进程状态设置为 EXIT_ZOMBIE。 此后，内核会向父进程发送 SIGCHLD 信号，通知其可以回收当前子进程的退出状态。如果父进程已经提前退出，子进程会被重新挂载到 init（PID 1）进程下，由其负责后续回收。 最后，do_exit() 调用 schedule() 永久让出 CPU，进程不再被调度。 父进程随后通过 wait() 或 waitpid() 等系统调用获取子进程退出信息，并触发 release_task() 对其进行彻底清理，包括释放其 task_struct、内核栈、pid 表项等内核资源，从而完成整个进程回收流程。 进程的调度Linux的调度是基于分时技术的，CPU的时间被分为片，每个进程的执行都是按照片为单位去执行。在进程调度的时候，调度的优先级是基于静态优先级和动态优先级结合的方法来得出的。 静态优先级：在进程被创建的时候分配的优先级，他是不可以改变的 动态优先级：调度器在运行过程中根据进程行为动态调整的优先级值，通常是通过CFS（complete Fair Schedule）完全公平调度器来通过vcputime来等效动态优先级","link":"/2025/07/09/Linux%E4%B8%AD%E7%9A%84%E8%BF%9B%E7%A8%8B/"},{"title":"Linux的内存","text":"写在前面，本文所讨论的是基于 x86_64架构上的 Linux。 内存管理物理内存划分 什么是 UMA？什么是 NUMA？ UMA（Uniform Memory Access，统一内存访问）是一种内存体系结构，指所有CPU访问主存的速度是一致的。在计算机发展的早期，主板上通常设有北桥（Northbridge）芯片，负责连接CPU与内存、显卡等高速设备，实现了CPU对内存的统一高效访问。随着DMA技术和存储设备IO速度的发展，北桥的功能逐步被集成进CPU，现代主板上已经没有独立的北桥芯片。绝大多数个人台式机和笔记本仍然采用UMA的内存访问方式。 NUMA（Non-Uniform Memory Access，非统一内存访问）是一种内存体系结构，值所有的CPU访问主存的速度是不一致的，常见于大型服务器，有多个CPU，总线和巨大的主存。 什么是内存节点？ 在 NUMA（非统一内存访问）架构下，每个CPU（或CPU组）都被分配一块本地内存（NUMA节点），CPU访问本地节点内存时速度最快，延迟最低；而访问其他节点的内存时，需要通过跨节点总线（如QPI、Infinity Fabric等）进行数据传输，速度会有所降低。为了优化性能，操作系统通常会尽量将进程和其使用的内存分配在同一个节点上。相比之下，UMA（统一内存访问）架构下，所有CPU共享同一个内存节点，访问速度和延迟完全一致，没有本地和远程之分。 什么是内存区域？ 这里取64位为例：截取部分Linux内核源代码如下 1234567891011121314151617enum zone_type {#ifdef CONFIG_ZONE_DMA ZONE_DMA,#endif#ifdef CONFIG_ZONE_DMA32 ZONE_DMA32,#endif ZONE_NORMAL,#ifdef CONFIG_HIGHMEM ZONE_HIGHMEM,#endif ZONE_MOVABLE,#ifdef CONFIG_ZONE_DEVICE ZONE_DEVICE,#endif __MAX_NR_ZONES}; 从代码可知，内存区域至少有 ZONE_DMA32，ZONE_NORMAL和 ZONE_MOVABLE ZONE_DMA32:用于外部IO设备的高速读写内存，通常在前4G内存 ZONE_NORMAL:用于常规的内存使用 ZONE_MOVABLE:主要用于存放可迁移页，方便内存碎片整理、支持大页分配和内存热插拔 什么是内存页面 物理内存页面也叫做页帧。物理内存从开始起每4K、4K的，构成一个个页帧，这些页帧的编号依次是0、1、2、3……。每个页帧的真实物理地址是页帧号乘以页帧的大小。页帧是物理内存分配的最小单元，大小为固定的4KB 物理内存分配 首先是Buddy System，Buddy System既是直接的内存分配接口，也是所有其它内存分配器的底层分配器。伙伴系统的基本管理单位是区域，最小分配粒度是页面。因为伙伴系统是建立在物理内存的三级区划上的，所以最小分配粒度是页面，不能比页面再小了。基本管理单位是区域，是因为每个区域的内存都有特殊的用途或者用法，不能随便混用，所以不能用节点作为基本管理单位。伙伴系统并不是直接管理一个个页帧的，而是把页帧组成页块(pageblock)来管理，页块是由连续的2^n^个页帧组成，n叫做这个页块的阶，n的范围是0到10。而且2^n^个页帧还有对齐的要求，首页帧的页帧号(pfn)必须能除尽2^n^，比如3阶页块的首页帧(pfn)必须除以8(2^3^)能除尽，10阶页块的首页帧必须除以1024(2^10^)能除尽。0阶页块只包含一个页帧，任意一个页帧都可以构成一个0阶页块，而且符合对齐要求。 Slab Allocator slab allocator负责管理 slab cache中的内存。在 slab cache 中有多个 slab来存储不同的对象。每个slab对应着从主存中分割来的内存块。其中，内存块按照slab要存储的对象大小提前切割好。这样设计将内存分层和对象池相切割开，为内核小对象的高效分配（开销小，且不存在内存碎片）和回收提供了强大支持 1234567891011[slab cache]（对象类型专属池-&gt; inode, dentry, mm_struct这些使用很频繁的数据结构） ├─ [slab 1]（一大块内存，分割成若干对象块） │ ├─ object 1 │ ├─ object 2 │ └─ ... ├─ [slab 2] │ ├─ object 1 │ └─ ... └─ [slab 3] ├─ object 1 └─ ... kmalloc 是 Linux 内核为内核代码提供的高效小对象内存分配API，其内部实现基于 slab allocator。内核为不同大小的常用对象维护专用 slab cache，kmalloc 会自动选择合适的 slab cache，并从中快速分配对象。这使得内核在进行频繁的小块内存分配和释放时，能获得极高的性能和较低的碎片率。 vmalloc：vmalloc则是在内核需要使用大块内存的时候，但是物理内存碎片较多无法提供，这里就会使用vmalloc来将这些物理内存碎片整合起来，这样内核看起来是连续的虚拟地址，但是实际的物理地址不是连续的。使用vmalloc可以灵活的应对碎片，充分利用内存资源 内存地址众所周知，在计算机实际运行的时候，物理地址(PA)是唯一。CPU等资源的数量是固定的，而进程却可以有很多，这就导致了直接访问物理地址这一方式，不仅很复杂，而且安全性差，且难以对内存进行管理。因此引入了逻辑地址即虚拟地址(VA),所有的进程访问的地址都是VA，在通过 MMU（内存管理单元，负责地址转化的实际物理电路）进行从 VA到 PA的映射。 逻辑地址的组成由于技术的发展，在比较早的时期，Linux是通过逻辑地址到线性地址再到物理地址的转化。其中结合了段寻址和页寻址，而现在段寻址的方式已经被基本遗弃，更多的是直接使用页寻址的方式，通过四级页表的方式从逻辑地址到物理地址的转化。并且保存了对LDT(local description table)和 GDT(global description table)的支持，当对应的字段有效时，才使用段寻址的方式去查询。因此本文着重介绍使用页寻址的方式。 进程的所使用的地址空间就是用虚拟地址来表示的，同样的进程的地址空间被划分为了用户态虚拟地址和内核态虚拟地址。这部分的内容会在Linux的进程中有更详细的介绍。 硬件中的分页现代分页的最小页表是4KB的大小，当然也会有一些大页（2MB），超大页（1GB）的出现，不过这些大页也都是大页和超大页是通过页表的上层（PD、PDPT）直接映射大块连续物理内存来实现的，并且管理方式有些不同。 同时，必须强调的一点是，现代CPU是无法直接访问内存的，而是通过利用局部性原理，使用多级缓存的设计来保证高速访问，因此根据最终转换的PA，去高速缓存中读取数据（即使发生缓存不命中，也会从内存中读入数据到高速缓存中）。为了叙述简便，后续我们仍使用“访问内存”这一表达，代表的是通过物理地址最终完成的数据访问过程，不论数据是否实际命中 cache。 Linux中的分页现在的Linux采用的是4级分页模型，分别是页全局目录，页上级目录，页中间目录，页表。缩写分别为：PGD，PUD，PMD，PT。通过这四级别的映射之后，得到最终的 PTE，最后用 PTE的帧地址加上虚拟地址的偏移得到最终的 PA。每次从VA到PA的转化，首先要依据 CR3寄存器中的页全局地址，和VA前面的字段，按照上述规则去计算得到最终的PA。 TLB（Translation Lookaside Buffer）TLB，即快表，是一块保存在 MMU中的高速缓存区，用来直接保存VA到PA的映射，从而不用去多级查找，以此来提高效率。（这里也是利用了局部性原理），不过要注意区分的是，TLB不是保存在 Cache中的，它是保存在 MMU中独立的高速缓存区。因此实际的内存访问，是首先在 TLB中访问，如果没有找到对应项，再去使用多级页表查询的方式去访问，同时更新 TLB。 最终的内存访问方式结合上述机制，可以梳理出 Linux 在x86_64 架构下完整的一次内存访问过程。假设当前 CPU 执行一个访问内存的指令（如读取变量、访问数组等），它首先会提供一个 虚拟地址 VA。这段地址会依次经历以下步骤，最终转换为物理地址并完成访问： TLB 查询：CPU 首先将 VA 提交给 MMU，MMU 会在 TLB 中查找是否存在该虚拟页的映射（即页帧地址）。如果查找命中（称为 TLB hit），则立即得到物理页帧号，再与 VA 的页内偏移合并，得到最终的物理地址。 页表查找（TLB miss）：若 TLB 中未命中（TLB miss），则 MMU 会从 CR3 寄存器中获取当前活动页表的基地址，按虚拟地址的高位字段，逐级遍历页表结构（PGD → PUD → PMD → PT），最终得到 PTE 中的物理页帧地址。 更新 TLB：一旦找到有效的页表项，MMU 会将该 VA → PA 的映射（准确说是PA所在的页表的帧地址）插入到 TLB 中，以便未来的访问能更快命中。 访问 Cache / 内存： 使用得到的物理地址，CPU 向 Cache 系统发起数据访问请求； 若 Cache 命中，则数据直接来自 L1/L2/L3 缓存； 若 Cache 不命中（Cache miss），则从主存（DRAM）中加载数据到缓存行，再由 CPU 使用。 完成数据访问：数据被加载到寄存器或被用于指令执行，整个访问过程完成。 这个过程中，TLB 和 Cache 分别负责加速“地址转换”与“数据访问”，共同构成现代处理器内存访问延迟优化的核心。","link":"/2025/07/09/Linux%E7%9A%84%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/"},{"title":"Linux的内核同步","text":"内核抢占内核抢占是指在内核态运行时允许高优先级任务中断当前任务执行，从而提升系统响应性和实时性的机制。同样的，内核抢占依赖于两个重要的关键条件： 可重入的内核设计：可重入意味着 内核代码在被抢占后，仍能被其他内核线程或中断安全地再次进入并执行，不会引发数据破坏或逻辑错误。 完善的内核同步机制：抢占意味着多个内核任务可能同时执行或交错执行某些共享资源操作，因此必须通过同步手段（如自旋锁、顺序锁、RCU等）来保护临界区。同步的目标是防止竞态条件和保证内存一致性 同步原语每CPU变量​ 每CPU变量（Per-CPU variable） 是 Linux 内核中一种优化机制，指的是：为每个 CPU 分配一份独立的变量副本，从而避免多核系统中对共享变量的竞争，提高并发性能。由于使用每CPU变量是为了解决cache热的问题，因此每CPU变量非常适合最终一致性和无共享写的场景，但不适用于要求跨 CPU 严格顺序或同步一致性的场景。每CPU变量常见于计数，如中断计数和网络包计数。 原子操作​ **原子操作（Atomic Operation）**是指一类 不可中断、不可分割 的操作，他可以保证这个操作要么一定完成，要么不执行。原子操作是一种轻量级、高效的线程同步方式，适合用于简洁的并发控制场景 内存屏蔽​ 内存屏障（Memory Barrier）是一种指令级的同步机制，用于防止指令在编译器或 CPU 执行阶段发生重排序。在现代编译器中，为了优化代码的执行，会发生指令重排，而内存屏障的作用就是保证在这之后的指令不会越过屏障。 自旋锁自旋锁是一种 忙等锁，即如果当前锁已被持有，等待者会在原地循环检查（“自旋”），而不是睡眠等待。 在 Linux 内核中，自旋锁常用于短时间的临界区保护，因为其不涉及上下文切换。 抢占式自旋锁：持有自旋锁期间，关闭调度器，当前CPU不会被抢占。其更简单、效率高，适用于SMP系统中频繁使用的场景 非抢占式自旋锁：常见于非SMP系统，在请求锁的期间，允许被抢占，有强的实时性要求系统中是允许自旋锁被抢占 顺序锁顺序锁是一种允许读者在不加锁的情况下并发读取数据，但需要检测是否发生“写冲突”，如果发生则重新读取。即读不需要获取锁的限制，但是写的时候，不允许读，并且独占资源。由于不对读做限制，在发生写入后，要实时更新，这个时候是根据序列号是否变化来判断的。 读数据的时候：获取序列号，如果为奇数（表明正在写入，不读取）。为偶数，说明可以读，但是要检查序列号是否一样，不一样要重新读取 写数据的时候：获取写的互斥锁，序列号加一，开始写入。当写完之后，序列号在加一，表明写入完成，同时释放写锁。 RCU（READ-COPY-UPDATE）RCU的核心思想是：将读写并发冲突的问题，通过将“读”与“写”解耦，转化为“复制 + 替换 + 延迟回收”模型来解决，以达到极高性能的并发读访问。 R（Read）——无锁读取 RCU 的“Read”阶段允许多个读者线程在不加锁的情况下并发访问共享数据结构。读者只需通过调用 rcu_read_lock() 和 rcu_read_unlock() 将访问代码包围起来，便可安全读取指针指向的数据，而无需担心数据正在被更新。这种无锁读机制极大地提高了系统在读多写少场景下的并发性能，因为读者不会阻塞写者，也不会相互阻塞。 C（Copy）——复制修改 当需要更新共享数据时，写者不会直接修改正在被读者访问的数据，而是首先复制一份数据副本。在副本上进行修改后，通过原子方式将全局指针指向新的数据副本，完成所谓的“发布更新”操作。这个“Copy”过程确保了读者始终访问一致、不可变的旧数据视图，从而实现读写解耦。 U（Update）——延迟回收 一旦新的数据副本被成功替换，旧数据就不再是当前版本，但它仍可能被一些尚未退出 RCU 读临界区的线程引用。为了安全地回收旧数据，RCU 会等待一个称为“宽限期（Grace Period）”的时间段，在此期间内，系统保证所有正在读取旧数据的线程都已完成访问。只有在宽限期结束后，旧数据才会被安全释放或重用。 信号量在Linux中，信号量被分为内核信号量和POSIX信号量（用户态） 内核信号量（Kernel Semaphore） ​ 内核信号量是 Linux 内核空间中用于实现线程间同步的同步原语，适用于内核模块、驱动程序等不能使用用户态同步机制的场景。它主要用于协调内核线程对共享资源的访问，支持阻塞等待，可用于实现类似互斥锁的功能。内核提供的接口包括 sema_init() 初始化信号量、down() 获取资源（P 操作）、up() 释放资源（V 操作）。与 spinlock 相比，信号量适用于允许睡眠的临界区，避免忙等，提高内核效率。 POSIX信号量（POSIX Semaphore） ​ POSIX 信号量是 POSIX 标准（IEEE 1003.1b）定义的用户空间多线程/多进程同步机制，支持命名信号量（跨进程）和无名信号量（同进程多线程）。其接口包括 sem_init() 初始化、sem_wait() 阻塞等待、sem_post() 释放资源、sem_destroy() 释放信号量结构等。POSIX 信号量可以基于 futex 等内核机制实现，兼顾效率和通用性，是现代类 Unix 系统中广泛使用的同步方式之一，适用于线程和进程间资源控制与互斥。","link":"/2025/06/30/Linux%E7%9A%84%E5%86%85%E6%A0%B8%E5%90%8C%E6%AD%A5/"},{"title":"用hexo+icarus搭建个人博客","text":"如何用Hexo+Icarus建立一个个人网站前置准备在开始建立个人网站前，需要安装以下工具： Node.js 和 npm 下载地址：Node.js官网 安装后，在终端运行以下命令验证安装成功：12node -vnpm -v Git 下载地址：Git官网 安装后，在终端运行以下命令验证安装成功：1git --version GitHub账号 如果你打算部署到GitHub Pages，需要一个GitHub账号 注册地址：GitHub 安装Hexo 全局安装Hexo-CLI 1npm install -g hexo-cli 创建Hexo项目 123hexo init my-blogcd my-blognpm install 安装必要的插件 12npm install hexo-renderer-inferno --savenpm install hexo-deployer-git --save 安装Icarus主题 安装Icarus主题 1npm install hexo-theme-icarus --save 启用Icarus主题 在根目录下的 _config.yml中修改主题设置：1theme: icarus 或者使用以下命令自动创建主题配置文件：1hexo config theme icarus 个性化配置基本配置 修改 _config.yml文件 站点名称、作者、URL等基本信息 1234567title: 你的网站标题subtitle: '副标题'description: '网站描述'keywords: 关键词author: 你的名字language: zh-CNtimezone: 'Asia/Shanghai' 配置部署信息 ==注意，这里的repo必须为github仓库中以github.io结尾的仓库名字== 1234deploy: type: git repo: git@github.com:用户名/用户名.github.io.git branch: master Icarus主题配置 修改 _config.icarus.yml文件 ==注意，在publish文件下的内容全部是自动生成的内容，对这个文件下的内容做的所有修改都是无效的。以及所有_config.icarus.yml中的相对寻址路径都是在public下去寻找的。如果要添加自己的图片，请在source下新建img文件，放入图片，你会在publish对应的文件夹下面看见你放入的文件。更多详情请见icarus和hexo的官方文档== 配置网站logo和图标 123logo: /img/logo.svghead: favicon: /img/favicon.svg #在public下的img文件夹中去寻找图标 配置导航菜单 1234567navbar: menu: 首页: / 归档: /archives 分类: /categories 标签: /tags 关于: /about 配置侧边栏 12345678910111213141516171819202122232425262728sidebar: left: sticky: true right: sticky: truewidgets: - position: left type: profile author: 你的名字 author_title: 你的职位 location: 你的位置 avatar: /img/avatar.jpg - position: left type: toc - position: left type: categories - position: left type: recent_posts - position: left type: archives - position: left type: tags 调整主栏宽度 如果想让主栏更宽，可以将所有widget放在同一侧（如左侧）。可以参考常见问题 - Icarus (ppoffice.github.io) 配置Gitalk评论系统 如果你没有有自己的OAuth应用：注册GitHub OAuth应用 访问 https://github.com/settings/applications/new 填写应用名称（如”博客评论”） 主页URL：你的博客地址 回调URL：与主页URL相同 点击”Register application” 如果你已经有自己的OAuth应用：查看已创建的OAuth应用 GitHub头像 -&gt; Settings -&gt; Developer settings -&gt; OAuth Apps 配置Gitalk 在 _config.icarus.yml中添加： 12345678comment: type: gitalk client_id: 你的client_id client_secret: 你的client_secret repo: 用户名.github.io owner: GitHub用户名 admin: - GitHub用户名 初始化评论 部署网站后，以管理员身份登录并访问每篇文章，初始化对应的GitHub Issue 创建内容 创建新文章 1hexo new &quot;文章标题&quot; 文章格式 123456789101112131415---title: 文章标题date: 2023-03-18categories: - 分类1 - 分类2tags: - 标签1 - 标签2excerpt: 这是文章摘要，会显示在首页。---&lt;!-- more --&gt;这里是文章正文内容... 本地预览 启动本地服务器 1hexo server 访问本地预览 浏览器打开 http://localhost:4000 部署网站 生成静态文件 12hexo clean hexo generate #或者直接 hexo g 部署到GitHub Pages 1hexo deploy #或者直接 hexo d 自定义域名（可选） 在 source目录下创建 CNAME文件，内容为你的域名 在域名提供商处设置DNS解析到GitHub Pages 常见问题解决 主题配置问题 确保YAML格式正确，注意缩进 使用在线YAML验证工具检查格式 图片显示问题 将图片放在 source/img/目录下 路径使用 /img/图片名.jpg Gitalk初始化问题 确保client_id和client_secret正确 检查repo名称是否正确 需要管理员登录GitHub并访问文章页面初始化评论 参考资源 Hexo官方文档 Icarus主题文档 Gitalk文档","link":"/2025/05/02/%E7%94%A8hexo+icarus%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/"}],"tags":[{"name":"SFINAE","slug":"SFINAE","link":"/tags/SFINAE/"},{"name":"构造顺序","slug":"构造顺序","link":"/tags/%E6%9E%84%E9%80%A0%E9%A1%BA%E5%BA%8F/"},{"name":"类型擦除","slug":"类型擦除","link":"/tags/%E7%B1%BB%E5%9E%8B%E6%93%A6%E9%99%A4/"},{"name":"模板匹配","slug":"模板匹配","link":"/tags/%E6%A8%A1%E6%9D%BF%E5%8C%B9%E9%85%8D/"},{"name":"STL","slug":"STL","link":"/tags/STL/"},{"name":"操作系统","slug":"操作系统","link":"/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"},{"name":"C++关键字解析","slug":"C-关键字解析","link":"/tags/C-%E5%85%B3%E9%94%AE%E5%AD%97%E8%A7%A3%E6%9E%90/"},{"name":"Template","slug":"Template","link":"/tags/Template/"},{"name":"设计模式","slug":"设计模式","link":"/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"name":"并发编程","slug":"并发编程","link":"/tags/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"},{"name":"RAII","slug":"RAII","link":"/tags/RAII/"},{"name":"C++指针","slug":"C-指针","link":"/tags/C-%E6%8C%87%E9%92%88/"},{"name":"内存管理","slug":"内存管理","link":"/tags/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/"},{"name":"编译原理","slug":"编译原理","link":"/tags/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/"},{"name":"性能优化","slug":"性能优化","link":"/tags/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"},{"name":"C++语言特性","slug":"C-语言特性","link":"/tags/C-%E8%AF%AD%E8%A8%80%E7%89%B9%E6%80%A7/"},{"name":"左值右值","slug":"左值右值","link":"/tags/%E5%B7%A6%E5%80%BC%E5%8F%B3%E5%80%BC/"},{"name":"引用","slug":"引用","link":"/tags/%E5%BC%95%E7%94%A8/"},{"name":"lambda表达式","slug":"lambda表达式","link":"/tags/lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F/"},{"name":"运行时特性","slug":"运行时特性","link":"/tags/%E8%BF%90%E8%A1%8C%E6%97%B6%E7%89%B9%E6%80%A7/"},{"name":"终端","slug":"终端","link":"/tags/%E7%BB%88%E7%AB%AF/"},{"name":"异常","slug":"异常","link":"/tags/%E5%BC%82%E5%B8%B8/"},{"name":"面向对象编程","slug":"面向对象编程","link":"/tags/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B/"},{"name":"进程描述符","slug":"进程描述符","link":"/tags/%E8%BF%9B%E7%A8%8B%E6%8F%8F%E8%BF%B0%E7%AC%A6/"},{"name":"页表","slug":"页表","link":"/tags/%E9%A1%B5%E8%A1%A8/"},{"name":"内存寻址","slug":"内存寻址","link":"/tags/%E5%86%85%E5%AD%98%E5%AF%BB%E5%9D%80/"},{"name":"同步","slug":"同步","link":"/tags/%E5%90%8C%E6%AD%A5/"},{"name":"并行","slug":"并行","link":"/tags/%E5%B9%B6%E8%A1%8C/"},{"name":"Hexo","slug":"Hexo","link":"/tags/Hexo/"},{"name":"Icarus","slug":"Icarus","link":"/tags/Icarus/"},{"name":"GitHub Pages","slug":"GitHub-Pages","link":"/tags/GitHub-Pages/"},{"name":"Gitalk","slug":"Gitalk","link":"/tags/Gitalk/"}],"categories":[{"name":"C++","slug":"C","link":"/categories/C/"},{"name":"Linux","slug":"Linux","link":"/categories/Linux/"},{"name":"STL","slug":"STL","link":"/categories/STL/"},{"name":"博客搭建","slug":"博客搭建","link":"/categories/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"},{"name":"前端开发","slug":"博客搭建/前端开发","link":"/categories/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/"}],"pages":[]}