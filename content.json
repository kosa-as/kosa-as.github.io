{"posts":[{"title":"数据系统的基本介绍","text":"数据系统的基础从数据系统架构的角度出发OLAP和OLTP在企业中，通常会有两类的数据工作者，一种是后端开发人员另一种则是数据分析师。后端开发人员通常通过构建服务来处理读取和更新数据的请求，这些服务通常直接或者间接的为外部用户提供服务；数据分析师则是通常对过去一段时间内的所有业务数据做分析，产出关于组织活动的报告以及对业务新的见解。 由上可知，数据系统主要分为两个大类，即OLAP(On-Line Analytical Processing)和OLTP(On-Line Transcations Processing) 属性 事务型系统（OLTP） 分析型系统（OLAP） 主要读取模式 点查询（通过键获取单个记录） 对大量记录进行聚合 主要写入模式 创建、更新和删除单个记录 批量导入（ETL）或事件流 人类用户示例 Web 或移动应用程序的最终用户 内部分析师，用于决策支持 机器使用示例 检查操作是否被授权 检测欺诈/滥用模式 查询类型 固定的查询集，由应用程序预定义 分析师可以进行任意查询 数据代表 数据的最新状态（当前时间点） 随时间发生的事件历史 数据集大小 GB 到 TB TB 到 PB 数据仓库（Data WareHouse）早期的数据库基本都是OLTP类型的设计，包括数据分析也在其上执行。而OLTP在大数据分析上的劣势，使得越来越多的企业转而在单独的数据库系统上运行分析。这个单独的数据库被称为 数据仓库。 数据仓库中的数据通过从OLTP型数据库中ETL而来，显而易见，数据仓库中保存着的是OLTP的只读副本。 数据湖（Data Lake）从数据仓库的介绍中，很容易可以发现，数据仓库只适合存储结构化的数据，而往往除了业务数据，还有日志，流式事件等数据也想要保存。这些数据的明显特点是结构不清晰，数据仓库只能存结构化数据的局限性被无限放大，由此开始推出了数据湖。 由于数据仓库的局限性，在数据湖里，与数据仓库的区别在于，数据湖只是包含文件，并且干脆就直接不强制任何特定的文件格式或数据模型。数据湖的数据来源也不再只是ETL（这里新提出了CDC的概念，增量数据更新，即OLAP一旦由数据更新，就触发向数据湖的写入），可以是像Kafka这种的流式输入，可以是系统各个组件的日志输入等等。此外，传统的数据仓库使用着HDFS，它开始渐渐不适合数据湖的存储需求，因为有着更好拓展，更便宜，更好用的对象存储可以选择（S3/MinIO/OSS）。 湖仓一体（Lakehouse）在数据湖被推出后，人们很快发现，数据入湖并不能很好的解决所有的问题，数据湖中存储的是原始的数据，如果缺乏严格的数据管理，那么就很容易变为“数据沼泽”。于是在数据湖之上，开发者开始提供类似数据仓库的能力（ACID、Schema等），也可以被称作数据存储中间层。现有的开源存储中间层有Iceberg，Hudi和Delta，它们是通过表格式+元数据+事务日志的方式在湖中文件上，将它们组织为可以进行管理的表。 Iceberg最大的特点是对数据进行分区，并且拥有很好的元数据管理。同时最开放最通用，在数据查询上有独特的优势。适合多平台的查询以及数据的分析 HudiHudi全称（Hadoop Upserts anD Incrementals）。虽然是基于HDFS发展的，但是hudi也可以支持对象存储。此外HUDI原生支持 Upsert、Delete、增量读（Incremental Query），适合大量实时写入、CDC、需要增量消费的业务事实表。 Delta主要面向 Spark / Databricks 生态，擅长流批一体，最贴近使用原生SQL的中间层。使用Spark进行流处理的时候很具有优势。 讲到这里，其实上面只是涉及到了设计的部分，而现实的落地也同样的复杂。 从数据系统落地的角度出发众所周知，公司是要赚钱的。大家公认的管理智慧是，作为组织核心竞争力或竞争优势的事物应该在内部完成，而非核心、例行或常见的事物应该留给供应商。因此采用云服务还是云原生就是一个问题。 Cloud Service 和 Cloud Native使用云服务而不是自己运行对应的软件，本质上是将该软件的运维外包给云提供商。 使用云服务有充分的支持和反对理由。云提供商声称，使用他们的服务可以节省你的时间和金钱，并相比自建基础设施让你更敏捷。（客户与服务商会达成SLA，里面就约定了服务的质量，可用性等约束） 云服务的缺点： 服务不可用时你做不了任何事 架构的调整，必须要和服务商先行沟通 数据安全的一系列问题 使用云原生就能很好的解决上面的痛点。基于云原生的服务，基本的要求就是：高可用（容忍故障，人为错误），可伸缩，可观测。 云原生的缺点： 学习成本高 运维复杂性高，微服务治理成本高 由于云原生的自动化特性，不合理的分配资源会导致浪费 分布式与单节点系统涉及多态机器通过网络通信的系统会被称之为分布式系统，参与分布式系统的每个进程被称之为节点。采用分布式系统的原因无外乎有以下几种需求： 高可用性 可伸缩性 延迟 弹性 。。。 不过分布式系统也存在着很大的问题：部分故障仍然是分布式系统面临的最大问题，而且每个通过网络的请求和调用都会存在着失败的可能性。 总结","link":"/2026/01/04/cloud/%E6%95%B0%E6%8D%AE%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BB%8B%E7%BB%8D/"},{"title":"C++中std::functional的实现","text":"std::functional的基本原理： 将任意可调用对象包装为一个类型安全、可复制、可赋值的对象 不需要知道其底层类型（即擦除原始类型） 只要它们满足函数签名即可传参执行 std：：functional原理分析： 可调用对象： 类型 举例 可传给 std::function 说明 普通函数指针 int(*)(int,int) ✅ 最基础 Lambda [=](int x){ return x+1; } ✅ 最常用 函数对象 struct F { int operator()(); }; ✅ 可定制行为 静态成员函数 static int f() ✅ 和普通函数等价 成员函数指针 &amp;Class::method ❌（需要包装） 必须配合对象使用 std::bind 结果 bind(f, 1, _1) ✅ 预设参数 std::mem_fn 结果 mem_fn(&amp;C::f) ✅ 成员函数包装 std::function 本身 function&lt;void()&gt; ✅ 高阶封装 类型擦除： std::decay_t&lt;T&gt; 是 C++ 类型萃取中非常常用的工具，它会把一个类型 退化（decay） 成适用于函数参数传递的形式，其行为类似于函数参数的默认类型转换规则。可以理解为：std::decay_t&lt;T&gt; 会去掉引用、cv 限定符、数组/函数类型退化为指针等。 Function的实现12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273#pragma once#include &lt;memory&gt;#include &lt;utility&gt;#include &lt;type_traits&gt;template &lt;typename&gt;class Function; //模板特化，R(Args...)表示一个可调用对象，R是返回类型，Args...是参数类型template &lt;typename R, typename... Args&gt;class Function&lt;R(Args...)&gt; { //ICallable是一个抽象类，定义了一个纯虚函数invoke，用于包裹可调用对象 class ICallable { public: virtual R invoke(Args&amp;&amp;... args) = 0; virtual std::unique_ptr&lt;ICallable&gt; clone() const = 0; virtual ~ICallable() = default; }; //CallableImpl是一个具体类，继承自ICallable，用于包裹可调用对象 template &lt;typename F&gt; class CallableImpl : public ICallable { F func; public: explicit CallableImpl(F&amp;&amp; f) : func(std::forward&lt;F&gt;(f)) {} R invoke(Args&amp;&amp;... args) override { return func(std::forward&lt;Args&gt;(args)...); } std::unique_ptr&lt;ICallable&gt; clone() const override { return std::make_unique&lt;CallableImpl&lt;F&gt;&gt;(F(func)); } }; std::unique_ptr&lt;ICallable&gt; callable;public: // 默认构造函数 Function() noexcept = default; template &lt;typename F, typename = std::enable_if_t&lt;!std::is_same&lt;std::decay_t&lt;F&gt;, Function&gt;::value&gt;&gt; //构造函数，接受一个可调用对象F，并将其包裹在CallableImpl中 Function(F&amp;&amp; f) : callable(std::make_unique&lt;CallableImpl&lt;std::decay_t&lt;F&gt;&gt;&gt;(std::forward&lt;F&gt;(f))) {} // 移动构造和赋值 Function(Function&amp;&amp; other) noexcept = default; Function&amp; operator=(Function&amp;&amp; other) noexcept = default; // 拷贝构造函数 Function(const Function&amp; other) : callable(other.callable ? other.callable-&gt;clone() : nullptr) {} // 拷贝赋值运算符 Function&amp; operator=(const Function&amp; other) { if (this != &amp;other) { callable = other.callable ? other.callable-&gt;clone() : nullptr; } return *this; } R operator()(Args... args) { if (!callable) { throw std::bad_function_call(); } return callable-&gt;invoke(std::forward&lt;Args&gt;(args)...); } explicit operator bool() const { return static_cast&lt;bool&gt;(callable); }}; 代码说明ICallable是所有可调用对象的抽象包裹wrapper类，是一个基类。在Function中，通过*ICallable指针（或者智能指针）来调用派生类中的invoke函数，来实现最后的执行 1234567template &lt;typename R, typename... Args&gt; class ICallable { public: virtual R invoke(Args&amp;&amp;... args) = 0;//执行函数 virtual std::unique_ptr&lt;ICallable&gt; clone() const = 0;//基类并不知道子类是什么样子的，添加一个辅助克隆函数 virtual ~ICallable() = default;//析构函数，必须要申明为虚函数}; CallableImpl是基于ICallable的派生类，里面实现了具体的方法。 123456789101112131415template &lt;typename R, typename... Args&gt; template &lt;typename F&gt;class CallableImpl : public ICallable { F func; public: explicit CallableImpl(F&amp;&amp; f) : func(std::forward&lt;F&gt;(f)) {}//单参构造函数，使用完美转发 R invoke(Args&amp;&amp;... args) override { return func(std::forward&lt;Args&gt;(args)...);//使用func(args...) } std::unique_ptr&lt;ICallable&gt; clone() const override { return std::make_unique&lt;CallableImpl&lt;F&gt;&gt;(F(func));//深拷贝函数，返回本派生类的一个深拷贝对象 } }; 然后是Function内容的实现： 首先私有变量采用了unique_ptr的设计，来管理类型为基类指针但是指向子类的指针。 单参构造函数：explicit Function(F&amp;&amp; f)，在上面使用了SFINAE（substitute failure is not an error），即在进行模板匹配的时候，如果发生了模板不匹配，则不认为是一种错误，转而匹配其他的构造函数。（在其他的设计中也有体现，比如std：：lock_guard和std::unique_lock,两者都要求传入的类实现lock和unlock方法。） 讲到构造函数匹配的问题：下面是构造函数的匹配规则 匹配类别 优先级 非模板函数 最高 模板函数（精确匹配） 高 模板函数（万能引用 T&amp;&amp;） 较低（仅在无其他更优时选） 可变参数模板 (...) 最低 为什么要实现辅助的clone函数呢？ 在这里可见，在赋值构造和赋值拷贝中，调用的是callable实际指向对象的clone函数，如果不这样，默认的赋值构造与拷贝实现的是浅拷贝，那么会引发一系列的问题 为什么要重载R operator()(Args... args)呢？ 通过重载这个运算符，来包裹invoke函数，那么就可以直接使用f()的方式调用函数，实现可调用对象的完美还原（不改变使用方式） 12345678910111213141516171819202122232425262728293031323334353637383940414243444546template &lt;typename&gt;//模板特化，R(Args...)表示一个可调用对象，R是返回类型，Args...是参数类型template &lt;typename R, typename... Args&gt;class Function&lt;R(Args...)&gt; { //ICallable是一个抽象类，定义了一个纯虚函数invoke，用于包裹可调用对象 class ICallable; //CallableImpl是一个具体类，继承自ICallable，用于包裹可调用对象 template &lt;typename F&gt; class CallableImpl : public ICallable; std::unique_ptr&lt;ICallable&gt; callable;public: // 默认构造函数 Function() noexcept = default; template &lt;typename F, typename = std::enable_if_t&lt;!std::is_same&lt;std::decay_t&lt;F&gt;, Function&gt;::value&gt;&gt; //构造函数，接受一个可调用对象F，并将其包裹在CallableImpl中,同时使用类型擦除，来进行包裹 Function(F&amp;&amp; f) : callable(std::make_unique&lt;CallableImpl&lt;std::decay_t&lt;F&gt;&gt;&gt;(std::forward&lt;F&gt;(f))) {} // 移动构造和赋值 Function(Function&amp;&amp; other) noexcept = default; Function&amp; operator=(Function&amp;&amp; other) noexcept = default; // 拷贝构造函数 Function(const Function&amp; other) : callable(other.callable ? other.callable-&gt;clone() : nullptr) {} // 拷贝赋值运算符 Function&amp; operator=(const Function&amp; other) { if (this != &amp;other) { callable = other.callable ? other.callable-&gt;clone() : nullptr; } return *this; } R operator()(Args... args) { if (!callable) { throw std::bad_function_call(); } return callable-&gt;invoke(std::forward&lt;Args&gt;(args)...); } explicit operator bool() const { return static_cast&lt;bool&gt;(callable); }};","link":"/2026/01/04/cpp/C++%E4%B8%ADfunctional%E7%9A%84%E5%AE%9E%E7%8E%B0/"},{"title":"C++关键字解析","text":"1.sizeof和strlen的区别strlen测量的是字符串的实际长度,源代码如下 123456size_t strlen(const char *str) { size_t length = 0; while (*str++) ++length; return length;} sizeof测量的是对象或者表达式类型占用的字节大小 总而言之，一个测量的是实际长度，到’/0’结束，而另一个则是测量实际占用的大小。 2.static的用法 应用场景 类型 作用 局部 static 变量 函数内部 变量生命周期贯穿整个程序，但作用域仅限函数 文件内部 static 变量 文件作用域 限制变量可见性，避免命名冲突 文件内部 static 函数 文件作用域 仅在当前编译单元可见，隐藏实现细节 类的 static 变量 类成员 所有对象共享 类的 static 函数 类成员 不依赖对象，访问静态数据 静态工具类 = delete 防止实例化 线程安全的 static 变量 C++11 确保多线程环境下安全初始化 static 的核心作用： ✅ 控制作用域（文件/函数级别）✅ 延长生命周期（局部 static 变量）✅ 共享数据（类 static 成员）✅ 提升封装性（防止全局变量污染） 3.const的用法 用法 作用 const int a = 10; 常量变量，不可修改 const int* p; 指针指向的值不可修改 int* const p; 指针本身不可修改 const int* const p; 指针本身和指向的值都不可修改 void func(const int x); 传值参数不可修改 void func(const int* p); 传指针参数，指向的值不可修改 void func(const int&amp; ref); 传引用参数，引用值不可修改 class A { const int data; }; 类的成员变量不可修改，需构造函数初始化 void show() const; const 成员函数，不能修改类成员变量 const int&amp; getData() const; const 返回值，防止修改 4.const和define的区别 特性 #define const 作用 预处理文本替换 定义常量变量 类型检查 ❌ 无类型检查，可能引发错误 ✅ 有类型检查，更安全 作用域 ❌ 无作用域，作用于整个文件 ✅ 遵循 C++ 作用域规则 内存占用 ❌ 仅进行文本替换，不占用变量存储空间 ✅ 变量存储在只读数据区 可调试性 ❌ 不能在调试器中查看 ✅ 可以查看变量值 const 指针支持 ❌ 不能用于指针 ✅ 可用于指针，如 const int* p 适用场景 定义简单的文本宏（如 #define DEBUG） 定义具有类型的常量 在C++11之后，推荐使用constexpr来完成一些define定义的值。意味编译时常量，在编译时完成计算来提高程序性能 5.inline函数的作用和使用inline 关键字用于建议编译器在调用处直接展开函数代码，以减少函数调用的开销，提高运行效率。它适用于短小、频繁调用的函数。 类内部定义的函数默认是inline的 1234class Math {public: int square(int x) { return x * x; }//✅默认inline}; 6.malloc和new的区别 特性 new / new[] malloc() / calloc() 语言 C++ C（C++ 兼容） 分配类型 适用于对象，调用构造函数 仅分配原始内存，不会调用构造函数 释放方式 delete / delete[] free() 返回类型 直接返回正确类型指针 返回 void*，需要手动转换类型 初始化 new 会初始化对象（默认构造或指定初始化） malloc 不会初始化（calloc 会零初始化） 异常处理 new 失败时抛出 std::bad_alloc 异常 malloc 失败时返回 NULL，需要手动检查 安全性 更安全，支持 RAII（如 std::unique_ptr） 可能导致类型错误，易发生内存泄漏 7.free和delete的区别 特性 delete / delete[] free() 适用语言 C++ C（C++ 兼容） 适用对象 new 分配的对象 malloc/calloc/realloc 分配的内存 析构函数 ✅ 调用析构函数 ❌ 不会调用析构函数 作用范围 对象销毁 + 释放内存 仅释放内存 使用方式 delete p; / delete[] p; free(p); 安全性 更安全，支持类对象的管理 仅适用于 C 语言风格的内存管理 类型安全 不需要强制转换 需要强制转换 void* 8.volatile关键字的使用与场景volatile关键字在编程中用于确保变量的可见性和防止编译器优化，其核心作用是告诉编译器每次访问变量时必须直接从内存中读取或写入，而不是使用寄存器中的缓存值。常用于嵌入式开发从硬件寄存器中读取数据 作用： 禁止编译器优化确保每次对变量的读写操作都直接作用于内存，而非寄存器中的临时值，避免因优化导致意外行为。 保证可见性当变量可能被外部因素（如硬件、其他线程、信号处理函数）修改时，确保程序能读取到最新值 9.C语言中struct和CPP语言中struct的区别 特性 C语言中的 struct C++中的 struct C++中的 class 默认访问控制 公有 (public) 公有 (public) 私有 (private) 成员函数 不支持 支持 支持 构造函数和析构函数 不支持 支持 支持 继承和多态 不支持 支持 支持 简单来说，C++中的struct和class非常相似，区别主要在于默认的访问控制权限，struct默认是public，而class默认是private。（在继承的时候也是如此）因此struct被用于保存数据结构，而class则用于描述抽象对象。 10.extern关键字extern 是 C 和 C++ 中的一个关键字，主要用于声明变量或函数的外部链接，意味着该变量或函数是在其他地方定义的，而不是当前文件中定义的。 11.explicit关键字用来声明类构造函数是显式调用的，而非隐式调用，可以阻止调用构造函数时进行隐式转换和赋值初始化。只可用于修饰单参构造函数，因为无参构造函数和多参构造函数本身就是显式调用的，再加上 explicit 关键字也没有什么意义。 声明 explicit 的构造函数，从而可以阻止编译器执行非预期 (往往也不被期望) 的类型转换，因为某些非预期的类型转换可能会引起意向不到的错误。 举例： 1234567891011121314151617181920#include &lt;iostream&gt;#include &lt;cstring&gt;using namespace std;class A{public: int var; A(int tmp) { var = tmp; }};int main(){ A ex = 10; // 发生了隐式转换 return 0;}// 在上述过程中，A ex = 10实际上是先执行了A ex1(10), A ex = ex1。先将10转为A类型的对象，然后将该对象转为ex 12.#define vs typedef 特性 #define typedef 本质 预处理指令，文本替换 类型定义，编译时处理 类型检查 无类型检查，仅仅是字符串替换 受C语言类型系统约束，更加安全 指针类型 可能导致意外错误（如 INT_PTR a, b） 遵循类型规则（如 INT_PTR_T a, b） 适用场景 定义常量、宏函数 定义类型别名，适用于结构体、指针等 可调试性 代码不易调试（文本替换可能引入问题） 更加直观，类型更加明确 使用 #define 仅当你需要定义常量或者宏函数时，如 #define PI 3.14。 使用 typedef 适用于定义复杂类型的别名，如 typedef struct、指针、数组等。 因此，typedef 在处理类型时比 #define 更安全、直观，而 #define 更适用于常量和宏。 13.memmovememmove 是 C 标准库中的一个内存操作函数，声明在 &lt;string.h&gt; 头文件中。它的作用是将一块内存区域的数据复制到另一块内存区域，即使两块区域存在重叠，也能保证数据不会被破坏。因为在发生重叠的时候，就开始倒序复制，就可以避免这个问题 14.auto类型推导 (1) auto 类型推导规则 auto 根据右值类型推导，但去掉 const 和引用。 即基础类型推导，推导结果和初始化表达式一致，忽略引用和const修饰符。如果要保留这些特性，那么需要加上&amp;和const auto&amp; 保持引用类型，适用于引用变量。 const auto&amp; 可保持 const 限定，避免去掉 const。 auto* 适用于指针类型，但 const 规则同样适用。 decltype(auto) 会保持表达式的原始类型。 (2) auto vs decltype(auto) 表达式 推导类型 auto x = a;(a 是 const int) int auto&amp; x = a; int&amp; const auto x = a; const int decltype(auto) x = a; const int decltype(auto) x = b; (b 是 int&amp;) int&amp; C++ 的 auto 极大地增强了代码的简洁性，同时遵循模板推导规则，可以合理地推导类型，减少冗余代码。但在使用时，仍需注意 const、引用和指针的影响，以避免意外的类型变更","link":"/2025/02/25/cpp/C++%E5%85%B3%E9%94%AE%E5%AD%97%E8%A7%A3%E6%9E%90/"},{"title":"在C++20的标准下实现自己的vector容器","text":"首先介绍一下vector的基本功能：vector是一个线性容器，他是一种动态数组，其内存管理是动态的，但元素的访问方式类似于静态数组（即通过索引直接访问） 相关知识介绍： std::allocator: 在所有的标准stl容器中，都是使用allocator来管理内存，这种管理方式只会申请原始内存，即没有初始化。（不同于new，申请内存的同时会在堆上构建 ==不使用new的原因是默认的new效率更低，同时使用allocator可以更好的控制对象的生命周期，允许在已分配的内存中按需构造析构对象==）。同时使用std::allocator_traits&lt;std::allocator&lt;T&gt;&gt;::construct和std::allocator_traits&lt;std::allocator&lt;T&gt;&gt;::destory来显示的构造或者析构对象。 类的基本知识：在C++ 11之后，新建一个类，哪怕没有声明任何一个函数，编译器会默认实现六个函数，分别是：默认构造函数，默认析构函数，拷贝构造函数，移动构造函数，拷贝赋值函数，移动赋值函数。 迭代器：在类中，再去定义一个迭代器类，来封装一个容器内对象类型的指针，同时重载一些运算符的实现 动态内存：vector在堆上新申请一片内存，当这个内存被用满之后，那么vector就要重新去申请一片内存，然后把之前的元素全部放入。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697#include &lt;memory&gt;#include &lt;stdexcept&gt;#include &lt;initializer_list&gt;#include &lt;algorithm&gt;#include &lt;iostream&gt;template &lt;typename T&gt;class Vector {private: T* data; size_t vec_size; size_t vec_capacity; std::allocator&lt;T&gt; allocator; // 扩容函数声明 void reserve(size_t new_capacity); // 快速排序函数声明 template&lt;typename Compare&gt; void quick_sort(typename Vector&lt;T&gt;::iterator first, typename Vector&lt;T&gt;::iterator last, Compare cmp);public: class iterator { T* ptr; public: explicit iterator(T* ptr) : ptr(ptr) {} T&amp; operator*() const { return *ptr; }//解引用操作符 T* operator-&gt;() const { return ptr; }//成员访问操作符 iterator&amp; operator++() { ++ptr; return *this; }//前缀加 iterator operator++(int) { iterator tmp = *this; ++(*this); return tmp; }//后缀加 iterator&amp; operator--() { --ptr; return *this; }//前缀减 iterator operator--(int) { iterator tmp = *this; --(*this); return tmp; }//后缀减 bool operator==(const iterator&amp; other) const { return ptr == other.ptr; } bool operator!=(const iterator&amp; other) const { return ptr != other.ptr; } iterator operator+(size_t n) const { return iterator(ptr + n); } iterator operator-(size_t n) const { return iterator(ptr - n); } }; class const_iterator : public iterator { public: explicit const_iterator(const T* ptr) : iterator(ptr) {} const T&amp; operator*() const { return iterator::operator*(); } const T* operator-&gt;() const { return iterator::operator-&gt;(); } }; // 构造函数声明 Vector() noexcept; explicit Vector(size_t n); Vector(size_t n, const T&amp; val); Vector(std::initializer_list&lt;T&gt; init); Vector(iterator begin, iterator end); Vector(const Vector&lt;T&gt;&amp; other); Vector(Vector&lt;T&gt;&amp;&amp; other) noexcept; // 赋值运算符声明 Vector&amp; operator=(const Vector&lt;T&gt;&amp; other); Vector&amp; operator=(Vector&lt;T&gt;&amp;&amp; other) noexcept; // 析构函数声明 ~Vector(); // 迭代器函数声明 iterator begin(); const_iterator const_begin() const; iterator end(); const_iterator const_end() const; // 访问元素函数声明 T&amp; operator[](size_t index); T&amp; at(size_t index); // 容量和大小函数声明 [[nodiscard]] size_t capacity() const; void set_capacity(size_t new_capacity); [[nodiscard]] bool empty() const; [[nodiscard]] size_t size() const; // 清空函数声明 void clear(); // 添加元素函数声明 void push_back(const T&amp; value); // 添加元素函数声明,移动添加 void push_back(T&amp;&amp; value); // 添加元素函数声明，直接构造 template&lt;typename... Args&gt; void emplace_back(Args&amp;&amp;... args); // 查找元素函数声明 const_iterator find(const T&amp; value) const; // 插入元素函数声明 void insert(iterator pos, const T&amp; value); // 删除元素函数声明 void erase(iterator pos); void pop_back(); // 访问首尾元素函数声明 T&amp; front() const; T&amp; back() const; // 交换函数声明 void swap(Vector&amp; other); // 友元函数声明 template &lt;typename U&gt; friend std::ostream&amp; operator&lt;&lt;(std::ostream&amp; os, const Vector&lt;U&gt;&amp; vec); // 快速排序函数声明 template&lt;typename Compare = std::less&lt;T&gt;&gt; void sort(iterator first, iterator last, Compare cmp = Compare()); // 函数重写 template&lt;typename Compare = std::less&lt;T&gt;&gt; void sort(Compare cmp = Compare());}; vector的私有属性1234T* data;//指向管理的数据的指针size_t vec_size;//容器内数据的数量size_t vec_capacity;//分配内容可容纳的对象的数量std::allocator&lt;T&gt; allocator;//容器内存管理器 vector的迭代器12345678910111213141516171819202122class iterator { T* ptr; public: explicit iterator(T* ptr) : ptr(ptr) {} T&amp; operator*() const { return *ptr; } T* operator-&gt;() const { return ptr; } iterator&amp; operator++() { ++ptr; return *this; }//前缀加 iterator operator++(int) { iterator tmp = *this; ++(*this); return tmp; }//后缀加 iterator&amp; operator--() { --ptr; return *this; }//前缀减 iterator operator--(int) { iterator tmp = *this; --(*this); return tmp; }//后缀减 bool operator==(const iterator&amp; other) const { return ptr == other.ptr; } bool operator!=(const iterator&amp; other) const { return ptr != other.ptr; } iterator operator+(size_t n) const { return iterator(ptr + n); } iterator operator-(size_t n) const { return iterator(ptr - n); }};class const_iterator : public iterator { public: explicit const_iterator(const T* ptr) : iterator(ptr) {} const T&amp; operator*() const { return iterator::operator*(); } const T* operator-&gt;() const { return iterator::operator-&gt;(); }}; 在C++11之后，除了iterator之后，还实现了const_iterator。迭代器内实现了各种常见指针操作的重载 vector的扩容操作在执行push_back，emplace_back, insert等操作后，vector可能需要扩容，此时需要调用reserve函数去堆上申请一块新的内存空间。在vector扩容的时候，通常扩充为之前的1.5~2倍大小 1234567891011121314151617181920212223template &lt;typename T&gt;void Vector&lt;T&gt;::set_capacity(size_t new_capacity) { if (new_capacity &lt;= vec_capacity) return; // 只在需要扩容时执行 reserve(new_capacity);}// 扩容函数实现template &lt;typename T&gt;void Vector&lt;T&gt;::reserve(size_t new_capacity) { if (new_capacity &lt;= vec_capacity) return; // 只在需要扩容时执行 T* new_data = std::allocator_traits&lt;std::allocator&lt;T&gt;&gt;::allocate(allocator, new_capacity); // 移动现有元素 for (size_t i = 0; i &lt; vec_size; i++) { std::allocator_traits&lt;std::allocator&lt;T&gt;&gt;::construct(allocator, &amp;new_data[i], std::move(data[i])); std::allocator_traits&lt;std::allocator&lt;T&gt;&gt;::destroy(allocator, &amp;data[i]); } // 释放旧内存 if (data) { std::allocator_traits&lt;std::allocator&lt;T&gt;&gt;::deallocate(allocator, data, vec_capacity); } data = new_data; vec_capacity = new_capacity;} vector的构造函数1234567Vector() noexcept;explicit Vector(size_t n);Vector(size_t n, const T&amp; val);Vector(std::initializer_list&lt;T&gt; init);Vector(iterator begin, iterator end);Vector(const Vector&lt;T&gt;&amp; other);Vector(Vector&lt;T&gt;&amp;&amp; other) noexcept; 首先是默认构造Vector() noexcept, noexcept表示不会抛出异常 然后是单参构造函数explicit Vector(size_t n),在C++11之前，对于单参构造函数，都要用explicit来避免隐式转化。在C++11之后，也可以堆多参构造函数使用 拷贝构造函数Vector(const Vector&lt;T&gt;&amp; other); 12345678template &lt;typename T&gt;Vector&lt;T&gt;::Vector(const Vector&lt;T&gt;&amp; other) : data(nullptr), vec_size(0), vec_capacity(0) { reserve(other.vec_size); for (size_t i = 0; i &lt; other.vec_size; ++i) { std::allocator_traits&lt;std::allocator&lt;T&gt;&gt;::construct(allocator, &amp;data[i], other.data[i]); } vec_size = other.vec_size;} 移动构造函数Vector&lt;T&gt;::Vector(Vector&lt;T&gt;&amp;&amp; other) noexcept : 123456789101112// 移动构造函数实现template &lt;typename T&gt;Vector&lt;T&gt;::Vector(Vector&lt;T&gt;&amp;&amp; other) noexcept : data(other.data), vec_size(other.vec_size), vec_capacity(other.vec_capacity), allocator(std::move(other.allocator)) { // 防止 other 析构时释放我们刚&quot;偷&quot;来的内存 other.data = nullptr; other.vec_size = 0; other.vec_capacity = 0;} 初始化列表构造 Vector(std::initializer_list&lt;T&gt; init);: 1234567891011// 初始化列表构造函数实现template &lt;typename T&gt;Vector&lt;T&gt;::Vector(std::initializer_list&lt;T&gt; init) : data(nullptr), vec_size(0), vec_capacity(0) { if (init.size() &gt; 0) { reserve(init.size()); for (size_t i = 0; i &lt; init.size(); ++i) { std::allocator_traits&lt;std::allocator&lt;T&gt;&gt;::construct(allocator, &amp;data[i], *(init.begin() + i)); } vec_size = init.size(); }} 迭代器构造函数Vector(iterator begin, iterator end); 12345678910// 迭代器构造函数实现template &lt;typename T&gt;Vector&lt;T&gt;::Vector(iterator begin, iterator end) : data(nullptr), vec_size(0), vec_capacity(0) { size_t count = end - begin; reserve(count); for (size_t i = 0; i &lt; count; ++i) { std::allocator_traits&lt;std::allocator&lt;T&gt;&gt;::construct(allocator, &amp;data[i], *(begin + i)); } vec_size = count;} vector的析构函数调用clear()函数，清空allocator分配的内存 123456789101112131415161718// 析构函数实现template &lt;typename T&gt;Vector&lt;T&gt;::~Vector() { clear();}// 清空函数实现template &lt;typename T&gt;void Vector&lt;T&gt;::clear() { for (size_t i = 0; i &lt; vec_size; i++) { std::allocator_traits&lt;std::allocator&lt;T&gt;&gt;::destroy(allocator, &amp;data[i]); } if (data) { std::allocator_traits&lt;std::allocator&lt;T&gt;&gt;::deallocate(allocator, data, vec_capacity); } data = nullptr; vec_size = 0; vec_capacity = 0;} vector添加元素的操作 push_back:有两种方法，一种是拷贝构造，一种是移动构造 12345678910111213141516171819template &lt;typename T&gt;void Vector&lt;T&gt;::push_back(const T&amp; value) {//拷贝原对象 if (vec_size == vec_capacity) { size_t new_capacity = (vec_capacity == 0) ? 1 : 2 * vec_capacity; reserve(new_capacity); } std::allocator_traits&lt;std::allocator&lt;T&gt;&gt;::construct(allocator, data+vec_size, value); ++vec_size;}template &lt;typename T&gt;void Vector&lt;T&gt;::push_back(T&amp;&amp; value) {//利用右值直接构造 if (vec_size == vec_capacity) { size_t new_capacity = (vec_capacity == 0) ? 1 : 2 * vec_capacity; reserve(new_capacity); } std::allocator_traits&lt;std::allocator&lt;T&gt;&gt;::construct(allocator, data+vec_size, std::move(value)); ++vec_size;} emplace_back 123456789101112131415161718// 添加元素函数实现，直接构造template &lt;typename T&gt;template&lt;typename... Args&gt;void Vector&lt;T&gt;::emplace_back(Args&amp;&amp;... args) { if (vec_size == vec_capacity) { size_t new_capacity = (vec_capacity == 0) ? 1 : 2 * vec_capacity; reserve(new_capacity); } // 使用完美转发构造新元素 std::allocator_traits&lt;std::allocator&lt;T&gt;&gt;::construct( allocator, data + vec_size, std::forward&lt;Args&gt;(args)... ); ++vec_size;} insert：利用迭代器实现了元素的定点插入 1234567891011121314// 插入元素函数实现template &lt;typename T&gt;void Vector&lt;T&gt;::insert(iterator pos, const T&amp; value) { size_t index = pos - begin(); if (vec_size == vec_capacity) { size_t new_capacity = (vec_capacity == 0) ? 1 : 2 * vec_capacity; reserve(new_capacity); } for (size_t i = vec_size; i &gt; index; --i) { std::allocator_traits&lt;std::allocator&lt;T&gt;&gt;::construct(allocator, &amp;data[i], std::move(data[i-1])); } std::allocator_traits&lt;std::allocator&lt;T&gt;&gt;::construct(allocator, &amp;data[index], value); ++vec_size;} vector中排序的使用这里使用了比较器模板，在 C++ 中，比较器模板允许你为算法（如排序、查找、优先级队列等）提供自定义的比较规则，同时保持代码的泛用性和高性能。以下是实现比较器模板的详细方法及示例： 比较器可以是 函数指针、函数对象（仿函数） 或 Lambda 表达式。它们需要满足以下条件： 接受两个相同类型的参数。 返回 bool 类型，表示两个元素的顺序关系。 这里在类中比较器模板的申明中，指定了Compare = std::less&lt;T&gt; 12345678910111213141516171819202122232425262728293031323334353637// 快速排序函数实现template &lt;typename T&gt;template &lt;typename Compare&gt;void Vector&lt;T&gt;::quick_sort(typename Vector&lt;T&gt;::iterator first, typename Vector&lt;T&gt;::iterator last, Compare cmp) { if (first &gt;= last) return; // 选择基准元素（此处选择中间元素） T pivot = *(first + (last - first) / 2); iterator left = first; iterator right = last - 1; // 分区操作 while (left &lt;= right) { while (cmp(*left, pivot)) ++left; while (cmp(pivot, *right)) --right; if (left &lt;= right) { std::swap(*left, *right); ++left; --right; } } // 递归排序 quick_sort(first, right + 1, cmp); quick_sort(left, last, cmp);}// 快速排序函数实现template &lt;typename T&gt;template &lt;typename Compare&gt;void Vector&lt;T&gt;::sort(iterator first, iterator last, Compare cmp) { quick_sort(first, last, cmp);}template &lt;typename T&gt;template &lt;typename Compare&gt;void Vector&lt;T&gt;::sort(Compare cmp) { quick_sort(begin(), end(), cmp);} ​","link":"/2026/01/04/cpp/C++%E5%AE%9E%E7%8E%B0Vector%E5%AE%B9%E5%99%A8/"},{"title":"在C++20的标准下实现一个线程池","text":"线程池是提前声明好的，是一种预先创建线程并重复利用它们来执行多个任务的并发编程技术。他可以对线程进行准确的资源控制，同时减少线程创建销毁的开销，并且对任务进行统一的管理。本文将讲一下如何实现一个简单的线程安全的线程池。首先是前置知识的介绍 线程std::thread和std::jthread std：：thread是在C++11中引入，一个 std::thread 对象代表了一个真实运行中的线程句柄（handle）。因此在使用thread的时候，必须要使用join（等待线程结束）或者detach（放弃对这个线程的管理）来告诉操作系统，这个线程句柄接下来要怎么处理。 std：：jthread是在C++20中引入，在std：：thread的基础上，实现了stop_token即取消支持。同时在离开作用域的时候，无需使用join，std：：jthread会自己实现join，来避免忘记使用join的情况 std：：thread和std：：jthread的共同之处： 均不支持拷贝赋值和拷贝构造，但是支持移动赋值和移动构造。原因也很简单，std：：thread所持有的句柄是单例的，只允许移动不准拷贝。 在使用时，接受可调用对象来调用单参构造函数，创建一个新的线程 互斥量std::mutex std::mutex的引入是用来保护共享数据免受从多个线程同时访问的同步原语。在CPP中，常见于使用std::lock_guard和std::unique_lock,来保证临界区的正常访问。 std::lock_guard: 简单固定，在创建锁的时候即立即固定，在生命周期结束的时候立即自动解锁。不提供unlock，lock选项，也不允许移动。 std：：unique_lock:提供lock和unlock的选项，同样的不允许拷贝赋值和拷贝构造，但是可以移动。它是独占式的拥有互斥量。 条件变量std::condition_variable条件变量std::condition_variable的出现是用于唤醒等待线程从而避免死锁。如果不采用条件变量，那么在等待进入临界区的时候，使用while(true)检查，不仅造成了CPU资源的浪费，同时还容易造成死锁。 在开发中，std::condition_variable 是与 std::mutex 一起使用的同步原语，它能用于阻塞一个线程，或同时阻塞多个线程，直至另一线程修改共享变量（条件）并通知 std::condition_variable。 cv.notify_one()和cv.notify_all()：通知一个或者所有在等待的线程，检查在wait中的条件。 条件变量的等待：cv.wait() void wait(std::unique_lock&lt;std::mutex&gt;&amp; lock );:没有实现避免虚假唤醒（这是一定存在的，它是一种内核的行为。及没有发生notify但是却被唤醒）的方法，必须在while循环中使用 template&lt; class Predicate &gt;` void wait( std::unique_lock&lt;std::mutex&gt;&amp; lock, Predicate pred ); //实现了避免虚假唤醒的方法，接受一个谓词类型作为参数，来判断是否发生了虚假唤醒 期物std::future类模板 std::future 提供访问异步操作结果的机制，（通过 std::async、std::packaged_task 或 std::promise 创建的）异步操作能提供一个 std::future 对象给该异步操作的创建者 特性 std::async std::packaged_task std::promise 用途 自动运行异步任务并返回 future 封装函数任务，手动启动，返回 future 显式设置结果，获取 future 控制执行时机 否（由实现决定是否新线程） 是（手动调用） 是（你决定何时设置结果） 可传入函数 ✅ 是 ✅ 是 ❌ 否，只设置值 多用于哪种场景 一次性异步任务 自定义调度策略的异步任务 跨线程通信，或异步中断返回 原子量std：：atomicstd::atomic&lt;T&gt; 提供原子性访问，即不会被线程调度打断，也不会产生数据竞争。它支持的操作如 .store()、.load()、.exchange()、.compare_exchange_weak() 等都能保证线程安全。 在使用std：：atomic的时候，默认的内存顺序是 mememory_order_seq_cst最强顺序，全局顺序一致性，编译器和CPU都不能重排序 模式 类比关系 含义 relaxed 自扫门前雪 不管别人，自己原子执行即可 release 发出公告 把前面的写操作同步给别人 acquire 等待公告 拿到别人发布的写操作 seq_cst 一切都按顺序排队 所有线程看到同样的顺序 单例模式单例模式是指这个类只能有一个实例存在，并且通常在工具类中使用，比如数据库链接，线程池。要实现单例模式是不是要将构造和析构函数私有，然后所有的移动，拷贝赋值构造都被delete，提供一个getinstance方法来返回全局唯一的静态的类的实例 懒汉式：在第一次调用时才构造实例；节省资源，适用于高启动性能要求或可能从不使用的单例类 12345678910111213class LazySingleton {public: static LazySingleton&amp; getInstance() { static LazySingleton instance; // 局部静态变量线程安全（C++11） return instance; } LazySingleton(const LazySingleton&amp;) = delete; LazySingleton&amp; operator=(const LazySingleton&amp;) = delete;private: LazySingleton() = default;}; 饿汉式：类加载时就初始化实例，不等用的时候才创建；实例在程序开始时就存在，一定不会为 null； 1234567891011121314class EagerSingleton {public: static EagerSingleton&amp; getInstance() { return instance; } EagerSingleton(const EagerSingleton&amp;) = delete; EagerSingleton&amp; operator=(const EagerSingleton&amp;) = delete;private: EagerSingleton() = default; static EagerSingleton instance; // 饿汉式，程序启动时创建};EagerSingleton EagerSingleton::instance; // 定义并初始化 具体实现的线程池代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105#include &lt;vector&gt;#include &lt;queue&gt;#include &lt;thread&gt;#include &lt;mutex&gt;#include &lt;condition_variable&gt;#include &lt;future&gt;#include &lt;functional&gt;#include &lt;atomic&gt;#include &lt;memory&gt;class SingletonThreadPool { std::vector&lt;std::thread&gt; workers;//线程池 std::queue&lt;std::function&lt;void()&gt;&gt; tasks;//任务队列 std::mutex queue_mutex;//入任务队列的锁 std::condition_variable condition;//条件变量，控制任务被执行 std::atomic&lt;bool&gt; stop;//线程池是否结束 explicit SingletonThreadPool(size_t threads) : stop(false) { for (size_t i = 0; i &lt; threads; ++i) { workers.emplace_back([this] { while (true) {//线程要一直保持活跃状态 std::function&lt;void()&gt; task; {//这是使用一个代码块来保证unique_lock生命周期的正常结束 std::unique_lock&lt;std::mutex&gt; lock(this-&gt;queue_mutex); this-&gt;condition.wait(lock, [this] {//谓词函数，当线程池被停止，或者有任务的时候去执行任务 return this-&gt;stop.load() || !this-&gt;tasks.empty(); }); if (this-&gt;stop.load() &amp;&amp; this-&gt;tasks.empty()) return; task = std::move(this-&gt;tasks.front());//移动所有权，调用了移动赋值函数 this-&gt;tasks.pop(); }//unique_lock会自动释放掉 task();//function重载了()运算符，等价于：INVOKE&lt;R&gt;(f, std::forward&lt;Args&gt;(args)...) } });//直接传入一个可调用的对象（lambda函数），使用emplace_back来直接原地构造一个thread对象 } }public: //单例模式不需要任何的拷贝移动构造函数 SingletonThreadPool&amp; operator= (const SingletonThreadPool &amp;) = delete; SingletonThreadPool(const SingletonThreadPool &amp;) = delete; SingletonThreadPool(SingletonThreadPool &amp;&amp;) = delete; SingletonThreadPool&amp; operator= (SingletonThreadPool &amp;&amp;) = delete; //析构函数必须在public中声明，否则unique_ptr无法析构 ~SingletonThreadPool() { stop.store(true); condition.notify_all();//让所有未执行完的线程全部执行完 for (std::thread &amp;worker : workers)//必须用&amp;，否则会造成资源泄漏 if (worker.joinable()) worker.join();//回收所有的线程 } static SingletonThreadPool* get_thread_pool(size_t threads) { static std::unique_ptr&lt;SingletonThreadPool&gt; ptr(new SingletonThreadPool(threads)); //这里不可以使用make_unique，因为所有的构造函数都是private的，必须使用移动构造的方式赋值给unique_ptr return ptr.get(); } template&lt;class F, class... Args&gt; auto submit(F&amp;&amp; f, Args&amp;&amp;... args) -&gt; std::future&lt;std::invoke_result_t&lt;F, Args...&gt;&gt; { //invoke_result_t是对invoke(F,Args)的放回结果做预测，通过这种方式来去确定future包裹的是什么 using return_type = std::invoke_result_t&lt;F, Args...&gt;; //使用std::packaged_task封装函数任务，来自定义获取异步调用的结果 auto task = std::make_shared&lt;std::packaged_task&lt;return_type()&gt;&gt;( std::bind(std::forward&lt;F&gt;(f), std::forward&lt;Args&gt;(args)...)//将函数和参数绑定，实现一个可调用对象 ); std::future&lt;return_type&gt; res = task-&gt;get_future(); { std::lock_guard&lt;std::mutex&gt; lock(queue_mutex); if (stop.load()) throw std::runtime_error(&quot;submit on stopped ThreadPool&quot;); tasks.emplace([task]() { (*task)(); }); //lambda函数中使用参数来捕获了task，使用*task来获取包裹的可调用对象，在使用()来执行 } condition.notify_one();//通知一个线程，有新的任务加入 return res;//返回执行结果 }};// ==================== 使用示例 ====================#include &lt;iostream&gt;#include &lt;chrono&gt;int main() { auto pool = SingletonThreadPool::get_thread_pool(4); std::vector&lt;std::future&lt;int&gt;&gt; results; for (int i = 0; i &lt; 8; ++i) { results.emplace_back( pool-&gt;submit([i] { std::this_thread::sleep_for(std::chrono::milliseconds(100)); std::cout &lt;&lt; &quot;Task &quot; &lt;&lt; i &lt;&lt; &quot; done\\n&quot;; return i; }) ); } for (auto &amp;&amp;result : results) std::cout &lt;&lt; result.get() &lt;&lt; std::endl; return 0;}","link":"/2026/01/04/cpp/C++%E5%B9%B6%E8%A1%8C%E5%92%8C%E5%B9%B6%E5%8F%91/"},{"title":"C++智能指针和内存管理","text":"RAIIRAII即Resource Acquisition is Initialization（资源获取即初始化） 在智能指针中添加了引用计数的概念，引用计数这种计数是为了防止内存泄露而产生的。 基本想法是对于动态分配的对象，进行引用计数，每当增加一次对同一个对象的引用，那么引用对象的引用计数就会增加一次， 每删除一次引用，引用计数就会减一，当一个对象的引用计数减为零时，就自动删除指向的堆内存。 std::unique_ptrstd::unique_ptr 是一种智能指针，它通过指针持有并管理另一对象（对其负责），并在 unique_ptr 离开作用域时释放该对象。 在发生下列两者之一时，用关联的删除器释放对象：（总结就是这个unique_ptr不在指向这个对象） 管理它的 unique_ptr 对象被销毁。 通过 operator= 或 reset() 赋值另一指针给管理它的 unique_ptr 对象。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118#include &lt;cassert&gt;#include &lt;cstdio&gt;#include &lt;fstream&gt;#include &lt;iostream&gt;#include &lt;memory&gt;#include &lt;stdexcept&gt;// 用于下面运行时多态演示的辅助类struct B{ virtual ~B() = default; virtual void bar() { std::cout &lt;&lt; &quot;B::bar\\n&quot;; }};struct D : B{ D() { std::cout &lt;&lt; &quot;D::D\\n&quot;; } ~D() override{ std::cout &lt;&lt; &quot;D::~D\\n&quot;; } void bar() override { std::cout &lt;&lt; &quot;D::bar\\n&quot;; }};// 消费 unique_ptr 的函数能以值或以右值引用接收它std::unique_ptr&lt;D&gt; pass_through(std::unique_ptr&lt;D&gt; p){ p-&gt;bar(); return p;}// 用于下面自定义删除器演示的辅助函数void close_file(std::FILE* fp){ std::fclose(fp);}// 基于 unique_ptr 的链表演示struct List{ struct Node { int data; std::unique_ptr&lt;Node&gt; next; }; std::unique_ptr&lt;Node&gt; head; ~List() { // 循环按顺序销毁各列表节点，默认析构函数将会递归调用其 “next” 指针的析构函数， // 这在足够大的链表上可能造成栈溢出。 while (head) { auto next = std::move(head-&gt;next); head = std::move(next); } } void push(int data) { head = std::make_unique&lt;Node&gt;(data, std::move(head-&gt;next)); }};int main(){ std::cout &lt;&lt; &quot;1) 独占所有权语义演示\\n&quot;; { // 创建一个（独占）资源 std::unique_ptr&lt;D&gt; p = std::make_unique&lt;D&gt;(); // 转移所有权给 “pass_through”，而它再通过返回值将所有权转移回来 std::unique_ptr&lt;D&gt; q = pass_through(std::move(p)); // “p” 现在是已被移动的“空”状态，等于 nullptr assert(!p); } std::cout &lt;&lt; &quot;\\n&quot; &quot;2) 运行时多态演示\\n&quot;; { // 创建派生类资源并通过基类指向它 std::unique_ptr&lt;B&gt; p = std::make_unique&lt;D&gt;(); // 动态派发如期工作 p-&gt;bar(); } std::cout &lt;&lt; &quot;\\n&quot; &quot;3) 自定义删除器演示\\n&quot;; std::ofstream(&quot;demo.txt&quot;) &lt;&lt; 'x'; // 准备要读取的文件 { using unique_file_t = std::unique_ptr&lt;std::FILE, decltype(&amp;close_file)&gt;; unique_file_t fp(std::fopen(&quot;demo.txt&quot;, &quot;r&quot;), &amp;close_file); if (fp) std::cout &lt;&lt; static_cast&lt;char&gt;(std::fgetc(fp.get())) &lt;&lt; '\\n'; } // 在此调用 “close_file()”（如果 “fp” 为空） std::cout &lt;&lt; &quot;\\n&quot; &quot;4) 自定义 lambda 表达式删除器和异常安全性演示\\n&quot;; try { std::unique_ptr&lt;D, void(*)(D*)&gt; p(new D, [](D* ptr) { std::cout &lt;&lt; &quot;由自定义删除器销毁...\\n&quot;; delete ptr; }); throw std::runtime_error(&quot;&quot;); // “p” 是普通指针的情况下此处就会泄漏 } catch (const std::exception&amp;) { std::cout &lt;&lt; &quot;捕获到异常\\n&quot;; } std::cout &lt;&lt; &quot;\\n&quot; &quot;5) 数组形式的 unique_ptr 演示\\n&quot;; { std::unique_ptr&lt;D[]&gt; p(new D[3]); } // “D::~D()” 被调用 3 次} std::shared_ptrstd::shared_ptr 是一种智能指针，它能够记录多少个 shared_ptr 共同指向一个对象，从而消除显式的调用 delete，当引用计数变为零的时候就会将对象自动删除。 使用make_shared&lt;T&gt;(T&amp;&amp;... args),通过传入一个对象（make_shared内使用了完美转发）来获取这个对象类型的shared_ptr指针。 std::shared_ptr 可以通过 get() 方法来获取原始指针，通过 reset() 来减少一个引用计数， 并通过use_count()来查看一个对象的引用计数。 std::shared_ptr 是一种通过指针保持对象共享所有权的智能指针。多个 shared_ptr 对象可持有同一对象。下列情况之一出现时销毁对象并解分配其内存： 最后剩下的持有对象的 shared_ptr 被销毁； 最后剩下的持有对象的 shared_ptr 被通过 operator= 或 reset() 赋值为另一指针。 但是在下面代码，存在着内存泄漏的问题： 1234567891011121314151617181920212223#include &lt;memory&gt;#include &lt;iostream&gt;struct A;struct B;struct A { std::shared_ptr&lt;B&gt; pointer; ~A() { std::cout &lt;&lt; &quot;A 被销毁&quot; &lt;&lt; std::endl; }};struct B { std::shared_ptr&lt;A&gt; pointer; ~B() { std::cout &lt;&lt; &quot;B 被销毁&quot; &lt;&lt; std::endl; }};int main() { auto a = std::make_shared&lt;A&gt;(); auto b = std::make_shared&lt;B&gt;(); a-&gt;pointer = b; b-&gt;pointer = a;}//离开作用域的时候，std::shared_ptr都会被析构，但是Control block中的引用计数不为0，导致对象没有被析构从而引发内存泄漏 std::weak_ptrstd::weak_ptr 是一种智能指针，它持有被 std::shared_ptr 管理的对象的非拥有性“弱”引用。在访问引用的对象前必须先转换为 std::shared_ptr。（使用lock()） weak_ptr不持有对象的生命周期，不算入引用计数 但是可以用weak_ptr判断对象是否过期 std::weak_ptr 实现临时所有权：当某个对象只有存在时才需要被访问，且随时可能被他人删除时，可以使用 std::weak_ptr 来跟踪该对象，需要获得临时所有权时，将其转换为 std::shared_ptr。如果此时销毁了原始 std::shared_ptr，则对象的生命周期将被延长，直到临时 std::shared_ptr 也被销毁为止。 123456789101112131415161718192021222324252627282930#include &lt;memory&gt;#include &lt;iostream&gt;struct A;struct B;struct A { std::shared_ptr&lt;B&gt; pointer; void print() { std::cout &lt;&lt; &quot;A&quot; &lt;&lt;std::endl; } ~A() { std::cout &lt;&lt; &quot;A 被销毁&quot; &lt;&lt; std::endl; }};struct B { std::weak_ptr&lt;A&gt; pointer; void print() { std::cout &lt;&lt; &quot;B&quot; &lt;&lt;std::endl; } ~B() { std::cout &lt;&lt; &quot;B 被销毁&quot; &lt;&lt; std::endl; }};int main() { auto a = std::make_shared&lt;A&gt;(); auto b = std::make_shared&lt;B&gt;(); a-&gt;pointer-&gt;print(); //b-&gt;pointer-&gt;print(); error: base operand of '-&gt;' has non-pointer type 'std::weak_ptr&lt;A&gt;' b-&gt;pointer.lock()-&gt;print();} 引用计数的实现在cpp中，使用shared_ptr的时候，编译器会创建一个Control Block，控制块的实现思想主要是通过封装 引用计数 和 删除器 来确保对象的生命周期由多个智能指针共享时，能够安全、有效地管理资源的分配和释放。 控制块的概念 控制块是一个管理 shared_ptr 引用计数和其他元数据的结构。它包含了： 强引用计数（use_count）：追踪有多少个 shared_ptr 实例引用了这个对象。 弱引用计数（weak_count）：追踪有多少个 weak_ptr 引用了该对象，确保只有所有强引用计数为零时，控制块才会被销毁。 删除器（deleter）：负责销毁被管理的对象。当引用计数归零时，删除器会被调用来销毁对象。 分配器（allocator）：如果 shared_ptr 使用了自定义分配器，控制块也会包含该分配器的状态。 控制块的结构设计 控制块通常是一个独立的结构体或类，它和被管理对象的内存分开存储。这样设计的好处是能确保内存和对象的生命周期是独立管理的，避免了直接将对象和引用计数存在同一块内存中可能导致的效率问题。 下面是一个简单的control block的实现 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190#ifndef SHARED_PTR_H#define SHARED_PTR_H#pragma once#include &lt;iostream&gt;#include &lt;functional&gt;#include &lt;memory&gt;#include &lt;stdexcept&gt;// Forward declarationtemplate &lt;typename T&gt;class shared_ptr;struct ControlBlock { size_t ref_count; void* ptr; std::function&lt;void(void*)&gt; deleter; ControlBlock() : ref_count(0), ptr(nullptr), deleter([](void*){}) {} ControlBlock(size_t ref_count, void* ptr) : ref_count(ref_count), ptr(ptr), deleter([](void* p) {}) {} ControlBlock(size_t ref_count, void* ptr, std::function&lt;void(void*)&gt; d) : ref_count(ref_count), ptr(ptr), deleter(std::move(d)) {} ~ControlBlock() = default;};template &lt;typename T&gt;class shared_ptr { ControlBlock* control_block; T* ptr; void release();public: // Constructors shared_ptr() noexcept : control_block(nullptr), ptr(nullptr) {} explicit shared_ptr(T* p); shared_ptr(const shared_ptr&amp; other) noexcept; shared_ptr(shared_ptr&amp;&amp; other) noexcept; template &lt;typename... Args&gt; static shared_ptr&lt;T&gt; make_shared(Args&amp;&amp;... args); // Destructor ~shared_ptr(); // Assignment operators shared_ptr&amp; operator=(const shared_ptr&amp; other) noexcept; shared_ptr&amp; operator=(shared_ptr&amp;&amp; other) noexcept; // Pointer operations T&amp; operator*() const; T* operator-&gt;() const; T* get() const noexcept; void reset(T* p = nullptr); [[nodiscard]] size_t use_count() const noexcept; // Type conversion explicit operator bool() const noexcept; // Swap two smart pointers void swap(shared_ptr&amp; other) noexcept; // Comparison operations bool operator==(const shared_ptr&amp; other) const noexcept; bool operator!=(const shared_ptr&amp; other) const noexcept;};template &lt;typename T&gt;shared_ptr&lt;T&gt;::shared_ptr(T* p) : control_block(new ControlBlock(1, p)), ptr(p) {}template &lt;typename T&gt;shared_ptr&lt;T&gt;::shared_ptr(const shared_ptr&amp; other) noexcept : control_block(other.control_block), ptr(other.ptr) { if (control_block) { control_block-&gt;ref_count++; }}template &lt;typename T&gt;shared_ptr&lt;T&gt;::shared_ptr(shared_ptr&amp;&amp; other) noexcept : control_block(other.control_block), ptr(other.ptr) { other.control_block = nullptr; other.ptr = nullptr;}template &lt;typename T&gt;template &lt;typename... Args&gt;shared_ptr&lt;T&gt; shared_ptr&lt;T&gt;::make_shared(Args&amp;&amp;... args) { return shared_ptr&lt;T&gt;(new T(std::forward&lt;Args&gt;(args)...));}template &lt;typename T&gt;shared_ptr&lt;T&gt;::~shared_ptr() { release();}template &lt;typename T&gt;void shared_ptr&lt;T&gt;::release() { if (control_block) { control_block-&gt;ref_count--; if (control_block-&gt;ref_count == 0) { if (ptr) { control_block-&gt;deleter(ptr); } delete control_block; } }}template &lt;typename T&gt;shared_ptr&lt;T&gt;&amp; shared_ptr&lt;T&gt;::operator=(const shared_ptr&amp; other) noexcept { if (this != &amp;other) { release(); control_block = other.control_block; ptr = other.ptr; if (control_block) { control_block-&gt;ref_count++; } } return *this;}template &lt;typename T&gt;shared_ptr&lt;T&gt;&amp; shared_ptr&lt;T&gt;::operator=(shared_ptr&amp;&amp; other) noexcept { if (this != &amp;other) { release(); control_block = other.control_block; ptr = other.ptr; other.control_block = nullptr; other.ptr = nullptr; } return *this;}template &lt;typename T&gt;T&amp; shared_ptr&lt;T&gt;::operator*() const { // Dereference operator if (ptr == nullptr) { throw std::runtime_error(&quot;Attempting to dereference a null pointer&quot;); } return *ptr;}template &lt;typename T&gt;T* shared_ptr&lt;T&gt;::operator-&gt;() const { // Arrow operator for accessing members return ptr;}template &lt;typename T&gt;T* shared_ptr&lt;T&gt;::get() const noexcept { return ptr;}template &lt;typename T&gt;void shared_ptr&lt;T&gt;::reset(T* p) { release(); ptr = p; control_block = new ControlBlock(1, p, [](void* p) { delete static_cast&lt;T*&gt;(p); });}template &lt;typename T&gt;size_t shared_ptr&lt;T&gt;::use_count() const noexcept { if(control_block) { return control_block-&gt;ref_count; } return 0;}template &lt;typename T&gt;bool shared_ptr&lt;T&gt;::operator==(const shared_ptr&amp; other) const noexcept { return ptr == other.ptr;}template &lt;typename T&gt;bool shared_ptr&lt;T&gt;::operator!=(const shared_ptr&amp; other) const noexcept { return ptr != other.ptr;}template &lt;typename T&gt;shared_ptr&lt;T&gt;::operator bool() const noexcept { return ptr != nullptr;}template &lt;typename T&gt;void shared_ptr&lt;T&gt;::swap(shared_ptr&amp; other) noexcept { std::swap(control_block, other.control_block); std::swap(ptr, other.ptr);}#endif //SHARED_PTR_H","link":"/2026/01/04/cpp/C++%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88%E5%92%8C%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/"},{"title":"C++编译与内存相关","text":"1.cpp文件从解析到执行发生了什么？ 预处理：.cpp文件经过预处理生成文本文件.i格式的文件。在这个过程中，对原始的cpp文件中删除注释，展开宏等等。以方便进行下一步处理 编译+汇编：依据在预处理阶段生成的.i文件，进行词法、语法分析和语义检查，之后使用机器字进行替代，转为由汇编语言组成的.o文件 链接：根据编译阶段生成的.o文件，以及静态链接库.a或者动态链接库.so。这由链接方式决定。将.o文件和其执行所需要的库文件进行链接，生成最终的可执行文件。此时也是在这个阶段，.o文件被组合为一个单独的可执行文件，并且生成一个ELF格式的文件。这个ELF文件包括了：可执行代码（.text段），数据（.data段），未初始化数据（.bss段），动态链接信息（如果需要），调试信息（如果启用）。**最终可执行文件的格式就是ELF文件。**ELF文件中保存的内容是编译后运行前生成的内容 加载：在程序执行时，操作系统的加载器会将ELF文件加载到内存中。加载器会根据ELF文件的头部信息（如程序头表和节区头表）确定各个段（如 .text、.data等）的内存位置，并将它们加载到内存中。随后，程序开始执行。 2.函数调用过程中内存发生了什么？现有如下代码： 12345678910void foo(int a) { int b = a + 1; // 函数执行完毕}int main() { int x = 10; foo(x); // 调用foo函数 return 0;} 栈帧： 栈帧是每个函数调用时在栈中分配的内存区域，它包含了函数的返回地址、调用者的栈帧指针、局部变量、参数等信息。栈帧的管理是栈内存结构的核心，每次发生新的函数调用，都会由新的栈帧被创建。通常存在寄存器 %rbp中 栈顶： 栈顶指向的是栈内存顶部的区域，它是栈中当前活动的地址位置。通常存在寄存器 %rsp中 发生函数调用时：首先新创建一个新的栈帧，然后将调用者调用的函数结束后的下一条指令的地址压入栈中（返回地址）。然后在将调用者的栈帧的栈指针压入栈中，以及一些上下文的寄存器状态。之后在从右到左依次向栈中压入函数参数，之后在压入一些局部变量。遵循着这样的顺序。 3.申请堆内存产生的内存碎片 由于程序申请堆内存空间是动态的，而堆内存的管理是操作系统或者内存管理程序分配或者回收的，因此不可避免的会产生内存碎片。 如何解决内存碎片： 内存池技术：提前分配好内存，用内存池来管理 垃圾回收机制：标记和整理内存来回收未使用的内存，以此来减少碎片 最佳适配算法：动态分配时选择最适合需求大小的内存块，避免过多的小碎片 合并内存空间：释放内存时，尝试将相邻的空闲内存块合并成更大的块 4.CPP的内存对齐 每种数据类型都有一个对齐要求，即它的起始地址必须是该对齐值的倍数。 要求内存对其可以减少访问内存的延时，来提升性能。 5.智能指针的介绍与使用 std::unique_ptr:是一种独占式的智能指针，意味着同一时刻只能有一个 unique_ptr 指向某个对象。同时 unique_ptr不允许赋值，只能通过 std::move转移所有权。当独占式指针超出作用域后，会自动销毁。 std::share_ptr:是一种共享的只能指针，多个 shared_ptr 可以共同拥有同一个对象，智能指针内部会使用引用计数来追踪有多少 shared_ptr 指向同一个对象。当这个引用计数为0的时候，就会释放掉共享指针 std::weak_ptr：是一种弱指针，std::weak_ptr 不影响对象的引用计数，它用于观察一个由 shared_ptr 管理的对象。用于避免由于循环引用（指两个struct中互相有指针互相引用，导致互相持有无法释放，用 weak_ptr就可以解决这个问题）导致 shared_ptr无法释放 总结：std::unique_ptr通过判断在不在作用域来销毁，而 std::share_ptr通过内部的引用计数来判断是否需要销毁。 在使用智能指针的时候，尽量避免手动new，这样会需要两次手动内存分配 6.大端与小端 大端存储：高字节在高位，符合人类手写习惯。适用于网络通讯协议 小端存储：低字节在低位，更适合计算机的运算。常见于x86_64机器 7.内存泄漏 内存泄漏：指的是程序动态分配的内存未被释放，导致内存长期占用，最终可能导致内存耗尽、程序崩溃等问题。比如new了一个堆空间，但是一直没有delete 如何避免内存泄漏： 避免手动管理内存，使用智能指针（C++） 使用 RAII 资源管理（C++）：将资源（内存、文件、锁、数据库连接等）与对象的生命周期绑定，确保资源在对象销毁时自动释放，防止资源泄漏。 解决循环引用问题和避免悬垂指针 8.include include “ “和include&lt;&gt;的区别：include “ “首先从当前源文件所在目录或用户指定的目录中搜索头文件，如果找不到，则去库文件中寻找。而include&lt;&gt;则是直接去库文件中寻找对应的头文件","link":"/2026/01/04/cpp/C++%E7%BC%96%E8%AF%91%E4%B8%8E%E5%86%85%E5%AD%98%E7%9B%B8%E5%85%B3/"},{"title":"C++语言特性相关","text":"1.左值引用右值引用左值（Lvalue，Locator Value）指的是可以被取地址的值，即在表达式结束后仍然存在的对象。例如，变量、数组元素、对象等都是左值。 左值引用用于绑定左值，并且通常用于传递和修改可变对象。 123int a = 10;int&amp; ref = a; // ref 绑定到 aref = 20; // 修改 ref 也会影响 a 右值（Rvalue，Right-hand value）指的是无法取地址的临时值，通常是表达式计算的结果，如字面量、临时变量等。 右值引用使用 &amp;&amp; 语法，用于绑定右值，使得右值可以被高效地移动，而不是复制。 12int&amp;&amp; rref = 10; // 10 是右值，可以绑定到右值引用std::cout &lt;&lt; rref &lt;&lt; std::endl; // 输出 10 左值引用 vs 右值引用 左值引用 &amp; 右值引用 &amp;&amp; 绑定对象 只能绑定左值 只能绑定右值 修改对象 可以修改 可以修改 适用场景 传递可变对象 移动语义、避免拷贝 常见用法 普通变量引用、函数参数 移动构造、移动赋值 2.左值引用和右值引用的转化 std::move():是一个转换工具，用于将左值强制转换为右值，从而触发移动语义 std::forward&lt;T&gt;():主要用于泛型编程，保证在模板参数传递时，保留左右值的原始属性，实现完美转发。 std::move_if_noexcept():在某些情况下，如果移动构造可能抛出异常，我们可能更希望使用拷贝构造。std::move_if_noexcept 可用于这种情况 3.指针的大小与用法 指针的大小和编译器的目标平台的位数，而与所指向的数据类型无关。如果是32位的机器，则指针的大小则是4Byte，如果是64位机器，那么指针的大小是8Byte。 指针存储变量的内存地址，使用 &amp; 获取地址，使用 * 解引用指针以访问数据。 指针作为函数参数：实现传址调用，允许函数直接修改原始数据。函数指针：用于回调机制或策略模式等 4.指针和引用的区别总结对比表 特性 指针 引用 是否需要初始化 不需要，可以为空 必须初始化 是否能重新指向 可以 不可以 是否可为空 可以指向 nullptr 不可以 是否有独立内存 是，占用内存存储地址 否，与原变量共用内存 是否可修改值 通过 * 解引用后可修改 可修改（除非 const 修饰） 典型应用场景 动态内存分配、数据结构 参数传递、引用更安全的别名 5.指针常量和常量指针常量指针（const T*）：指向的值不能修改，但指针本身的指向可以更改。（即只能读，不能修改） 指针常量（T* const）：指针本身的指向不能更改，但指向的值可以修改。 6.函数指针的定义函数指针 (Function Pointer) 是指向函数的地址的指针。与普通指针不同，函数指针指向的是可执行代码段中的函数入口地址，而非数据 函数指针的基本语法 定义函数指针的一般形式为： 1返回类型 (*指针变量名)(参数类型列表); 7.CPP中函数传递参数的方法在 C++ 中，函数传递参数的方式主要有以下几种： 值传递（Pass by Value） 形参是实参的副本，在函数内对参数的修改不会影响原始数据。 适用于基本数据类型，但对于大对象会导致不必要的拷贝开销。 1void func(int x) { x = 10; } 引用传递（Pass by Reference） 形参是实参的引用，函数内的修改会直接影响原始数据。 适用于需要修改参数的情况，或者避免拷贝大对象以提升效率。 1void func(int&amp; x) { x = 10; } 指针传递（Pass by Pointer） 形参是指向实参的指针，可以在函数内修改原数据。 需要检查指针是否为空，避免空指针访问错误。 1void func(int* x) { if (x) *x = 10; } 常量引用传递（Pass by Const Reference） 适用于大对象的只读传递，既避免了拷贝，又保证了数据不会被修改。 1void func(const std::string&amp; str) { std::cout &lt;&lt; str; } 右值引用传递（Pass by Rvalue Reference）（C++11及以上） 允许传递右值（临时对象），通常用于移动语义（move semantics），提高效率。 1void func(std::string&amp;&amp; str) { std::cout &lt;&lt; str; } 智能指针传递（Pass by Smart Pointer）（C++11及以上） 通过 std::shared_ptr 或 std::unique_ptr 传递对象，管理内存生命周期。 1void func(std::shared_ptr&lt;int&gt; ptr) { std::cout &lt;&lt; *ptr; } 不同的方式适用于不同的场景，应根据性能需求和数据安全性来选择合适的参数传递方式。 8.迭代器迭代器（Iterator）是 C++ STL（标准模板库） 中用于遍历容器（如 vector、list、map 等）的一种通用接口。迭代器提供了一种类似指针的方式来访问容器中的元素，同时又能适应不同类型的容器。 C++ 提供了 五种迭代器，分别适用于不同类型的容器和操作： 迭代器类型 说明 适用容器 输入迭代器 (InputIterator) 只能 从前向后读取 数据 istream_iterator 输出迭代器 (OutputIterator) 只能 向前写入 数据 ostream_iterator 前向迭代器 (ForwardIterator) 可读可写，可单向移动 forward_list 双向迭代器 (BidirectionalIterator) 可读可写，可双向移动 list、map、set 随机访问迭代器 (RandomAccessIterator) 可读可写，可随机跳转 vector、deque 常见 STL 容器的迭代器 容器 begin() end() 迭代器类型 vector vector&lt;int&gt;::iterator vector&lt;int&gt;::iterator 随机访问 list list&lt;int&gt;::iterator list&lt;int&gt;::iterator 双向 map map&lt;int, int&gt;::iterator map&lt;int, int&gt;::iterator 双向 set set&lt;int&gt;::iterator set&lt;int&gt;::iterator 双向 9.野指针和悬空指针野指针 vs 悬空指针 类别 定义 产生原因 如何修正 野指针 未初始化的指针，指向未知地址 1. 没有初始化 2. 释放后未置空 3. 超出作用域 初始化指针为 nullptr 悬空指针 指向已释放的无效内存 1. 释放后仍然访问 2. 作用域结束后访问 3. 二次释放 释放后将指针置空 10.类型转化static_cast vs dynamic_cast 特性 static_cast dynamic_cast 转换时间 编译时 运行时 是否安全检查 ❌ 无检查 ✅ 运行时检查 适用范围 基本类型、多态类型、void* 仅适用于多态类型 转换失败时 未定义行为 返回 nullptr（指针）/ 抛异常（引用） 速度 ⚡ 高效 🐢 慢（因运行时检查） 四种转换方式对比 转换类型 转换方式 运行时检查 适用范围 推荐使用情况 static_cast 编译时转换 ❌ 无 兼容类型转换 ✅ 用于安全转换，如 int → double dynamic_cast 运行时转换 ✅ 有 多态类型（有虚函数） ✅ 适用于父子类转换，确保安全 const_cast 移除/添加 const ❌ 无 指针/引用 ✅ 需要修改 const 变量时 reinterpret_cast 低级转换 ❌ 无 指针/整数/位级转换 ⚠️ 极少使用，仅用于底层编程","link":"/2025/02/25/cpp/C++%E8%AF%AD%E8%A8%80%E7%89%B9%E6%80%A7%E7%9B%B8%E5%85%B3/"},{"title":"C++语言运行期的强化","text":"lambda表达式 基础：lambda表达式的基本语法如下： 123[捕获列表](参数列表) mutable(可选) 异常属性 -&gt; 返回类型 {// 函数体} 在其中，捕获列表起到了传递外部数据的作用，根据传递的行为，捕获列表可以分为以下几种： 值捕获：与参数传值类似，值捕获的前提是变量可以拷贝，不同之处则在于，被捕获的变量在 Lambda 表达式被创建时拷贝， 而非调用时才拷贝。（在Lambda表达式被传建的时候，会对捕获的变量保存一个内部的拷贝，在修改捕获变量的值不会影响结果） 1234567891011void lambda_value_capture() { int value = 1; auto copy_value = [value] { return value; }; value = 100; auto stored_value = copy_value(); std::cout &lt;&lt; &quot;stored_value = &quot; &lt;&lt; stored_value &lt;&lt; std::endl; // 这时, stored_value == 1, 而 value == 100. // 因为 copy_value 在创建时就保存了一份 value 的拷贝} 引用捕获：引用捕获保存的是引用，获取最新的捕目标的值 1234567891011void lambda_reference_capture() { int value = 1; auto copy_value = [&amp;value] { return value; }; value = 100; auto stored_value = copy_value(); std::cout &lt;&lt; &quot;stored_value = &quot; &lt;&lt; stored_value &lt;&lt; std::endl; // 这时, stored_value == 100, value == 100. // 因为 copy_value 保存的是引用} 隐式捕获：让编译器自己去猜测要捕获的变量 [] 空捕获列表 [name1, name2, …] 捕获一系列变量 [&amp;] 引用捕获, 从函数体内的使用确定引用捕获列表 [=] 值捕获, 从函数体内的使用确定值捕获列表 函数对象包装器 std::function：std::function 是一种通用、多态的函数封装， 它的实例可以对任何可以调用的目标实体进行存储、复制和调用操作， 它也是对 C++ 中现有的可调用实体的一种类型安全的包裹（相对来说，函数指针的调用不是类型安全的）， 换句话说，就是函数的容器。 std::bind和 std::placeholder,std::bind 则是用来绑定函数调用的参数的， 它解决的需求是我们有时候可能并不一定能够一次性获得调用某个函数的全部参数，通过这个函数， 我们可以将部分调用参数提前绑定到函数身上成为一个新的对象，然后在参数齐全后，完成调用。而 std::placeholder则是占位函数，用于表明调用时用户来提供函数 123456789101112131415161718192021#include &lt;iostream&gt;#include &lt;functional&gt;class MyClass {public: void print(int x) { std::cout &lt;&lt; &quot;Value: &quot; &lt;&lt; x &lt;&lt; std::endl; }};int main() { MyClass obj; // 绑定成员函数，需要提供实例对象 auto boundFunc = std::bind(&amp;MyClass::print, &amp;obj, std::placeholders::_1); // 调用绑定的函数，相当于 obj.print(42) boundFunc(42); return 0;} 右值引用 左值：左值是表达式（不一定是赋值表达式）后依然存在的持久对象 右值：右值指表达式结束后就不再存在的临时对象 纯右值：纯粹的右值，要么是纯粹的字面量，例如 10, true； 要么是求值结果相当于字面量或匿名临时对象，例如 1+2。非引用返回的临时变量、运算表达式产生的临时变量、 原始字面量、Lambda 表达式都属于纯右值 将亡值：即将被销毁、却能够被移动的值 右值引用和左值引用: 要拿到一个将亡值，就需要用到右值引用：T &amp;&amp;，其中 T 是类型。 右值引用的声明让这个临时值的生命周期得以延长、只要变量还活着，那么将亡值将继续存活 1234567891011121314151617181920212223242526272829#include &lt;iostream&gt;#include &lt;string&gt;void reference(std::string&amp; str) { std::cout &lt;&lt; &quot;左值&quot; &lt;&lt; std::endl;}void reference(std::string&amp;&amp; str) { std::cout &lt;&lt; &quot;右值&quot; &lt;&lt; std::endl;}int main(){ std::string lv1 = &quot;string,&quot;; // lv1 是一个左值 // std::string&amp;&amp; r1 = lv1; // 非法, 右值引用不能引用左值 std::string&amp;&amp; rv1 = std::move(lv1); // 合法, std::move可以将左值转移为右值 std::cout &lt;&lt; rv1 &lt;&lt; std::endl; // string, const std::string&amp; lv2 = lv1 + lv1; // 合法, 常量左值引用能够延长临时变量的生命周期 // lv2 += &quot;Test&quot;; // 非法, 常量引用无法被修改 std::cout &lt;&lt; lv2 &lt;&lt; std::endl; // string,string, std::string&amp;&amp; rv2 = lv1 + lv2; // 合法, 右值引用延长临时对象生命周期 rv2 += &quot;Test&quot;; // 合法, 非常量引用能够修改临时变量 std::cout &lt;&lt; rv2 &lt;&lt; std::endl; // string,string,string,Test reference(rv2); // 输出左值 return 0;} 完美转发在作参数转发的时候，保证左值和右值可以被正确的传递 1234567891011121314151617181920212223242526272829#include &lt;iostream&gt;#include &lt;utility&gt;void reference(int&amp; v) { std::cout &lt;&lt; &quot;左值引用&quot; &lt;&lt; std::endl;}void reference(int&amp;&amp; v) { std::cout &lt;&lt; &quot;右值引用&quot; &lt;&lt; std::endl;}template &lt;typename T&gt;void pass(T&amp;&amp; v) { std::cout &lt;&lt; &quot; 普通传参: &quot;; reference(v); std::cout &lt;&lt; &quot; std::move 传参: &quot;; reference(std::move(v)); std::cout &lt;&lt; &quot; std::forward 传参: &quot;; reference(std::forward&lt;T&gt;(v)); std::cout &lt;&lt; &quot;static_cast&lt;T&amp;&amp;&gt; 传参: &quot;; reference(static_cast&lt;T&amp;&amp;&gt;(v));}int main() { std::cout &lt;&lt; &quot;传递右值:&quot; &lt;&lt; std::endl; pass(1); std::cout &lt;&lt; &quot;传递左值:&quot; &lt;&lt; std::endl; int v = 1; pass(v); return 0;} 无论传递参数为左值还是右值，普通传参都会将参数作为左值进行转发； 由于类似的原因，std::move 总会接受到一个左值，从而转发调用了 reference(int&amp;&amp;) 输出右值引用。 唯独 std::forward 即没有造成任何多余的拷贝，同时完美转发(传递)了函数的实参给了内部调用的其他函数","link":"/2026/01/04/cpp/C++%E8%AF%AD%E8%A8%80%E8%BF%90%E8%A1%8C%E6%9C%9F%E7%9A%84%E5%BC%BA%E5%8C%96/"},{"title":"C++面向对象","text":"1.面向对象的三大特性：封装，继承，多态 2.重载、**重写 和 **隐藏 对比项 重载（Overloading） 重写（Overriding） 隐藏（Hiding） 作用域 同一个类 继承体系（子类 vs. 父类） 继承体系（子类 vs. 父类） 函数名 相同 相同 相同 参数列表 必须不同 必须相同 可相同或不同 返回类型 可以不同，但不影响重载 不能改变（C++11 允许协变返回类型） 可以不同 访问方式 直接调用 通过基类指针或引用调用 直接调用 虚函数 无关 必须是 virtual 无关 影响 编译期选择不同方法 运行时调用子类方法（动态绑定） 隐藏父类同名方法，必须使用 Base::func() 访问 重载（Overloading） 发生在同一个类，参数不同，返回值可以不同，属于编译期多态。 重写（Overriding） 发生在继承体系，子类重写基类的虚函数，必须函数签名（用于在重载时标识不同的函数）一致，属于运行时多态。 隐藏（Hiding） 发生在继承体系，但不是虚函数重写，而是子类定义了同名函数，隐藏了父类版本，调用父类方法需要 Base::func()。 在实践中，虚函数重写是 OOP 里最重要的特性，它允许多态行为，而隐藏可能导致代码难以维护，因此建议避免让子类的方法隐藏父类的方法，除非有特殊需求。 3.多态及其实现办法 多态分为运行时多态（通过虚函数实现）和编译时多态（通过函数重载和模板实现）。 运行时多态执行的核心步骤 （运行时多态，虚函数必须为 virtual,否则可能会引起内存泄漏） 对象构造时初始化虚函数指针（vptr，存储在对象的实例内存中） 当对象被构造时，编译器会隐式地在对象内存中插入一个指向**虚函数表（vtable）**的指针（vptr）。 vptr 的值由对象的实际类型决定。例如： Base 类型的对象，vptr 指向 Base 的虚函数表。 Derived 类型的对象，vptr 指向 Derived 的虚函数表。 虚函数表（vtable）的结构 （存储在只读数据段中，并且全局唯一） 每个有虚函数的类都有一个对应的虚函数表（静态存储区）。 虚函数表是一个函数指针数组，每个条目指向该类的虚函数实现。 若派生类覆盖了基类的虚函数，则虚函数表中对应的条目会被替换为派生类的函数地址。 通过基类指针或引用调用虚函数 当通过基类指针或引用调用虚函数时，编译器会生成代码： 从对象的 vptr 找到对应的虚函数表。 根据虚函数在表中的索引（由编译器确定）找到函数地址。 调用该函数地址指向的实现。 4.虚函数和纯虚函数在虚函数中，基类需要提供默认实现，并且基类是可以实例化的。但是在纯虚函数中，基类不提供实现（但是可以定义，但是使用必须显示的使用），同时基类不允许被实例化，并且派生类必须覆盖，要给出纯虚函数的实现，否则仍然是抽象类。（只要类中有一个纯虚函数，那么这个类就不能被初始化） 纯虚函数更多的应用在接口之中，来实现接口和实现的分离，充分体现面向对象的特性。此外，纯虚函数也和虚函数一样，要指定虚构函数，并且为`virtual` 为什么纯虚类的构造函数必须是`virtual`的：因为多态对象的析构是从派生类开始到基类结束的，只有这样才能保证内存被正确的释放。在析构时，需要动态调用来保证资源的全部释放。 5.多继承在 CPP中，与 Java不同的一点是 CPP允许多继承。 123class Derived : public Base1, public Base2 { // ...}; 但是在多继承中，常见的问题是二义性问题，和棱形问题 菱形问题： 当一个派生类从两个或多个基类继承，而这些基类又共同继承自同一个基类时，会导致二义性 和数据冗余 。用虚继承可以解决这个问题 二义性问题： 如果多个基类有同名成员，直接访问会引发编译错误。用显式指定基类的作用域可以解决这个问题。 6.深拷贝和浅拷贝 深拷贝：会重新复制内容并且分配内存，并且每个对象独立管理其对应的内存（类似于 unique_ptr） 浅拷贝：只会复制指针的地址，并且多个对象共享同一块内存。但是可能会导致double free，悬垂指针的问题。 此外资源管理类 必须遵循”Rule of Three “： 如果定义了析构函数、拷贝构造函数或赋值运算符中的任意一个，通常需定义全部三个 7.Base* ptr = new Derived()的一些理解 首先是Base* ptr，这表明ptr是静态类型Base*,并且是保存在栈空间上的 然后ptr指向的是堆空间上的Derive()对象。这表明动态类型是Derived() 这里，由于Derived是继承的Base，因此在Derived的堆空间中，结构是这样的（如果Base有虚函数），同时Base中的属性也会被继承下来（无论是否private）只不过在Derived中无法访问。 12345678堆上的 Derived 对象：+------------------+| vptr(指向Derived) |+------------------+| base_data |+------------------+| derived_data |+------------------+ 注意，这里的Base* ptr只能访问Base类中的属性和方法。当访问Base中的虚函数时，编译器会因为访问虚函数，因此触发动态调用，使用虚函数表指针去虚函数表中寻找 8.单继承和多继承的虚函数表单继承 只有 1 张 vtable，对象中只有 1 个 vptr。 调用虚函数时，vptr 访问 vtable，跳转到函数地址。 多继承 每个 Base 类有独立的 vtable，Derived 有多个 vptr。 访问 Base1 相关函数时，走 vptr1 → vtable_for_Base1。 访问 Base2 相关函数时，走 vptr2 → vtable_for_Base2。 9.如何禁止构造函数的使用 方法 适用场景 是否允许子类实例化 = delete 彻底禁止构造 ❌ private 构造函数 外部不能创建对象，但 friend 可创建 ❌ protected 构造函数 允许子类创建对象，但基类不可实例化 ✅ static 方法 通过 static 方法创建对象（单例模式） ❌ 抽象类（纯虚函数） 作为基类强制继承 ✅ 10.什么是默认构造函数默认构造函数是没有参数或所有参数都有默认值的构造函数。如果程序员没有显式定义构造函数，编译器会自动提供一个默认构造函数。 没有参数 或者 所有参数都有默认值。 用于创建对象时自动调用，初始化对象的成员变量。 如果没有显式定义，编译器会自动生成一个（但不会初始化成员变量）。 如果定义了其它带参数的构造函数，编译器不会再提供默认构造函数（C++11 之后）。 11.如何提高构造函数的效率使用成员初始化列表构造效率最高的原因：避免了默认构造和赋值的双重开销，而是直接调用构造函数 1234567891011class Example { std::string s;public: // 初始化列表：直接调用 std::string 的构造函数 Example() : s(&quot;Hello&quot;) {} // 构造函数体内赋值：先默认构造 s，再赋值 Example() { s = &quot;Hello&quot;; // 生成临时字符串对象，再赋值给 s }}; 优势从上面就显而易见 优化方法 适用场景 优化点 使用成员初始化列表 =&gt; A() : x(10), y(3.14) {} 成员变量的初始化 避免默认构造 + 赋值 避免不必要的构造 =&gt; void foo(A a) { } // ❌ void foo(const A&amp; a) { } // ✅ 传参、返回值 传引用、RVO 优化 使用 explicit 防止隐式转换 避免额外构造 避免 new 动态分配 资源管理 使用栈分配或智能指针 优化容器初始化 std::vector 等容器 直接初始化，避免扩容 使用 = default 编译器优化 让编译器自动优化 使用 std::move 资源移动优化 避免不必要的拷贝 12.类对象初始化顺序首先按照继承的顺序进行基类的初始化 –&gt; 然后按照成员变量的申明顺序初始化，和构造函数初始化列表中的顺序无关 –&gt; 然后进行构造函数体的执行 构造函数初始化列表指的是： 123Derived() : m2(&quot;m2&quot;), m1(&quot;m1&quot;) { // 初始化列表顺序：m2 → m1（实际顺序仍按声明） cout &lt;&lt; &quot;Derived constructor\\n&quot;;} 13.友元函数的作用和使用场景 运算符重载：当需要重载 &lt;&lt;或者 &gt;&gt;的时候，由于左操作数是 ostream 或 istream 跨类访问私有成员 工具函数需要访问私有数据 需要注意的是： 友元函数的注意事项 破坏封装性友元函数会暴露类的内部实现，需谨慎使用，避免过度依赖。 友元关系不可传递若类 A 是类 B 的友元，类 B 是类 C 的友元，类 A 不会自动成为 类 C 的友元。 友元声明的位置友元函数的声明必须出现在类的内部（通常在 public 或 private 区域，但权限不影响友元的访问能力）。 友元函数不是成员函数 友元函数不属于类的成员，没有 this 指针。 调用时直接通过函数名，而非对象（如 exchange(a, b)）。 友元类可以将整个类声明为友元： 123class A { friend class B; // 类 B 的所有成员函数都可以访问 A 的私有成员}; 14.静态绑定和动态绑定 绑定时机 编译时 运行时 函数类型 非虚函数、重载函数、模板函数 虚函数（virtual functions） 性能 无额外开销 需查虚函数表，有轻微开销 灵活性 固定，无法动态改变行为 灵活，支持多态 15.cpp模板编程C++ 模板编程是泛型编程的核心技术，允许你编写与类型无关的通用代码。模板编程也是一种多态 函数模板：用于创建通用函数，自动推导参数类型 类模板：用于创建通用类（如容器） 模板特化：为特定类型提供定制化实现 模板元编程：在编译期执行计算，例如计算阶乘 12345678910template &lt;int N&gt;struct Factorial { static const int value = N * Factorial&lt;N-1&gt;::value;};template &lt;&gt;struct Factorial&lt;0&gt; { // 终止条件 static const int value = 1;};// 使用std::cout &lt;&lt; Factorial&lt;5&gt;::value; // 输出 120（编译期计算） 16.如何避免不必要的拷贝来提高效率 使用引用或者指针来传递值 -&gt; 避免不必要的大型对象拷贝 针对资源管理类使用 std::move来移动所属权 尽可能的避免使用临时对象 17.实例化一个对象需要哪几个阶段 阶段 描述 1. 分配内存 在栈上或堆上分配存储空间 2. 调用构造函数 初始化对象、调用基类构造函数 3. 执行初始化 初始化成员变量，拷贝/移动构造等 4. 使用对象 调用方法、访问成员变量 5. 调用析构函数 释放资源，执行清理操作 对象的实例化并不仅仅是构造函数的调用，而是一个完整的生命周期管理过程 18.如何让类中的函数无法访问类的成员变量 方法 是否能访问成员变量 适用场景 static 成员函数 ❌ 无法访问 工具类、无状态函数 内部 private 类 ❌ 无法访问 数据封装，防止误操作 PIMPL 设计模式 ❌ 无法访问 API 设计，隐藏实现细节 friend 友元类 ✅ 友元可访问 需要控制访问权限 如果目标是让类的普通成员函数无法访问数据成员，最佳方案是使用 static 方法 或 隐藏数据（PIMPL、内部类）。 19.怎么限制类的对象只能创建在栈上或者堆上 限制在堆上： 将构造函数以及析构函数设为私有，同时提供一个静态的工厂函数用来返回在堆上创建的对象。（注意，这样做必须要手动释放堆空间，调用delete()直接delete this即可） 限制在栈上： 删除 new和 delete关键字，来禁止在堆上创建 12void* operator new(size_t) = delete; // 禁止 newvoid operator delete(void*) = delete; // 禁止 delete 20.类的默认私有继承和公有继承在继承中，父类的所有属性和操作都会被继承到子类中，但是由于继承的默认是私有继承，导致无法直接访问父类的方法。（在下面的代码中，如果是 class Test : Derived那么Test的实例t无法直接调用 t.Derived::foo()）。而在类中的 private,protected,public修饰的操作或者属性，仅仅用于类的不同访问者的访问权限。 123456789101112131415161718192021222324252627282930313233#include &lt;iostream&gt;using namespace std;class Base {public: virtual void foo() = 0; virtual void bar() = 0; virtual ~Base() = default;};class Derived : Base { // 需要 public 继承public: void foo() override { // override 关键字增强可读性 cout &lt;&lt; &quot;Derived::foo&quot; &lt;&lt; endl; } void bar() final { // 需要 override 来表明继承自 Base cout &lt;&lt; &quot;Derived::bar&quot; &lt;&lt; endl; }};class Test : public Derived{ // 需要 public 继承public: void foo() override { cout &lt;&lt; &quot;Test::foo&quot; &lt;&lt; endl; }};int main() { Derived d; d.foo(); d.bar(); Test t; t.foo(); t.Derived::foo(); // 这行仍然是合法的，但没有必要 return 0;}","link":"/2025/02/25/cpp/C++%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"},{"title":"Java语言基础","text":"Java程序基础类型Java的类型分为两大类,分别是基本数据类型和引用类型 基本数据类型:byte, short, int, long, float, double, char 引用类型:除了上述的基本数据类型,其它所有的类型都是引用类型. 其中,数组Array也是引用类型 数组的使用:Java和C++略有不同,其中数组的声明是以类型+[]的形式. 1234//声明一个int类型的int数组int[] num = {1,2,3,4,5};//声明一个String类型的数组String[] strings = {&quot;hello&quot;,&quot;world&quot;}; 需要注意的是: 如果对数组进行Arrays.sort方法排序,如果存储的类型是基本的数据类型,那么会直接对存储的数据做操作,如果是引用的类型的话,并不会直接移动在JVM中实际的存储位置,而是会只对其引用做排序. 面向对象基础面向对象的基础即三个:封装,多态,继承. 所有面向对象的知识都是围绕这三个展开的 类(class)和实例(instance)类是对现实世界进行抽象来映射到计算机模型的产物.而实例则是依据类实例化的产物. 类也可以理解为对一个概念的封装 就好比:人是一个抽象概念,而笔者则是人的一个实例 字段(feilds)和方法(method)字段和方法从UML中的定义去理解可能会更加的简单.即字段是属性,而方法则是操作 使用方法就要使用参数,这里对方法的参数作出介绍: 要强调的是: 参数如果是基本类型,那么会在存储位置直接作出修改；如果是引用类型,那么传递的实际上是引用的地址 方法参数: 方法可以包括0个或者多个参数,调用方法的时候参数必须一一对应传递 可变参数: 和CPP 17之后引入的折叠表达式一样, 使用类型...定义. this变量: 这里我个人倾向放在方法中来讲,因为每个方法都能访问到this变量,可以理解为隐藏在方法内的参数 提到方法,有一种特殊的方法,是用来创造实例的,即构造(construct). 如果一个类没有申明任何一个构造函数,那么Javac会默认实现一个构造函数. 如果你一但申明了构造函数,那么Javac就不会这么做. 这里和C++有很大的不同,GCC是一定默认生成构造函数的. 继承(inheritance)首先要明确的是, 为了避免cpp中多继承产生的很多问题, 在Java所有的继承都是单继承. 提到继承, 就必须要提类的访问权限控制.Java 一共有四种访问控制级别,如下表所示 修饰符 当前类 同一包 子类（不同包） 其他包 说明 public ✅ 可访问 ✅ 可访问 ✅ 可访问 ✅ 可访问 最宽松，所有地方都能访问 protected ✅ 可访问 ✅ 可访问 ✅ 可访问 ❌ 不可访问 子类可以访问（即使在不同包），但普通外部类不行 **(default)**无修饰符 ✅ 可访问 ✅ 可访问 ❌ 不可访问 ❌ 不可访问 又叫 包级私有，同包内可见 private ✅ 可访问 ❌ 不可访问 ❌ 不可访问 ❌ 不可访问 最严格，只能在本类中访问 继承的使用时机: 在面向对象的课程中,老师都介绍过三种对象之间关系的概念: is-a : 代表着类与类之间是继承关系,这时就要使用extends或者implements has-a: 代表着类与类之间是组合或者聚合关系,这个时候则是要在字段feilds中添加 uses-a: 代表着类与类之间是一种依赖关系,这时经常出现在方法method的参数中,表示依赖 三者的关联程度从高到低依次排序为: is-a; has-a; uses-a 上面已经介绍了继承的具体使用时机 super 在Java中, super关键字代表这父类(超类), 和this关键字类似,可以使用super关键字访问父类的字段和方法. 需要注意是的在子类的构造函数中,首先一定会调用父类的构造函数,否则子类一定会构造失败. 很多时候并没有看见super()方法,这是因为父类如果有默认的构造函数,那么在子类中就不用声明,否则一定要使用父类的构造函数 final 在Java中, final修饰符号可以用来修饰类, 方法, 变量 final 修饰类 : 表示阻止继承, 不允许任何类继承这个类 final 修饰方法 : 表示这个方法在继承之后不允许被重写 final 修饰变量: 表示这个变量不允许被修改(和C++中的const一个作用,不过java中没有const) 总之,在不同的场景下, final的意思略有不同,需要注意区分 向上转型和向下转型 向上转型: 显然向上转型是安全且一定成功的, 因为子类会继承父类所有的字段. 本质上向上转型是做了抽象,来满足OOP需求 向下转型: 向下转型是不安全且不一定成功的, 向下转型一定要用 instanceof 判断 多态(Polymorphism)多态分为静态多态和动态多态, 也叫做编译期多态(函数重载 overload)和运行期多态(函数重写 override) 函数重载: 函数名称要求必须一样, 返回值,参数要求可以不一样. 所有的函数重载都要写在一个类中 函数重写: 函数名称,返回值参数要求必须一样 静态多态是编译期决定的, 由编译器依据方法签名确定的；而动态多态,则是在运行时, 有JVM查找vtable来决定具体使用哪个方法 接口(interface)和抽象类(abstract class)抽象类和接口的相同之处: 两者都不能被实例化, 都是定义某种规范 两者都能有抽象方法和非抽象方法, 不过接口中的非抽象方法一定是default的 不同之处: 抽象类更适合描述高层抽象概念是规则的制定者；而接口更像是一种特性一种标签. 实现了这个接口的类就表明有了这个这个特性(比如cloneable, comparable). 正因为如此, 所以一个类可以实现多个接口. 抽象类也是类,除了不能实例化, 它拥有类的所有功能 接口则不一样, 在接口中所有声明的字段都是 static final属性的, 即使你并没有写static final标识符.(即不能字段是不能实例化的) 总之, 抽象类和接口的界限不是很明显, 如果一个抽象类没有需要的实例字段, 就要声明为接口 内部类Java的内部类分为三种: 内部类(innner class), 匿名类(anonymous class), 静态内部类(static Nested class) 内部类: 内部类与普通类有个最大的不同，就是Inner Class的实例不能单独存在，必须依附于一个Outer Class的实例。同样的, 内部类隐式的持有一个Outer.this的指针, 用来访问外部类的字段 匿名类:匿名类不需要在Outer Class中明确地定义这个Class，而是在方法内部，通过匿名类（Anonymous Class）来定义. 如下面两段代码: 123456789101112131415new Thread(new Runnable { @Override public void run() { //do something }}).start();Queue&lt;String&gt; pq = new PriorityQueue&lt;&gt;(new Comparator&lt;String&gt;() { @Override public int compare(String s1, String s2) { return s1.length() - s2.length(); }}); 这里的 Runnable 和 Comparator 都是接口, 显然接口是不能被实例化的, 这里就是使用了匿名类的方法 静态内部类: 静态内部类很特殊, 他可以不依附于外部的类, 便可以存在, 因此它无法访问到外部类的字段, 但是可以访问到外部类的private静态的字段和方法, 以及间接的使用new构建一个外部类实例. 这是一种破坏封装性的豁免. 静态内部类常用于复杂对象的构造,工具类等等. 以及用来实现单例模式(懒汉式). 123456789101112class Singleton{ /* * fields and methods */ public static Singleton getInstance{ return Handler.INSTANCE; } static class Handler{ final static Singleton INSTANCE = new Singleton(); }} 包(package), Jar, Classpath, 模块(Module) 包 : 包的作用是实现命名空间的功能, 同时包也是default访问级别的访问边界. 通过包, 可以更好的组织类,来避免命名冲突. Jar : 在java中, java程序的正确执行依赖.class能被jvm正确的识别到并且成功执行. 而jar包的作用就是管理分散在各层目录中的.class文件. 所以jar在jvm看来更像是一个目录. 通过ijar包可以灵活的部署代码 classpath: classpath的作用是告诉JVM 应该去哪里寻找程序正确执行所需要的class 模块: 模块则是在包的基础上, 在加上了一层封装, 这样可以控制哪些包可以对外暴露, 即只有export的包才可以访问其public属性, 否则即使是public也无法访问. Java的核心类介绍String, StringBuilder, StringBuffer, StringJoiner: 这些类中, String 是无法修改的, 而 StringBuilder, StringBuffer是可以修改的, 前者是线程不安全而后者是线程安全的, StringJoiner则是用于字符串合并 包装类型 包装类型指的是Integer, Boolean这些类型, 它们是对基本数据类型的包装, 可以被置为null. 而对于包装的类型, 它们会自动发生装箱和拆箱, 这很影响效率. 并且包装类型的比较必须使用equals() JavaBean 名字上理解是咖啡豆, 实际上是一种特殊的类, 它专门为数据传输所设计. 他的所有的字段都是 private , 通过 public的 set和get方法来读写实例字段. 这样的类可以被成为JavaBean. 枚举类 这里和CPP类似, 传统的类中声明静态字段方法来枚举的话, 不具备每个枚举值的合法性. 因此特地的引入了枚举类. 首先Enum是无法被继承的, 然后枚举类编译器会对其值的合法性质做检查. 记录类 记录类是从Java 14之后引入的概念. 记录类的特点是 : 所有的字段都是 final 的, 一旦创建实例之后无法修改任何字段. 并且类的本身也是final的, 无法被继承. Java的异常处理在Java中, 使用异常来表示错误, 并且通过try…catch…来捕获异常. 在java中, 所有的异常都是通过继承Throwable类来实现的.整个异常的结构如下图所示 在上图中, Error是严重的错误, 比如内存耗尽, 栈溢出. 这些问题对于程序来说是无能为力的, 只能在终端查看backtrace的结果 而Exception是运行时候出现的错误, 他可以被捕获并且去处理. 所有的Exception 都必须要被捕获并且去处理 同时, 和异常处理所伴随的是日志, 在java标准库中提供了logging作为日志功能的基本实现. 同样的, 也有一些开源好用的日志库, 比如log4j, slf4j这些日志库. 总而言之, 使用日志和捕获异常是在编写大型项目很好的一个编程习惯. 一定要养成这样的习惯 反射(Reflection)反射是Java很大的一个特性, 区别于CPP(不过听说CPP也要引入反射了…), 反射是Spring中AOP的基石 Class类JVM为每个加载的class创建了对应的Class实例，并在实例中保存了该class的所有信息，包括类名、包名、父类、实现的接口、所有方法、字段等(这些信息也叫做)，因此，如果获取了某个Class实例，我们就可以通过这个Class实例获取到该实例对应的class的所有信息。通过Class实例获取class信息的方法称为反射（Reflection） 每个实例都可以通过使用getClass()的方法来获取自身的Class实例 在使用反射的时候,需要注意的是: Java是动态加载的, 只有在运行时jvm第一次读到这个类才会为这个类添加对应的Class类实例 通过反射访问字段:Class类提供了以下几个方法来获取字段： Field getField(name)：根据字段名获取某个public的field（包括父类） Field getDeclaredField(name)：根据字段名获取当前类的某个field（不包括父类） Field[] getFields()：获取所有public的field（包括父类） Field[] getDeclaredFields()：获取当前类的所有field（不包括父类） 需要注意的是, 如果字段是private的, 表明是受访问权限保护不可修改的. 那么需要使用setAccessible来破坏其封装性 通过反射调用方法:可以通过Class实例获取所有Method信息。Class类提供了以下几个方法来获取Method： Method getMethod(name, Class...)：获取某个public的Method（包括父类） Method getDeclaredMethod(name, Class...)：获取当前类的某个Method（不包括父类） Method[] getMethods()：获取所有public的Method（包括父类） Method[] getDeclaredMethods()：获取当前类的所有Method（不包括父类） 需要注意的是, 如果方法是private的, 那么和字段一样,需要使用setAccessible来破坏其封装性. 调用反射需要使用invoke(Object instance, Object... parameters), 注意, 对于反射调用的非静态方法一定是依赖于实例的,而静态方法则只要传入null作为第一个参数即可 通过反射调用构造方法:同样, 也可以通过Class实例去获取类的构造方法 getConstructor(Class...)：获取某个public的Constructor； getDeclaredConstructor(Class...)：获取某个Constructor； getConstructors()：获取所有public的Constructor； getDeclaredConstructors()：获取所有Constructor。 通过获取的construction对象, 调用其newInstance方法即可按照指定构造函数创造实例 获取继承关系 获取父类的Class : getSuperclass(): 获取某个Class类型的父类的Class实例 获取实现的Interface: getInterfaces(): 获取某个Class类型所实现的所有接口的Class 实例 判断继承关系: 判断一个实例是否是某个类型时，使用instanceof操作符 判断两个Class实例中,有一个向上转型是否成立,使用isAssignableFrom()操作 注解(Annotation)Java 注解是一种 元数据机制，它的作用是 在编译期或运行时向工具或框架提供额外信息，从而实现 编译检查、代码生成、运行时依赖注入/映射、文档生成 等功能。 定义注解 @Tareget:定义Annotation能够被应用于源码的哪些位置: 类, 方法, 字段, 参数等等 @Retention:定义Annotation的生命周期, 仅编译期, 仅Class文件, 运行期 @Repeatable:使用@Repeatable这个元注解可以定义Annotation是否可重复 @Inherited:使用@Inherited定义子类是否可继承父类定义的Annotation 这里给出一个定义注解的实例 1234567@Target(ElementType.TYPE)@Retention(RetentionPolicy.RUNTIME)public @interface Report { int type() default 0; String level() default &quot;info&quot;; String value() default &quot;&quot;;} 处理注解之前提到过, 注解需要在编译期或运行时向工具提供额外信息, 这就需要反射的机制. 因此, Java通过反射来处理注解 Class.getAnnotation(Class) Field.getAnnotation(Class) Method.getAnnotation(Class) Constructor.getAnnotation(Class) 不过, 如果需要使用反射来读取类型, 那么注解的生命周期要选为运行时 泛型(Generics)在Java中, 泛型可以概括为, 通过编写一个模板代码来进行任意类型的适配, 是一种多态的体现. 与CPP中的模板不同, CPP的模板能力更为强大, 它能在编译期展开并且根据传入的类型生成不同的实例. 而在Java中, 编译时会检查泛型的类型安全，但在 编译后的字节码中泛型类型信息会被擦除. 及在JVM看来, List&lt;Integer&gt; 和List&lt;String&gt;其实是同一个类 List(没有类型参数的原始)，只是编译阶段保证你不会把错误的类型放进去。 编写和使用泛型在使用泛型的时候, 必须将T替换为所需要的class类型. 注意, 这里的T只能是引用类型, 因此不能是int这种基本类型. 因为Java泛型的实现基础是类型擦除, 而 int 不用继承 Object类实现. 在编写泛型的时候, 需要注意的是静态方法不能直接引用泛型类型T, 必须定义其它的类型. 也很好理解, 静态的方法和类是否实例化是无关的 类型擦除类型擦出是泛型的底层实现, 其实JVM对泛型一无所知, 因为在编译期间, 编译器通过类型擦除将所有的泛型安全的转化为别的类型. 比如下面是一段泛型代码: 123456789101112class Box&lt;T&gt; { T value;}class Box&lt;T extends Number&gt; { T value;}public static &lt;T extends Comparable&lt;T&gt;&gt; T min(T a, T b) { return a.compareTo(b) &lt;= 0 ? a : b;} 而在经过类型擦除之后, 结果是: 1234567891011class Box { Object value;}class Box { Number value;}public static Comparable min(Comparable a, Comparable b){ return a.compareTo(b) &lt;= 0 ? a : b;} 显然, 下面这段代码在JVM看来是没有任何泛型的信息 类型擦除的影响 运行时没有泛型信息: 123List&lt;String&gt; list1 = new ArrayList&lt;&gt;();List&lt;Integer&gt; list2 = new ArrayList&lt;&gt;();System.out.println(list1.getClass() == list2.getClass()); // true 不能直接创建泛型数组: 运行时JVM是无法区分 List&lt;String&gt; 和 List&lt;Integer&gt; 的数组 1List&lt;String&gt;[] array = new List&lt;String&gt;[10]; // 编译错误 不能用泛型做instanceof判断 12if (obj instanceof List&lt;String&gt;) { } // 编译错误if (obj instanceof List&lt;?&gt;) { } // 编译通过 反射需要用Type来获取精确的泛型消息 1234List&lt;String&gt; list1 = new ArrayList&lt;&gt;();Class&lt;?&gt; cls = list1.getClass(); // 得到的是ArrayList类型Field f = YourClass.class.getDeclaredField(&quot;list1&quot;); //YourClass就是包含list1这个字段的类Type cls_generic = f.getGenericType(); // 拿到 List&lt;String&gt; PECS原则何时使用extends，何时使用super？为了便于记忆,因此产生了PECS原则：Producer Extends Consumer Super。即：如果需要返回T，它是生产者（Producer），要使用extends通配符；如果需要写入T，它是消费者（Consumer），要使用super通配符 集合(Collections)Java 的集合（Collection）是对一组对象进行存储、操作的容器类库，位于 java.util 包中。它们主要用来 代替数组，解决数组固定大小、操作不灵活的问题。 集合分为三大类： Collection 接口（存放单个元素） List：有序、可重复 Set：无序、不可重复 Queue / Deque：队列/双端队列 Map 接口（存放键值对 key-value） 不能直接继承 Collection，但也属于集合框架的一部分 工具类 Collections：操作集合的工具类（排序、搜索、线程安全化等） Arrays：操作数组的工具类（与集合转换） 下面是集合的大分类 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253Iterable└─ Collection ├─ AbstractCollection ├─ List │ ├─ AbstractList │ │ └─ AbstractSequentialList │ ├─ ArrayList │ ├─ LinkedList (也实现 Deque) │ ├─ Vector (遗留, 同步) │ │ └─ Stack (遗留, LIFO) │ └─ CopyOnWriteArrayList (并发, 读多写少) │ ├─ Set │ ├─ AbstractSet │ ├─ HashSet │ │ └─ LinkedHashSet │ ├─ TreeSet (NavigableSet/SortedSet) │ └─ EnumSet (抽象父类+具体子类, 位图) │ └─ Queue ├─ AbstractQueue ├─ Deque (接口) │ ├─ ArrayDeque │ └─ LinkedList ├─ PriorityQueue (最小堆) │ ├─ BlockingQueue (接口, 并发) │ ├─ ArrayBlockingQueue │ ├─ LinkedBlockingQueue │ ├─ PriorityBlockingQueue │ ├─ DelayQueue │ ├─ SynchronousQueue │ └─ LinkedTransferQueue (也实现 TransferQueue) │ └─ BlockingDeque (接口, 并发; 也继承 Deque/BlockingQueue) └─ LinkedBlockingDequeMap (不继承 Collection)├─ AbstractMap├─ HashMap│ └─ LinkedHashMap├─ TreeMap (NavigableMap/SortedMap; 红黑树)├─ EnumMap (键为枚举)├─ WeakHashMap (键弱引用, 缓存)├─ IdentityHashMap (键用==比较)├─ Hashtable (遗留, 同步)│ └─ Properties (键/值为 String, 配置)│├─ ConcurrentMap (接口, 并发)│ └─ ConcurrentHashMap│└─ ConcurrentNavigableMap (接口, 并发+可导航) └─ ConcurrentSkipListMap 需要注意的是,在使用这些collections的时候, 对放入集合的元素有着如下的要求: 哈希类集合（HashMap/HashSet 等）依赖 equals 和 hashCode 有序/排序集合（TreeMap/TreeSet 等）依赖 Comparable 或 Comparator","link":"/2026/01/04/java/Java%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/"},{"title":"k8s的服务与负载均衡","text":"Service的定义在k8s中, Service是一种kuberenets对象, 它的作用是将运行在一个或一组 Pod 上的网络应用程序公开为网络服务的方法 端口在service中,主要有三种端口: port ：Service 对外暴露的端口（集群内部访问用的 ClusterIP:port，或 NodePort/LoadBalancer 的端口）。 targetPort ：Pod 容器内实际监听的端口。(target端口如果不写就是和port一个端口) nodePort ：如果 Service 类型是 NodePort/LoadBalancer，会在宿主机节点开放一个固定端口（30000–32767 默认范围）。 selector在service中, 既然要组织一组pod来提供服务, 那么必须要提供一种表示来匹配pod, 那么这里就是使用了selector. 12345678910111213apiVersion: v1kind: Servicemetadata: name: my-nginx labels: run: my-nginxspec: ports: - port: 80 protocol: TCP selector: run: my-nginx 如上述代码就是一个简单的service定义, 里面通过run:my-nginx来匹配符合标签的pod, 来加入service之中 endpointslice在定义service的时候, 如果使用了selector, 那么会自动生成EndpointSlice对象, 每个 EndpointSlice 里包含若干个 Pod/Endpoint 的信息，例如： 地址 (addresses) → Pod 的 IP 端口 (ports) → Pod 容器的端口（对应 Service 的 targetPort） 条件 (conditions) → Pod 是否 Ready、Serving、Terminating 等 拓扑信息 (topology) → 节点、区域等信息，方便拓扑感知调度 服务类型Kubernetes Service 类型允许指定你所需要的 Service 类型。 可用的 type 值及其行为有： ClusterIP通过集群的内部 IP 公开 Service，选择该值时 Service 只能够在集群内部访问。这也是没有为 Service 显式指定 type 时使用的默认值。可以使用 Ingress或者 Gateway API 向公共互联网公开服务。 NodePort通过每个节点上的 IP 和静态端口（NodePort）公开 Service。为了让 Service 可通过节点端口访问，Kubernetes 会为 Service 配置集群 IP 地址，相当于你请求了 type: ClusterIP 的 Service。 LoadBalancer使用云平台的负载均衡器向外部公开 Service。Kubernetes 不直接提供负载均衡组件；你必须将 Kubernetes 集群与云平台集成, 比如阿里云 ExternalName将服务映射到 externalName 字段的内容（例如，映射到主机名 api.foo.bar.example）。该映射将集群的 DNS 服务器配置为返回具有该外部主机名值的 CNAME 记录。集群不会为之创建任何类型代理。 service的使用在实际使用service的时候, service并不是实际存在的实体, 比如pod这种, 而是一种抽象的概念. 如下图是一个k8s网络的示意图 Pod的创建controller-manager （比如 DeploymentController、ReplicaSetController）会监听 apiserver 中 Pod/ReplicaSet/Deployment 的变化, 来动态的管理pod的数量. 分别是几种情况: kubectl发送的直接创建pod请求: 首先api-service 会作合法性判断, 通过后会第一时间把对象存入etcd scheduler （kube-scheduler）通过 watch 监听 apiserver 中的 Pending Pod 。会根据调度策略（资源可用性、亲和性/反亲和性、污点和容忍度等）为 Pod 选定一个合适的 Node。选好后 scheduler 向 apiserver 发送 绑定请求 ，把 Pod.spec.nodeName 设置为选中的节点。apiserver 更新 etcd，Pod 状态还是 Pending，但已经绑定到某个 Node。 目标节点上的 kubelet 会 watch apiserver 上自己节点的 Pod 对象, 发现有一个新 Pod 分配到本节点，于是开始创建流程. 包括创建puase容器, 调用CNI分配网络,拉取镜像,启动业务容器. 在完成这些过程中, kubelet会定期向api-service汇报自己的状态 api-service会接受来自 kubelet 报告的状态, 并且更新etcd. 同时control-manager中的endpoints-controller会在service创建, pod状态变化时候扫描集群里所有 Pod, 来做标签匹配. 满足所有条件的 Pod → 被写入 EndpointSlice pod的创建被包裹在deployment或者statefulset之中: 首先api-service 会作合法性判断, 通过后会第一时间把deployment或者statefulset对象存入etcd 这时候controller-manager中的deployment-controller或者statefulset-controller会监听apiserver中deployment或者statefulset的变化, 两者通常会实现一个ReplicaSet。而ReplicaSetController 监听 ReplicaSet 的变化后, 也会触发相应的Pod创建流程, 之后的流程就走到了scheduler,kubelet等组件. Pod丢失或者宕机: controller-manager 发定期访问api-service来检查pod状态, 一旦发生确实, 就进入创建的过程. 详细见上面第二步 Service的网络:","link":"/2026/01/04/k8s/k8s%E7%9A%84%E6%9C%8D%E5%8A%A1%E4%B8%8E%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1/"},{"title":"Linux中的文件系统","text":"Linux文件系统的设计初衷Linux操作系统中，有个很显著的特点就是：所有的IO对象都被抽象为文件，如果要进行IO操作，那么则通过调用Linux的虚拟文件系统提供的`open` 、`write `、`read`一系列接口，来到具体的IO块设备中使用设备驱动来实现。总而言之，就是Linux提供了一个内核层的软件，即虚拟文件系统，来提供所有的IO操作。 Linux虚拟文件系统支持的文件系统磁盘文件系统磁盘文件系统是用来管理本地磁盘的存储空间，或者其他可以起到磁盘作用的存储设备(U盘)。 Linux可以很好的支持对各种类型的文件系统的磁盘的访问，比如Linux使用的Ex4（第四拓展文件系统），Windows使用的NTFS以及 UNIX家族的各种操作系统 网络文件系统网络文件系统是一种通过 VFS 把远程存储挂载到本地目录树的技术，本质是“文件系统驱动 + 网络协议”，它让应用像操作本地文件一样去读写远程数据。常见的RPC技术就是访问远程的网络文件系统的方式 特殊文件系统特殊文件系统是 Linux 内核中不依赖磁盘的文件系统实现，它通过 VFS 提供统一的文件操作接口，但数据直接来自内存或内核数据结构，常用于系统信息、配置接口和临时存储。 常见的特殊文件系统介绍： 名称 挂载点 功能 procfs /proc 提供进程、内核状态信息（/proc/cpuinfo、/proc/meminfo） sysfs /sys 反映内核对象（设备、驱动、总线等）的层次结构 tmpfs 任意挂载点（常见 /run、/dev/shm） 内存中的临时存储，可当 RAM Disk 用 devtmpfs /dev 自动创建设备节点 sockfs 内核内部使用 为 socket 提供 VFS 接口 pipefs 内核内部使用 管道/匿名管道实现 configfs /sys/kernel/config 允许用户空间创建和配置内核对象 虚拟文件系统中的数据结构superblock超级块是存放在磁盘上文件系统开头的一小块（通常在引导块之后），同时内存中也会有一份副本用于运行时访问。它是文件系统的“元信息（metadata）”，描述了整个文件系统的布局和关键参数。内核在挂载（mount）文件系统时，会读取超级块，将里面的参数加载到内存，用来指导后续的目录、inode、数据块的管理。 superblock 的主要内容： 文件系统基本信息 魔数（magic number）：标识文件系统类型，防止挂载错误的分区。 文件系统大小：总共有多少块（blocks）。 block 大小（一般 1KB、2KB、4KB）。 inode 总数。 文件系统布局信息 inode 表起始位置、数量。 数据块区域起始位置、数量。 位图（block bitmap / inode bitmap）位置。 一致性与日志相关信息 log 区域（用于 journaling 文件系统，比如 ext3/ext4 的 journal）。 最近挂载时间、写入时间。 是否被 cleanly unmount。 运行时信息（仅内存态 superblock 保存） 挂载点引用计数。 指向 inode 缓存、dentry 缓存的指针。 同步/锁机制。 简单地说，superblock 就是文件系统的“元信息控制中心”，它告诉操作系统如何解释磁盘上的数据，确保文件系统能被正确挂载、管理和维护。 索引节点对象（inode）inode是文件系统中用来描述一个文件的 元数据结构 。每一个文件（普通文件、目录、符号链接、设备文件等）都有一个 inode。inode 不存储文件名 ，而是存储文件的属性和指向数据块的指针。 inode 中包含的主要信息 文件属性（metadata） 文件类型（普通文件、目录、符号链接、字符设备、块设备…） 权限（rwx） 所属用户 ID (UID)、组 ID (GID) 文件大小（bytes） 时间戳（atime/mtime/ctime） 链接计数（多少个目录项指向该 inode） 数据块位置 直接块指针 （direct blocks）：直接指向数据块。 间接块指针 （indirect blocks）：指向一个块，这个块里再存放更多数据块地址。 二级/三级间接块指针 （large file 才需要）。 文件对象（file）在 Linux 内核中，文件对象（file object） 就是 struct file 结构体。它并不是“磁盘上的实体”，而是 进程在打开文件时，内核为该打开实例创建的内存对象 。可以说，文件对象是站在进程的角度所设计出来的，它表示进程打开该文件的一次实例（动态的，运行时信息） file中包含的主要信息 路径 &amp; inode f_path：指向 dentry（目录项）和挂载点，用于路径解析 f_inode：快速访问 inode（文件的元数据） 操作方法 f_op：指向一组函数指针（struct file_operations），定义了 read/write/ioctl/mmap 等操作的具体实现 不同文件系统会注册自己的操作集，比如 ext4、procfs、sockfs 运行时状态 f_flags：打开时传入的 flag（如 O_APPEND、O_NONBLOCK） f_mode：读写模式（FMODE_READ, FMODE_WRITE） f_pos：文件读写指针（当前偏移量） 引用计数和同步 f_count：多少个 fd 指向这个 file 对象（dup、fork 时会增加） f_lock：保护并发访问 缓存和私有数据 f_mapping：指向页缓存，用于文件和内存的映射 private_data：给具体文件系统或设备驱动使用（例如 socket 就会存 socket 的内部结构体） 有时候很容易混淆inode和file，简而言之，inode 描述文件是什么，file 描述“我这次打开它怎么用” 目录项对象（dentry）dentry（directory entry，目录项对象） 是 VFS 用来表示 路径名的一部分（目录项） 的内存对象。它的作用是把 文件名 和 inode 关联起来。需要注意的是：磁盘上存储目录项地方是目录文件的数据块，内存中对应的运行时抽象就是 dentry。 dentry中包含的主要信息 名字信息 d_name：文件名（含长度和哈希值，便于快速查找） d_parent：指向父目录的 dentry（形成目录树） 层级关系 d_subdirs：子目录链表 支持在内存里维护完整的目录树结构 关联文件系统对象 d_inode：指向对应的 inode d_sb：指向所属的超级块 缓存与引用 d_hash：放入哈希表（dcache）中，用于快速查找路径 d_count：引用计数（多少个进程/内核对象正在用这个 dentry） d_flags：标记 dentry 状态（是否有效、是否负向等） 目录项缓存(dentry cache ，简称 dcache) dcache是 Linux VFS（虚拟文件系统）中非常重要的一部分。它的主要作用是： 加速路径名解析，避免重复的磁盘访问和 inode 查找 。 目录项缓存的作用 路径名到 inode 的快速映射 dentry 保存了目录名（比如 docs）与其对应 inode 的关系。 下次访问相同路径时可以直接从缓存获取 inode，而不用重新从磁盘读取。 加速路径解析 路径解析是逐级查找的，dcache 缓存了父目录到子目录/文件的映射，避免重复查找。 例如多次访问 /home/user/docs/，后续只需查缓存。 支持硬链接和别名 dentry 允许同一个 inode 被多个不同的目录项引用，帮助 VFS 处理硬链接。 减少磁盘 I/O 频繁打开、关闭文件时，通常 inode 和目录项都已经在缓存中，不需要再次读磁盘。 配合 inode cache dentry 只缓存 “路径 → inode 的映射”，而 inode cache 保存 “inode 号 → inode 对象”。 两者结合起来，VFS 可以几乎不访问磁盘就完成大部分路径解析。 注意,这里dentry cache和inode cache都是保存在内存之中的 文件系统的路径名查找这里以进程打开一个位于磁盘上的文件为例子 open(filename, flags, mode) 由于open要使用到系统的资源,因此需要使用SYS_OPEN, 陷入系统调用之后. 此时内核会去检查 dentrycache 查看有没有文件名对于的inode.如果找到了,那么根据该inode以及flags,mode,绑定对应inode中操作的函数指针,创建一个file类型,挂载在进程的file_struct中,同时,给该file对象分配一个fd,并且在fd_table中添加fd到file的映射,以根据文件描述符直接定位到制定的file. 如果没有找到,那么会依据目录名通过VFS中文件名解析的方式去查找,来返回对应文件名的inode,找到之后,在 dentrycache中添加这对映射关系,然后重复上面更新到进程的步骤.最后将对应的文件描述符返回.","link":"/2026/01/04/os/Linux%E4%B8%AD%E7%9A%84%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/"},{"title":"Linux的进程","text":"进程的地址空间处于隔离性的要求，每个进程所使用的地址为虚拟地址（`VA`），其中地址为 `0x0000000000000000` ~ `0xffffffffffffffff`（合理取64位计算机为例）。进程的地址空间分为用户态地址和内核态地址，其中用户态和内核态的地址范围如下。 地址范围 所属 描述 0x0000000000000000 ~ 0x00007fffffffffff 用户态 每个进程私有，可访问 0xffff800000000000 ~ 0xffffffffffffffff 内核态 全系统共享，只有内核代码可访问 用户态的地址空间分布 我们可以将一个用户态进程的地址空间划分如下（从低地址到高地址） 12345678910111213141516+-------------------------+| 用户栈（Stack） | ← 通常从高地址向低地址增长+-------------------------+| mmap 区域（共享库、匿名映射） |+-------------------------+| 堆（Heap） | ← 从 brk 指向的起始地址向上增长+-------------------------+| BSS 段（未初始化全局/静态变量）|+-------------------------+| 数据段（Data） | ← 已初始化的全局/静态变量+-------------------------+| 代码段（Text） | ← 程序指令+-------------------------+| 空洞 / 对齐区域 |+-------------------------+| NULL | ← 通常地址空间的最低部分（保护访问） 用户态地址空间各段的解释： 区域 说明 代码段（.text） 存储可执行代码（只读、可执行） 数据段（.data） 存储已初始化的全局变量或静态变量（可读写） BSS段（.bss） 存储未初始化的全局变量或静态变量（占虚拟空间，运行时初始化为0） 堆（heap） 由 malloc() 等函数动态分配内存，向高地址扩展，由 brk() 或 mmap() 控制 mmap 映射区 用于映射共享库（如 libc.so）、匿名内存（如 mmap(NULL,...)）等，地址位置灵活（同时也是用户态线程栈的保存位置） 用户栈（stack） 默认大小通常为 8MB（可调），由内核在启动线程时创建，从高地址向低地址扩展 VDSO / vsyscall 提供某些用户态可调用的内核函数（如 gettimeofday()），提升性能 NULL 保留页 地址空间的最低页通常不映射，用于捕获非法指针访问（如 NULL dereference） 内核态的地址空间分布，其中内核栈和per-CPU，虽然分配在全局地址空间，但是其内容不共享，为任务私有 12345678910111213141516171819202122232425262728用户空间（每进程私有）:0x0000_0000_0000_0000 ...0x0000_7fff_ffff_ffff ← 用户空间结束-------------------- 以下为所有进程全局共享的内核空间 --------------------内核空间（全局共享）:0xffff_8000_0000_0000 ← 内核空间起始 |- 直接映射区（physmap, linear mapping） | 0xffff_8000_0000_0000 ~ 0xffff_c7ff_ffff_ffff |- vmemmap 区（struct page 映射区，页框管理的数据结构） | 0xffff_ea00_0000_0000 ~ 0xffff_eeff_ffff_ffff |- vmalloc 区（动态虚拟内存分配，用于内存的动态分配） | 0xffff_c800_0000_0000 ~ 0xffff_dfff_ffff_ffff |- 模块映射区 | 0xffff_e000_0000_0000 ~ 0xffff_efff_ffff_ffff |- ioremap 区（PCI/IO设备动态映射，实际位于vmalloc子区） |- 内核镜像区（.text/.data/.bss, KASLR后地址随机） | 0xffffffff_80000000 ~ 0xffffffff_ffffffff |- fixmap 区 | 0xffff_fff0_0000_0000 ~ 0xffff_fff0_0fff_ffff |- vsyscall 区（已废弃，仅保留仿真，现在已经被Visual Dynamic Share Object替代，来提供无需发起系统调用的系统调用） | 0xffff_ffff_fffc_0000 ~ 0xffff_ffff_fffd_0000 |- EFI/ACPI保留区（部分机器有） | 0xffff_ffe0_0000_0000 ~ 0xffff_ffff_ffff_ffff |- 其它保留或架构相关区块0xffff_ffff_ffff_ffff ← 虚拟地址上限 内核态各段的解释 区域 描述 直接映射物理内存区域（Direct mapping） 将所有物理内存直接线性映射进虚拟地址空间，常用宏 __va() 与 __pa() 转换 vmalloc 区 vmalloc() 申请的非连续物理页区域，适合分配大对象。实现虚拟地址到离散的物理地址的映射 模块映射区 加载的内核模块、驱动代码位置 内核代码段 &amp; 数据段 内核自身代码与静态数据区域（内核本身的代码，不可以修改） fixmap 区 用于映射特定设备地址或中断向量表，具有固定虚拟地址 ioremap 映射区 IO 设备的 MMIO 寄存器映射到的虚拟地址 进程的实体表示在Linux内核中，进程的实体表示是使用 task_struct这一数据结构来表示的，在Linux中，Linux 采用 1:1 的线程实现模型，每个用户态线程对应一个内核态线程，内核通过 task_struct 来统一表示进程和线程，线程因此也被称作“轻量级进程”（Lightweight Process, LWP） 。轻量级进程会共享主进程的 mm_struct，fs_struct，signal_struct等等这些内容，他们各自的 task_struct是各不相同的。 下面是一个 task_struct的基本结构： 1234567891011task_struct├── 基本标识：pid, tgid, comm, state├── 调度信息：prio, se, policy├── 内存信息：mm, active_mm├── 线程组信息：group_leader, thread_group├── 父子关系：real_parent, children├── 信号处理：signal, sighand├── 文件系统：fs, files├── 权限/命名空间：cred, nsproxy├── 调试/审计：audit_context, start_time├── 架构相关：thread_struct 基本标识：pid是进程的唯一标识，而tgid则是所在线程组组长的pid（主线程的pid） 调度信息：prio是优先级，se则是实际的调度实体，而policy则是调度的策略 内存信息：mm用户态内存描述符，是一个指向mm_struct的指针，active_mm则是线程当前使用的mm_struct，这是因为内核线程会借用其他进程的，VMA是虚拟内存区域，用来描述进程虚拟地址空间中一段连续虚拟内存区域的数据结构，可以管理进程的虚拟地址空间到物理地址的映射关系，采用了红黑树的数据结构来管理。 线程组信息：group_leader指向线程组的组长，thread_group则是线程组的内部链表 信号处理：signal是指向 signal_struct的，线程组共享; sighand则是指向sighand_struct（信号处理函数表） 文件系统：files指向files_struct，表明打开文件表;而fs则是维护文件系统的信息 进程的状态 从操作系统的宏观角度： 创建：正在创建进程，还未就绪 就绪：已准备好、等待被调度上 CPU 运行：正在 CPU 上执行 阻塞：等待 I/O 或资源，不能运行 终止：执行完毕或被终止，等待资源释放 从Linux内核的具体实现角度： TASK_RUNNING：可运行，可能在 CPU 上，也可能在 runqueue 中等待 TASK_INTERRUPTIBLE：可被信号打断的睡眠，常见于等待资源、I/O TASK_UNINTERRUPTIBLE：不可被信号打断的睡眠，如 I/O 阻塞 EXIT_ZOMBIE：已退出，变成僵尸进程，等待父进程回收 __TASK_STOPPED：被 SIGSTOP 暂停 __TASK_TRACED：被调试器（如 gdb）暂停、单步等状态 进程的创建在Linux中，进程的创建主要有，fork，vfork以及clone三种方式来创建进程。 系统调用 本质功能 地址空间复制 子进程执行时父进程状态 适用场景 fork() 创建一个子进程，复制当前进程 写时复制（Copy-on-write） 父子进程并发执行 一般进程创建 vfork() 类似 fork，但不复制地址空间 共享地址空间（临时） 父进程被阻塞直到子进程 exec() 或 _exit() 创建后立即执行 exec clone() 最灵活的创建机制，用于创建线程 可选共享（通过标志控制） 父子可以并发执行 多线程、容器、线程池 fork() 和 vfork() 最终都会调用 clone()，区别在于传入的参数不同；所有这三者最终调用内核中的 copy_process() 函数来构建新的 task_struct 进程的切换简而言之，进程的切换就是保留当前进程的上下文，然后加载目标进程的上下文。 从更深入的角度解释则是： 1234567891011[当前CPU]↓保存 current-&gt;thread_struct 中的寄存器/堆栈↓切换 mm_struct（地址空间）↓current = next↓恢复 next-&gt;thread_struct 中的寄存器/堆栈↓ret 恢复程序计数器，跳转回用户/内核执行 进程的回收在前面的介绍中已经知道，所有用户态进程都由 init /systemd 派生，所有内核线程都由 kthreadd 创建。因此，这里进程的回收将从子进程的角度展开介绍。 当子进程调用 exit() 正常退出，或因异常（如段错误）终止时，会进入内核的 do_exit() 函数。 在 do_exit() 中，内核会关闭打开的文件描述符，调用 exit_mm() 释放虚拟内存资源（仅限拥有 mm_struct 的用户进程），释放信号处理器资源，同时将进程状态设置为 EXIT_ZOMBIE。 此后，内核会向父进程发送 SIGCHLD 信号，通知其可以回收当前子进程的退出状态。如果父进程已经提前退出，子进程会被重新挂载到 init（PID 1）进程下，由其负责后续回收。 最后，do_exit() 调用 schedule() 永久让出 CPU，进程不再被调度。 父进程随后通过 wait() 或 waitpid() 等系统调用获取子进程退出信息，并触发 release_task() 对其进行彻底清理，包括释放其 task_struct、内核栈、pid 表项等内核资源，从而完成整个进程回收流程。 进程的调度Linux的调度是基于分时技术的，CPU的时间被分为片，每个进程的执行都是按照片为单位去执行。在进程调度的时候，调度的优先级是基于静态优先级和动态优先级结合的方法来得出的。 静态优先级：在进程被创建的时候分配的优先级，他是不可以改变的 动态优先级：调度器在运行过程中根据进程行为动态调整的优先级值，通常是通过CFS（complete Fair Schedule）完全公平调度器来通过 vcputime来等效动态优先级 进程和线程在内核视角的区别在 Linux 内核中，进程（process）和线程（thread）都由 task_struct 统一表示，并由 Slab 分配器分配内存。它们都是调度器中的可调度实体（schedulable entity），因此每个任务都有唯一的 PID 。 线程通常由 clone() 系统调用创建，不同的 CLONE_* 标志决定了它与父任务共享哪些资源。 PID 与 TGID 每个任务（无论进程还是线程）都有唯一的 PID。 主线程：PID = TGID（线程组 ID） 其他线程：PID ≠ TGID，但 TGID 等于主线程的 PID。 栈空间 每个任务有独立的 内核栈 （内核态使用，固定大小） 每个任务有独立的 用户栈 ；线程的用户栈分配在父进程的 mmap 区域内。 资源共享 进程：拥有独立的 mm_struct（虚拟内存）、files_struct（文件描述符表）、fs_struct（文件系统信息）、sighand_struct（信号处理表）等。 线程：通常共享这些资源（取决于 clone() 的标志，如 CLONE_VM、CLONE_FILES、CLONE_FS、CLONE_SIGHAND 等）。 调度 内核调度器并不区分进程或线程，都是以 task_struct 作为调度单位。 区别主要体现在地址空间是否独立，以及资源是否共享。","link":"/2026/01/04/os/Linux%E4%B8%AD%E7%9A%84%E8%BF%9B%E7%A8%8B/"},{"title":"Linux的内存","text":"写在前面，本文所讨论的是基于 x86_64架构上的 Linux。 内存管理物理内存划分 什么是 UMA？什么是 NUMA？ UMA（Uniform Memory Access，统一内存访问）是一种内存体系结构，指所有CPU访问主存的速度是一致的。在计算机发展的早期，主板上通常设有北桥（Northbridge）芯片，负责连接CPU与内存、显卡等高速设备，实现了CPU对内存的统一高效访问。随着DMA技术和存储设备IO速度的发展，北桥的功能逐步被集成进CPU，现代主板上已经没有独立的北桥芯片。绝大多数个人台式机和笔记本仍然采用UMA的内存访问方式。 NUMA（Non-Uniform Memory Access，非统一内存访问）是一种内存体系结构，值所有的CPU访问主存的速度是不一致的，常见于大型服务器，有多个CPU，总线和巨大的主存。 什么是内存节点？ 在 NUMA（非统一内存访问）架构下，每个CPU（或CPU组）都被分配一块本地内存（NUMA节点），CPU访问本地节点内存时速度最快，延迟最低；而访问其他节点的内存时，需要通过跨节点总线（如QPI、Infinity Fabric等）进行数据传输，速度会有所降低。为了优化性能，操作系统通常会尽量将进程和其使用的内存分配在同一个节点上。相比之下，UMA（统一内存访问）架构下，所有CPU共享同一个内存节点，访问速度和延迟完全一致，没有本地和远程之分。 什么是内存区域？ 这里取64位为例：截取部分Linux内核源代码如下 1234567891011121314151617enum zone_type {#ifdef CONFIG_ZONE_DMA ZONE_DMA,#endif#ifdef CONFIG_ZONE_DMA32 ZONE_DMA32,#endif ZONE_NORMAL,#ifdef CONFIG_HIGHMEM ZONE_HIGHMEM,#endif ZONE_MOVABLE,#ifdef CONFIG_ZONE_DEVICE ZONE_DEVICE,#endif __MAX_NR_ZONES}; 从代码可知，内存区域至少有 ZONE_DMA32，ZONE_NORMAL和 ZONE_MOVABLE ZONE_DMA32:用于外部IO设备的高速读写内存，通常在前4G内存 ZONE_NORMAL:用于常规的内存使用 ZONE_MOVABLE:主要用于存放可迁移页，方便内存碎片整理、支持大页分配和内存热插拔 什么是内存页面 物理内存页面也叫做页帧。物理内存从开始起每4K、4K的，构成一个个页帧，这些页帧的编号依次是0、1、2、3……。每个页帧的真实物理地址是页帧号乘以页帧的大小。页帧是物理内存分配的最小单元，大小为固定的4KB 物理内存分配 首先是Buddy System，Buddy System既是直接的内存分配接口，也是所有其它内存分配器的底层分配器。伙伴系统的基本管理单位是区域，最小分配粒度是页面。因为伙伴系统是建立在物理内存的三级区划上的，所以最小分配粒度是页面，不能比页面再小了。基本管理单位是区域，是因为每个区域的内存都有特殊的用途或者用法，不能随便混用，所以不能用节点作为基本管理单位。伙伴系统并不是直接管理一个个页帧的，而是把页帧组成页块(pageblock)来管理，页块是由连续的2^n^个页帧组成，n叫做这个页块的阶，n的范围是0到10。而且2^n^个页帧还有对齐的要求，首页帧的页帧号(pfn)必须能除尽2^n^，比如3阶页块的首页帧(pfn)必须除以8(2^3^)能除尽，10阶页块的首页帧必须除以1024(2^10^)能除尽。0阶页块只包含一个页帧，任意一个页帧都可以构成一个0阶页块，而且符合对齐要求。 Slab Allocator slab allocator负责管理 slab cache中的内存。在 slab cache 中有多个 slab来存储不同的对象。每个slab对应着从主存中分割来的内存块。其中，内存块按照slab要存储的对象大小提前切割好。这样设计将内存分层和对象池相切割开，为内核小对象的高效分配（开销小，且不存在内存碎片）和回收提供了强大支持 1234567891011[slab cache]（对象类型专属池-&gt; inode, dentry, mm_struct这些使用很频繁的数据结构） ├─ [slab 1]（一大块内存，分割成若干对象块） │ ├─ object 1 │ ├─ object 2 │ └─ ... ├─ [slab 2] │ ├─ object 1 │ └─ ... └─ [slab 3] ├─ object 1 └─ ... kmalloc 是 Linux 内核为内核代码提供的高效小对象内存分配API，其内部实现基于 slab allocator。内核为不同大小的常用对象维护专用 slab cache，kmalloc 会自动选择合适的 slab cache，并从中快速分配对象。这使得内核在进行频繁的小块内存分配和释放时，能获得极高的性能和较低的碎片率。 vmalloc：vmalloc则是在内核需要使用大块内存的时候，但是物理内存碎片较多无法提供，这里就会使用vmalloc来将这些物理内存碎片整合起来，这样内核看起来是连续的虚拟地址，但是实际的物理地址不是连续的。使用vmalloc可以灵活的应对碎片，充分利用内存资源 内存地址众所周知，在计算机实际运行的时候，物理地址(PA)是唯一。CPU等资源的数量是固定的，而进程却可以有很多，这就导致了直接访问物理地址这一方式，不仅很复杂，而且安全性差，且难以对内存进行管理。因此引入了逻辑地址即虚拟地址(VA),所有的进程访问的地址都是VA，在通过 MMU（内存管理单元，负责地址转化的实际物理电路）进行从 VA到 PA的映射。 逻辑地址的组成由于技术的发展，在比较早的时期，Linux是通过逻辑地址到线性地址再到物理地址的转化。其中结合了段寻址和页寻址，而现在段寻址的方式已经被基本遗弃，更多的是直接使用页寻址的方式，通过四级页表的方式从逻辑地址到物理地址的转化。并且保存了对LDT(local description table)和 GDT(global description table)的支持，当对应的字段有效时，才使用段寻址的方式去查询。因此本文着重介绍使用页寻址的方式。 进程的所使用的地址空间就是用虚拟地址来表示的，同样的进程的地址空间被划分为了用户态虚拟地址和内核态虚拟地址。这部分的内容会在Linux的进程中有更详细的介绍。 硬件中的分页现代分页的最小页表是4KB的大小，当然也会有一些大页（2MB），超大页（1GB）的出现，不过这些大页也都是大页和超大页是通过页表的上层（PD、PDPT）直接映射大块连续物理内存来实现的，并且管理方式有些不同。 同时，必须强调的一点是，现代CPU是无法直接访问内存的，而是通过利用局部性原理，使用多级缓存的设计来保证高速访问，因此根据最终转换的PA，去高速缓存中读取数据（即使发生缓存不命中，也会从内存中读入数据到高速缓存中）。为了叙述简便，后续我们仍使用“访问内存”这一表达，代表的是通过物理地址最终完成的数据访问过程，不论数据是否实际命中 cache。 Linux中的分页现在的Linux采用的是4级分页模型，分别是页全局目录，页上级目录，页中间目录，页表。缩写分别为：PGD，PUD，PMD，PT。通过这四级别的映射之后，得到最终的 PTE，最后用 PTE的帧地址加上虚拟地址的偏移得到最终的 PA。每次从VA到PA的转化，首先要依据 CR3寄存器中的页全局地址，和VA前面的字段，按照上述规则去计算得到最终的PA。 TLB（Translation Lookaside Buffer）TLB，即快表，是一块保存在 MMU中的高速缓存区，用来直接保存VA到PA的映射，从而不用去多级查找，以此来提高效率。（这里也是利用了局部性原理），不过要注意区分的是，TLB不是保存在 Cache中的，它是保存在 MMU中独立的高速缓存区。因此实际的内存访问，是首先在 TLB中访问，如果没有找到对应项，再去使用多级页表查询的方式去访问，同时更新 TLB。 最终的内存访问方式结合上述机制，可以梳理出 Linux 在x86_64 架构下完整的一次内存访问过程。假设当前 CPU 执行一个访问内存的指令（如读取变量、访问数组等），它首先会提供一个 虚拟地址 VA。这段地址会依次经历以下步骤，最终转换为物理地址并完成访问： TLB 查询：CPU 首先将 VA 提交给 MMU，MMU 会在 TLB 中查找是否存在该虚拟页的映射（即页帧地址）。如果查找命中（称为 TLB hit），则立即得到物理页帧号，再与 VA 的页内偏移合并，得到最终的物理地址。 页表查找（TLB miss）：若 TLB 中未命中（TLB miss），则 MMU 会从 CR3 寄存器中获取当前活动页表的基地址，按虚拟地址的高位字段，逐级遍历页表结构（PGD → PUD → PMD → PT），最终得到 PTE 中的物理页帧地址。 更新 TLB：一旦找到有效的页表项，MMU 会将该 VA → PA 的映射（准确说是PA所在的页表的帧地址）插入到 TLB 中，以便未来的访问能更快命中。 访问 Cache / 内存： 使用得到的物理地址，CPU 向 Cache 系统发起数据访问请求； 若 Cache 命中，则数据直接来自 L1/L2/L3 缓存； 若 Cache 不命中（Cache miss），则从主存（DRAM）中加载数据到缓存行，再由 CPU 使用。 完成数据访问：数据被加载到寄存器或被用于指令执行，整个访问过程完成。 这个过程中，TLB 和 Cache 分别负责加速“地址转换”与“数据访问”，共同构成现代处理器内存访问延迟优化的核心。","link":"/2026/01/04/os/Linux%E7%9A%84%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/"},{"title":"Linux的内核同步","text":"内核抢占内核抢占是指在内核态运行时允许高优先级任务中断当前任务执行，从而提升系统响应性和实时性的机制。同样的，内核抢占依赖于两个重要的关键条件： 可重入的内核设计：可重入意味着 内核代码在被抢占后，仍能被其他内核线程或中断安全地再次进入并执行，不会引发数据破坏或逻辑错误。 完善的内核同步机制：抢占意味着多个内核任务可能同时执行或交错执行某些共享资源操作，因此必须通过同步手段（如自旋锁、顺序锁、RCU等）来保护临界区。同步的目标是防止竞态条件和保证内存一致性 同步原语每CPU变量​ 每CPU变量（Per-CPU variable） 是 Linux 内核中一种优化机制，指的是：为每个 CPU 分配一份独立的变量副本，从而避免多核系统中对共享变量的竞争，提高并发性能。由于使用每CPU变量是为了解决cache热的问题，因此每CPU变量非常适合最终一致性和无共享写的场景，但不适用于要求跨 CPU 严格顺序或同步一致性的场景。每CPU变量常见于计数，如中断计数和网络包计数。 原子操作​ **原子操作（Atomic Operation）**是指一类 不可中断、不可分割 的操作，他可以保证这个操作要么一定完成，要么不执行。原子操作是一种轻量级、高效的线程同步方式，适合用于简洁的并发控制场景 内存屏蔽​ 内存屏障（Memory Barrier）是一种指令级的同步机制，用于防止指令在编译器或 CPU 执行阶段发生重排序。在现代编译器中，为了优化代码的执行，会发生指令重排，而内存屏障的作用就是保证在这之后的指令不会越过屏障。 自旋锁自旋锁是一种 忙等锁，即如果当前锁已被持有，等待者会在原地循环检查（“自旋”），而不是睡眠等待。 在 Linux 内核中，自旋锁常用于短时间的临界区保护，因为其不涉及上下文切换。 抢占式自旋锁：持有自旋锁期间，关闭调度器，当前CPU不会被抢占。其更简单、效率高，适用于SMP系统中频繁使用的场景 非抢占式自旋锁：常见于非SMP系统，在请求锁的期间，允许被抢占，有强的实时性要求系统中是允许自旋锁被抢占 顺序锁顺序锁是一种允许读者在不加锁的情况下并发读取数据，但需要检测是否发生“写冲突”，如果发生则重新读取。即读不需要获取锁的限制，但是写的时候，不允许读，并且独占资源。由于不对读做限制，在发生写入后，要实时更新，这个时候是根据序列号是否变化来判断的。 读数据的时候：获取序列号，如果为奇数（表明正在写入，不读取）。为偶数，说明可以读，但是要检查序列号是否一样，不一样要重新读取 写数据的时候：获取写的互斥锁，序列号加一，开始写入。当写完之后，序列号在加一，表明写入完成，同时释放写锁。 RCU（READ-COPY-UPDATE）RCU的核心思想是：将读写并发冲突的问题，通过将“读”与“写”解耦，转化为“复制 + 替换 + 延迟回收”模型来解决，以达到极高性能的并发读访问。 R（Read）——无锁读取 RCU 的“Read”阶段允许多个读者线程在不加锁的情况下并发访问共享数据结构。读者只需通过调用 rcu_read_lock() 和 rcu_read_unlock() 将访问代码包围起来，便可安全读取指针指向的数据，而无需担心数据正在被更新。这种无锁读机制极大地提高了系统在读多写少场景下的并发性能，因为读者不会阻塞写者，也不会相互阻塞。 C（Copy）——复制修改 当需要更新共享数据时，写者不会直接修改正在被读者访问的数据，而是首先复制一份数据副本。在副本上进行修改后，通过原子方式将全局指针指向新的数据副本，完成所谓的“发布更新”操作。这个“Copy”过程确保了读者始终访问一致、不可变的旧数据视图，从而实现读写解耦。 U（Update）——延迟回收 一旦新的数据副本被成功替换，旧数据就不再是当前版本，但它仍可能被一些尚未退出 RCU 读临界区的线程引用。为了安全地回收旧数据，RCU 会等待一个称为“宽限期（Grace Period）”的时间段，在此期间内，系统保证所有正在读取旧数据的线程都已完成访问。只有在宽限期结束后，旧数据才会被安全释放或重用。 信号量在Linux中，信号量被分为内核信号量和POSIX信号量（用户态） 内核信号量（Kernel Semaphore） ​ 内核信号量是 Linux 内核空间中用于实现线程间同步的同步原语，适用于内核模块、驱动程序等不能使用用户态同步机制的场景。它主要用于协调内核线程对共享资源的访问，支持阻塞等待，可用于实现类似互斥锁的功能。内核提供的接口包括 sema_init() 初始化信号量、down() 获取资源（P 操作）、up() 释放资源（V 操作）。与 spinlock 相比，信号量适用于允许睡眠的临界区，避免忙等，提高内核效率。 POSIX信号量（POSIX Semaphore） ​ POSIX 信号量是 POSIX 标准（IEEE 1003.1b）定义的用户空间多线程/多进程同步机制，支持命名信号量（跨进程）和无名信号量（同进程多线程）。其接口包括 sem_init() 初始化、sem_wait() 阻塞等待、sem_post() 释放资源、sem_destroy() 释放信号量结构等。POSIX 信号量可以基于 futex 等内核机制实现，兼顾效率和通用性，是现代类 Unix 系统中广泛使用的同步方式之一，适用于线程和进程间资源控制与互斥。","link":"/2026/01/04/os/Linux%E7%9A%84%E5%86%85%E6%A0%B8%E5%90%8C%E6%AD%A5/"},{"title":"6.S081-Fall2021 的实现","text":"MIT 6.S081This repository contains my solution to the labs for MIT’s 6.S081 operating system. How to use it ?First, you need to clone this repository by 1git clone https://github.com/kosa-as/xv6-labs-2021.git Then cd into the file, you are now in the master branch of the projects, to see my answer to a specific lab, e.g. util, syscall …… , you just checkout into that branch by for example 1git checkout util and now you are in the utils branch which contains my solution to the specific lab. if you want to have a clean copy of the original lab handout, just go to the course website and follow the lab guidance. Also, you can watch the course videos on the course website. Hope you enjoy your OS journey. If you want to push to your own GitHub repository, run: 1git remote set-url &lt;remote-name&gt; &lt;new-URL&gt; Then push to the remote repository as usual. Lab ReportsFor each lab, I wrote a brief report on my implementation, explaining the important part of my code and how to complete the lab step by step. (I wrote these reports in Chinese) Lab Utilities Lab System Calls Lab Page Tables Lab Traps Lab Copy-on-Write Lab Multithreading Lab Lock Lab File System Reading materialsI highly recommend you read the xv6 book before watching the course videos and doing the labs.","link":"/2026/01/04/os/6.S081-Fall2021/"},{"title":"Linux的系统调用和信号","text":"系统调用系统调用构成了操作系统为用户态任务提供硬件资源访问能力的接口，而广泛应用的 POSIX API 则对这些系统调用的行为和形式进行了标准化定义。 系统调用的整个过程会发生什么？ 首先，用户态进程执行到系统调用的函数的时候，系统调用所需要传递的参数都已被放入寄存器中。此时，通过特殊的指令，如syscall，ecall触发系统调用陷入内核态，将返回地址以及系统调用号放入寄存器中，同时跳转到中断向量表设定的系统调用入口 在进行系统调用的处理过程中，根据寄存器中保留的系统调用号，调用对应的系统调用，同时保存进程的上下文以便恢复后续的执行 从寄存器中读取具体系统调用所需要的参数，然后交给内核处理具体的系统调用 处理结束之后，恢复上下文，并且将结果写入寄存器中，同时调用特殊的返回指令返回用户态，并恢复先前的执行 至此，进程恢复用户态，成功的完成了一次系统调用 系统调用的参数是怎么传递的？ 一般情况下，参数的传递是通过寄存器实现的。 但是如果所需要传递的参数过多，那么需要使用一片缓冲区，将指向缓冲区的指针传递。在内核态的时候，使用访问用户态地址空间的接口从用户态读入参数。 Linux内核关于加速系统调用的一些设计有一些系统调用，并不涉及到内核态下的写，比如获取时钟，当前执行的CPU编号。对于这些只读的系统调用，如果采用上述的系统调用方法，那么是耗时的。这里引入了 VDSO (visual dynamic share object)的概念，在进程的用户态地址空间映射了内核的代码，来避免了用户态→内核态→用户态的切换开销。 信号信号是一个很简短的消息，通常用一个数字去标识。在编写程序中，通过一组以SIG开头的宏来标识信号。信号在UNIX中即被设计出来，用来完成进程间的通讯，和内核通知进程发生的事。 信号的处理流程数据结构关系回顾任务中定义 task_struct中有关信号的定义的部分(截取部分)： 12345678910111213/* Signal handlers: */struct signal_struct *signal;struct sighand_struct __rcu *sighand;sigset_t blocked;sigset_t real_blocked;/* Restored if set_restore_sigmask() was used: */sigset_t saved_sigmask;struct sigpending pending;unsigned long sas_ss_sp;size_t sas_ss_size;unsigned int sas_ss_flags;struct callback_head *task_works; 其中，struct sigpending pending;是每个任务级的私有的信号 pending队列 然后是 signal_struct的具体定义（截取部分)： 12345678910111213141516struct signal_struct { refcount_t sigcnt; atomic_t live; int nr_threads; int quick_threads; struct list_head thread_head; wait_queue_head_t wait_chldexit; /* for wait4() */ /* current thread group signal load-balancing target: */ struct task_struct *curr_target; /* shared signal handling: */ struct sigpending shared_pending;...} struct signal_struct *signal是保存线程组级的信号处理状态（共享信号队列、线程数、wait4() 等状态）。整个进程的多个线程共享同一个 signal_struct。 信号发送到任务的过程 首先判断信号是发给 整个线程组 还是某个 特定任务 发送给整个线程组 → 加入 task_struct-&gt;signal_struct-&gt;shared_pending 任务级信号 → 加入 task_struct-&gt;pending 检查目标线程的 blocked mask ： 如果该信号在 blocked 中 → 进入挂起队列（pending），暂不递送。 如果不在 blocked 中 → 标记 TIF_SIGPENDING，让调度点检查并递送。 当线程返回用户态前（do_signal() 调用处）或被 ptrace 操作时，检查并处理 pending 信号。 当一个线程从内核态要 切换回用户态 （比如系统调用结束、异常/中断处理完毕）时，内核会检查： 这个线程的 pending（私有挂起信号队列） 以及 signal_struct-&gt;shared_pending（线程组挂起信号队列） 如果有未屏蔽的挂起信号，内核会调用 do_signal() 来递送它们。 所以信号 不会在内核态任意时刻打断执行 ，而是在准备返回用户态的“安全点”才执行（除非是致命信号 SIGKILL 这种立即生效的）。 任务怎么处理发送的信号任务必须以三种方式对收到的信号作出应答： 忽略 执行信号所定义的缺醒操作（如SIGKILL，SIGSTOP是必须执行对应的缺醒操作的) 调用相应的信号处理函数捕获处理信号","link":"/2026/01/04/os/Linux%E7%9A%84%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%E5%92%8C%E4%BF%A1%E5%8F%B7/"},{"title":"Linux中的中断和异常","text":"中断和异常的初步介绍在逻辑电路的层面，中断被定义为一个信号，用来改变处理器的指令执行顺序。这里的中断被分为同步中断和异步中断： 同步中断：由处理器自发产生，它一定发生在一条指令执行完之后 异步中断：有其它设备按照处理器的时钟随机产生 既然发生了中断，就说明需要对应的中断处理程序==中断处理程序不是进程，它更应该被视为一种CPU对硬件事件的响应机制，是一种软硬件结合的“执行路径抽象”==，出于性能的需求，中断处理程序必须满足：简短，高效且不可阻塞的。其中中断有不同的种类，所有的中断都用无符号八位数来标识，这个标识被英特尔称为向量。 上面所说的是学习用的通俗理解，在现代的Linux内核中，中断真正的处理往往采用：中断上下文 + 延迟处理机制 方式的结合，来高效的处理中断。在本文的最后会给出现代Linux内核处理的详细解释和介绍。 注意，在上面的中断是包括了同步中断和异步中断，后面，在 intel开发手册中，将同步中断定义为异常，异步中断则定义为中断。中断具体指代什么，要在具体的语境中去理解。 异常异常是CPU在执行指令的时候，探测到的一个反常的问题。异常可以分为三种：故障(fault)，陷阱(trap)，错误(error)。 异常处理异常处理的流程可以概括为：程序执行中触发异常 → CPU 根据中断向量跳转 → 自动保存部分上下文并切换到内核态 → 执行trap入口 → 调用C语言trap处理函数 → 执行具体异常处理逻辑 → 恢复上下文 → 返回用户态。 在执行期间，如果发生除零错误、page fault、非法指令或系统调用等情况，CPU会立即响应异常。对于系统调用这种人为触发的trap，也会走统一的异常处理路径。 触发异常后，CPU会自动保存部分关键上下文（如PC、CS、EFLAGS），并切换到内核栈和内核态，再根据中断向量表跳转到对应trap handler入口。 trap handler汇编代码会进一步保存所有通用寄存器内容，并最终调用高级语言编写的trap处理函数（如Linux中的 do_page_fault等）。处理函数会根据异常类型决定是修复（如分配页框）还是终止进程。 处理完成后，内核恢复用户态上下文，并使用 iret/sysret等指令返回用户态，继续程序执行（如果未被终止）。 中断中断则是由外部的硬件设备所引起的，中断分为两种，可屏蔽中断和不可屏蔽中断。其中，IO设备所产生的中断都是可屏蔽中断。 中断处理每个能发出中断请求的硬件设备都会通过一条 IRQ 线连接到 PIC（可编程中断控制器）。PIC 监视这些 IRQ 线，当检测到有中断信号时，会将对应的中断向量编号准备好，并通过 INTR 线向 CPU 发送中断请求。 CPU 收到 INTR 信号后，会发出 INTA（中断确认）信号，PIC 会将中断向量号发送到数据总线。CPU 读取该向量号后，用它去中断描述符表（IDT）中查找并跳转到对应的中断服务程序。 后续处理中断的流程（切换内核态、保存上下文、执行 handler、恢复现场）与异常处理类似，但中断源于外设，异常则是程序执行错误引发。 ==注：这里的PIC是单一CPU上的概念，现在更多使用的是APIC，即高级可编程中断控制器。即APIC接收所有的IRQ线，然后通过ICC（中断控制通信总线）来在SMP（Symmetric Multi-Processing，对称多处理器）下和其他的CPU通讯== 值得注意的是，并不是所有的IRQ和硬件设备都是一一对应的，IRQ的数量是有限的，会出现一个IRQ映射到多个可以发出中断请求的硬件设备的情况。例如IRQ43既可以分配给声卡，也可以分配给USB端口。而处理这种情况主要有两种方式： IRQ共享：每个硬件设备被抽象为一个 IRS（中断请求源），当中断控制器检测到某个 IRQ 线（或 MSI 中断）触发时，它会将对应的中断号传递给 CPU。内核通过中断号在 irq_desc[] 中查找到对应的中断处理程序列表，然后调用已注册的 ISR（中断服务例程）。如果该中断号上注册了多个共享 ISR，则会遍历这些 ISR，以确定哪个设备实际触发了中断。 IRQ动态分配：引入了虚拟IRQ的概念，一条IRQ线可能在最后时刻才会与一个设备驱动程序相关联。通过动态分配的方式，使得IRQ可以挂载更多的硬件设备，并且支持热插拔。 中断处理程序和异常处理程序的嵌套首先要明确的一点是，在进行中断处理程序或者异常处理程序的时候，CPU是处于中断上下文的，这个时候禁用了调度器，所以无法发生进程切换。关于中断处理程序和异常处理程序的嵌套： 中断处理程序可以被更高级的中断处理程序打断 异常处理程序可以被中断处理程序打断，反之则不可以 Linux中的中断处理在 Linux 内核中，中断处理被设计成一个分层体系，除了硬件触发的硬中断（硬中断处理程序），即中断上下文中的上半部分处理，还包括延迟执行的软中断（SoftIRQ） 和 tasklet，它们被广泛用于中断上下文中的下半部分处理。 部分 名称 执行位置 特点 上半部分 硬中断处理程序（ISR） 中断上下文 响应快，执行短，不可阻塞 下半部分 软中断（SoftIRQ）、tasklet、工作队列（workqueue） 进程上下文或中断上下文（非抢占） 延迟处理，功能丰富 在 Linux 中，中断处理被划分为“上半部分”和“下半部分”两层结构，其中上半部分（即中断服务例程，ISR）主要负责快速响应中断事件，通常只执行一些必要且简短的操作。具体而言，它的核心职责包括：清除中断标志位以避免中断抖动、保存设备状态（如读入寄存器值）、以及调度下半部分处理逻辑的入口函数（如tasklet_schedule()或 raise_softirq()）。 由于 ISR 运行在中断上下文中，不允许阻塞或进行复杂处理，Linux 要求其尽可能快速返回，以避免中断屏蔽时间过长、影响系统整体响应性能。 因此，真正的业务逻辑处理——例如网络数据包解析、磁盘数据传输、状态更新等，通常放在下半部分执行。这些延迟执行的处理可以通过软中断（softirq）、tasklet 或工作队列（workqueue）实现，分别适用于不同的实时性、可阻塞性和并发需求。这样设计既保证了中断响应的实时性，也提升了系统的并发处理能力和整体调度灵活性。","link":"/2026/01/04/os/Linux%E4%B8%AD%E7%9A%84%E4%B8%AD%E6%96%AD%E5%92%8C%E5%BC%82%E5%B8%B8/"},{"title":"用hexo+icarus搭建个人博客","text":"如何用Hexo+Icarus建立一个个人网站前置准备在开始建立个人网站前，需要安装以下工具： Node.js 和 npm 下载地址：Node.js官网 安装后，在终端运行以下命令验证安装成功：12node -vnpm -v Git 下载地址：Git官网 安装后，在终端运行以下命令验证安装成功：1git --version GitHub账号 如果你打算部署到GitHub Pages，需要一个GitHub账号 注册地址：GitHub 安装Hexo 全局安装Hexo-CLI 1npm install -g hexo-cli 创建Hexo项目 123hexo init my-blogcd my-blognpm install 安装必要的插件 12npm install hexo-renderer-inferno --savenpm install hexo-deployer-git --save 安装Icarus主题 安装Icarus主题 1npm install hexo-theme-icarus --save 启用Icarus主题 在根目录下的 _config.yml中修改主题设置：1theme: icarus 或者使用以下命令自动创建主题配置文件：1hexo config theme icarus 个性化配置基本配置 修改 _config.yml文件 站点名称、作者、URL等基本信息 1234567title: 你的网站标题subtitle: '副标题'description: '网站描述'keywords: 关键词author: 你的名字language: zh-CNtimezone: 'Asia/Shanghai' 配置部署信息 ==注意，这里的repo必须为github仓库中以github.io结尾的仓库名字== 1234deploy: type: git repo: git@github.com:用户名/用户名.github.io.git branch: master Icarus主题配置 修改 _config.icarus.yml文件 ==注意，在publish文件下的内容全部是自动生成的内容，对这个文件下的内容做的所有修改都是无效的。以及所有_config.icarus.yml中的相对寻址路径都是在public下去寻找的。如果要添加自己的图片，请在source下新建img文件，放入图片，你会在publish对应的文件夹下面看见你放入的文件。更多详情请见icarus和hexo的官方文档== 配置网站logo和图标 123logo: /img/logo.svghead: favicon: /img/favicon.svg #在public下的img文件夹中去寻找图标 配置导航菜单 1234567navbar: menu: 首页: / 归档: /archives 分类: /categories 标签: /tags 关于: /about 配置侧边栏 12345678910111213141516171819202122232425262728sidebar: left: sticky: true right: sticky: truewidgets: - position: left type: profile author: 你的名字 author_title: 你的职位 location: 你的位置 avatar: /img/avatar.jpg - position: left type: toc - position: left type: categories - position: left type: recent_posts - position: left type: archives - position: left type: tags 调整主栏宽度 如果想让主栏更宽，可以将所有widget放在同一侧（如左侧）。可以参考常见问题 - Icarus (ppoffice.github.io) 配置Gitalk评论系统 如果你没有有自己的OAuth应用：注册GitHub OAuth应用 访问 https://github.com/settings/applications/new 填写应用名称（如”博客评论”） 主页URL：你的博客地址 回调URL：与主页URL相同 点击”Register application” 如果你已经有自己的OAuth应用：查看已创建的OAuth应用 GitHub头像 -&gt; Settings -&gt; Developer settings -&gt; OAuth Apps 配置Gitalk 在 _config.icarus.yml中添加： 12345678comment: type: gitalk client_id: 你的client_id client_secret: 你的client_secret repo: 用户名.github.io owner: GitHub用户名 admin: - GitHub用户名 初始化评论 部署网站后，以管理员身份登录并访问每篇文章，初始化对应的GitHub Issue 创建内容 创建新文章 1hexo new &quot;文章标题&quot; 文章格式 123456789101112131415---title: 文章标题date: 2023-03-18categories: - 分类1 - 分类2tags: - 标签1 - 标签2excerpt: 这是文章摘要，会显示在首页。---&lt;!-- more --&gt;这里是文章正文内容... 本地预览 启动本地服务器 1hexo server 访问本地预览 浏览器打开 http://localhost:4000 部署网站 生成静态文件 12hexo clean hexo generate #或者直接 hexo g 部署到GitHub Pages 1hexo deploy #或者直接 hexo d 自定义域名（可选） 在 source目录下创建 CNAME文件，内容为你的域名 在域名提供商处设置DNS解析到GitHub Pages 常见问题解决 主题配置问题 确保YAML格式正确，注意缩进 使用在线YAML验证工具检查格式 图片显示问题 将图片放在 source/img/目录下 路径使用 /img/图片名.jpg Gitalk初始化问题 确保client_id和client_secret正确 检查repo名称是否正确 需要管理员登录GitHub并访问文章页面初始化评论 参考资源 Hexo官方文档 Icarus主题文档 Gitalk文档","link":"/2026/01/04/os/%E7%94%A8hexo+icarus%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/"}],"tags":[{"name":"数据系统","slug":"数据系统","link":"/tags/%E6%95%B0%E6%8D%AE%E7%B3%BB%E7%BB%9F/"},{"name":"OLAP","slug":"OLAP","link":"/tags/OLAP/"},{"name":"OLTP","slug":"OLTP","link":"/tags/OLTP/"},{"name":"数据仓库","slug":"数据仓库","link":"/tags/%E6%95%B0%E6%8D%AE%E4%BB%93%E5%BA%93/"},{"name":"数据湖","slug":"数据湖","link":"/tags/%E6%95%B0%E6%8D%AE%E6%B9%96/"},{"name":"湖仓一体","slug":"湖仓一体","link":"/tags/%E6%B9%96%E4%BB%93%E4%B8%80%E4%BD%93/"},{"name":"SFINAE","slug":"SFINAE","link":"/tags/SFINAE/"},{"name":"构造顺序","slug":"构造顺序","link":"/tags/%E6%9E%84%E9%80%A0%E9%A1%BA%E5%BA%8F/"},{"name":"类型擦除","slug":"类型擦除","link":"/tags/%E7%B1%BB%E5%9E%8B%E6%93%A6%E9%99%A4/"},{"name":"模板匹配","slug":"模板匹配","link":"/tags/%E6%A8%A1%E6%9D%BF%E5%8C%B9%E9%85%8D/"},{"name":"STL","slug":"STL","link":"/tags/STL/"},{"name":"C++关键字解析","slug":"C-关键字解析","link":"/tags/C-%E5%85%B3%E9%94%AE%E5%AD%97%E8%A7%A3%E6%9E%90/"},{"name":"Template","slug":"Template","link":"/tags/Template/"},{"name":"设计模式","slug":"设计模式","link":"/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"name":"并发编程","slug":"并发编程","link":"/tags/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"},{"name":"RAII","slug":"RAII","link":"/tags/RAII/"},{"name":"C++指针","slug":"C-指针","link":"/tags/C-%E6%8C%87%E9%92%88/"},{"name":"内存管理","slug":"内存管理","link":"/tags/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/"},{"name":"编译原理","slug":"编译原理","link":"/tags/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/"},{"name":"性能优化","slug":"性能优化","link":"/tags/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"},{"name":"C++语言特性","slug":"C-语言特性","link":"/tags/C-%E8%AF%AD%E8%A8%80%E7%89%B9%E6%80%A7/"},{"name":"左值右值","slug":"左值右值","link":"/tags/%E5%B7%A6%E5%80%BC%E5%8F%B3%E5%80%BC/"},{"name":"引用","slug":"引用","link":"/tags/%E5%BC%95%E7%94%A8/"},{"name":"lambda表达式","slug":"lambda表达式","link":"/tags/lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F/"},{"name":"运行时特性","slug":"运行时特性","link":"/tags/%E8%BF%90%E8%A1%8C%E6%97%B6%E7%89%B9%E6%80%A7/"},{"name":"面向对象编程","slug":"面向对象编程","link":"/tags/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B/"},{"name":"docker","slug":"docker","link":"/tags/docker/"},{"name":"k8s","slug":"k8s","link":"/tags/k8s/"},{"name":"文件系统","slug":"文件系统","link":"/tags/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/"},{"name":"IO","slug":"IO","link":"/tags/IO/"},{"name":"进程描述符","slug":"进程描述符","link":"/tags/%E8%BF%9B%E7%A8%8B%E6%8F%8F%E8%BF%B0%E7%AC%A6/"},{"name":"页表","slug":"页表","link":"/tags/%E9%A1%B5%E8%A1%A8/"},{"name":"内存寻址","slug":"内存寻址","link":"/tags/%E5%86%85%E5%AD%98%E5%AF%BB%E5%9D%80/"},{"name":"操作系统","slug":"操作系统","link":"/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"},{"name":"同步","slug":"同步","link":"/tags/%E5%90%8C%E6%AD%A5/"},{"name":"并行","slug":"并行","link":"/tags/%E5%B9%B6%E8%A1%8C/"},{"name":"异步","slug":"异步","link":"/tags/%E5%BC%82%E6%AD%A5/"},{"name":"异常","slug":"异常","link":"/tags/%E5%BC%82%E5%B8%B8/"},{"name":"中断","slug":"中断","link":"/tags/%E4%B8%AD%E6%96%AD/"},{"name":"Hexo","slug":"Hexo","link":"/tags/Hexo/"},{"name":"Icarus","slug":"Icarus","link":"/tags/Icarus/"},{"name":"GitHub Pages","slug":"GitHub-Pages","link":"/tags/GitHub-Pages/"},{"name":"Gitalk","slug":"Gitalk","link":"/tags/Gitalk/"}],"categories":[{"name":"云","slug":"云","link":"/categories/%E4%BA%91/"},{"name":"C++","slug":"C","link":"/categories/C/"},{"name":"STL","slug":"STL","link":"/categories/STL/"},{"name":"Java","slug":"Java","link":"/categories/Java/"},{"name":"云数据中心","slug":"云数据中心","link":"/categories/%E4%BA%91%E6%95%B0%E6%8D%AE%E4%B8%AD%E5%BF%83/"},{"name":"操作系统","slug":"操作系统","link":"/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"},{"name":"Linux","slug":"Linux","link":"/categories/Linux/"},{"name":"博客搭建","slug":"博客搭建","link":"/categories/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"},{"name":"Linux","slug":"操作系统/Linux","link":"/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/Linux/"},{"name":"前端开发","slug":"博客搭建/前端开发","link":"/categories/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/"}],"pages":[]}