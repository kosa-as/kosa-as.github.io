{"posts":[{"title":"C++关键字解析","text":"1.sizeof和strlen的区别strlen测量的是字符串的实际长度,源代码如下 123456size_t strlen(const char *str) { size_t length = 0; while (*str++) ++length; return length;} sizeof测量的是对象或者表达式类型占用的字节大小 总而言之，一个测量的是实际长度，到’/0’结束，而另一个则是测量实际占用的大小。 2.static的用法 应用场景 类型 作用 局部 static 变量 函数内部 变量生命周期贯穿整个程序，但作用域仅限函数 文件内部 static 变量 文件作用域 限制变量可见性，避免命名冲突 文件内部 static 函数 文件作用域 仅在当前编译单元可见，隐藏实现细节 类的 static 变量 类成员 所有对象共享 类的 static 函数 类成员 不依赖对象，访问静态数据 静态工具类 = delete 防止实例化 线程安全的 static 变量 C++11 确保多线程环境下安全初始化 static 的核心作用： ✅ 控制作用域（文件/函数级别）✅ 延长生命周期（局部 static 变量）✅ 共享数据（类 static 成员）✅ 提升封装性（防止全局变量污染） 3.const的用法 用法 作用 const int a = 10; 常量变量，不可修改 const int* p; 指针指向的值不可修改 int* const p; 指针本身不可修改 const int* const p; 指针本身和指向的值都不可修改 void func(const int x); 传值参数不可修改 void func(const int* p); 传指针参数，指向的值不可修改 void func(const int&amp; ref); 传引用参数，引用值不可修改 class A { const int data; }; 类的成员变量不可修改，需构造函数初始化 void show() const; const 成员函数，不能修改类成员变量 const int&amp; getData() const; const 返回值，防止修改 4.const和define的区别 特性 #define const 作用 预处理文本替换 定义常量变量 类型检查 ❌ 无类型检查，可能引发错误 ✅ 有类型检查，更安全 作用域 ❌ 无作用域，作用于整个文件 ✅ 遵循 C++ 作用域规则 内存占用 ❌ 仅进行文本替换，不占用变量存储空间 ✅ 变量存储在只读数据区 可调试性 ❌ 不能在调试器中查看 ✅ 可以查看变量值 const 指针支持 ❌ 不能用于指针 ✅ 可用于指针，如 const int* p 适用场景 定义简单的文本宏（如 #define DEBUG） 定义具有类型的常量 在C++11之后，推荐使用constexpr来完成一些define定义的值。意味编译时常量，在编译时完成计算来提高程序性能 5.inline函数的作用和使用inline 关键字用于建议编译器在调用处直接展开函数代码，以减少函数调用的开销，提高运行效率。它适用于短小、频繁调用的函数。 类内部定义的函数默认是inline的 1234class Math {public: int square(int x) { return x * x; }//✅默认inline}; 6.malloc和new的区别 特性 new / new[] malloc() / calloc() 语言 C++ C（C++ 兼容） 分配类型 适用于对象，调用构造函数 仅分配原始内存，不会调用构造函数 释放方式 delete / delete[] free() 返回类型 直接返回正确类型指针 返回 void*，需要手动转换类型 初始化 new 会初始化对象（默认构造或指定初始化） malloc 不会初始化（calloc 会零初始化） 异常处理 new 失败时抛出 std::bad_alloc 异常 malloc 失败时返回 NULL，需要手动检查 安全性 更安全，支持 RAII（如 std::unique_ptr） 可能导致类型错误，易发生内存泄漏 7.free和delete的区别 特性 delete / delete[] free() 适用语言 C++ C（C++ 兼容） 适用对象 new 分配的对象 malloc/calloc/realloc 分配的内存 析构函数 ✅ 调用析构函数 ❌ 不会调用析构函数 作用范围 对象销毁 + 释放内存 仅释放内存 使用方式 delete p; / delete[] p; free(p); 安全性 更安全，支持类对象的管理 仅适用于 C 语言风格的内存管理 类型安全 不需要强制转换 需要强制转换 void* 8.volatile关键字的使用与场景volatile关键字在编程中用于确保变量的可见性和防止编译器优化，其核心作用是告诉编译器每次访问变量时必须直接从内存中读取或写入，而不是使用寄存器中的缓存值。常用于嵌入式开发从硬件寄存器中读取数据 作用： 禁止编译器优化确保每次对变量的读写操作都直接作用于内存，而非寄存器中的临时值，避免因优化导致意外行为。 保证可见性当变量可能被外部因素（如硬件、其他线程、信号处理函数）修改时，确保程序能读取到最新值 9.C语言中struct和CPP语言中struct的区别 特性 C语言中的 struct C++中的 struct C++中的 class 默认访问控制 公有 (public) 公有 (public) 私有 (private) 成员函数 不支持 支持 支持 构造函数和析构函数 不支持 支持 支持 继承和多态 不支持 支持 支持 简单来说，C++中的struct和class非常相似，区别主要在于默认的访问控制权限，struct默认是public，而class默认是private。（在继承的时候也是如此）因此struct被用于保存数据结构，而class则用于描述抽象对象。 10.extern关键字extern 是 C 和 C++ 中的一个关键字，主要用于声明变量或函数的外部链接，意味着该变量或函数是在其他地方定义的，而不是当前文件中定义的。 11.explicit关键字用来声明类构造函数是显式调用的，而非隐式调用，可以阻止调用构造函数时进行隐式转换和赋值初始化。只可用于修饰单参构造函数，因为无参构造函数和多参构造函数本身就是显式调用的，再加上 explicit 关键字也没有什么意义。 声明 explicit 的构造函数，从而可以阻止编译器执行非预期 (往往也不被期望) 的类型转换，因为某些非预期的类型转换可能会引起意向不到的错误。 举例： 1234567891011121314151617181920#include &lt;iostream&gt;#include &lt;cstring&gt;using namespace std;class A{public: int var; A(int tmp) { var = tmp; }};int main(){ A ex = 10; // 发生了隐式转换 return 0;}// 在上述过程中，A ex = 10实际上是先执行了A ex1(10), A ex = ex1。先将10转为A类型的对象，然后将该对象转为ex 12.#define vs typedef 特性 #define typedef 本质 预处理指令，文本替换 类型定义，编译时处理 类型检查 无类型检查，仅仅是字符串替换 受C语言类型系统约束，更加安全 指针类型 可能导致意外错误（如 INT_PTR a, b） 遵循类型规则（如 INT_PTR_T a, b） 适用场景 定义常量、宏函数 定义类型别名，适用于结构体、指针等 可调试性 代码不易调试（文本替换可能引入问题） 更加直观，类型更加明确 使用 #define 仅当你需要定义常量或者宏函数时，如 #define PI 3.14。 使用 typedef 适用于定义复杂类型的别名，如 typedef struct、指针、数组等。 因此，typedef 在处理类型时比 #define 更安全、直观，而 #define 更适用于常量和宏。 13.memmovememmove 是 C 标准库中的一个内存操作函数，声明在 &lt;string.h&gt; 头文件中。它的作用是将一块内存区域的数据复制到另一块内存区域，即使两块区域存在重叠，也能保证数据不会被破坏。因为在发生重叠的时候，就开始倒序复制，就可以避免这个问题 14.auto类型推导 (1) auto 类型推导规则 auto 根据右值类型推导，但去掉 const 和引用。 即基础类型推导，推导结果和初始化表达式一致，忽略引用和const修饰符。如果要保留这些特性，那么需要加上&amp;和const auto&amp; 保持引用类型，适用于引用变量。 const auto&amp; 可保持 const 限定，避免去掉 const。 auto* 适用于指针类型，但 const 规则同样适用。 decltype(auto) 会保持表达式的原始类型。 (2) auto vs decltype(auto) 表达式 推导类型 auto x = a;(a 是 const int) int auto&amp; x = a; int&amp; const auto x = a; const int decltype(auto) x = a; const int decltype(auto) x = b; (b 是 int&amp;) int&amp; C++ 的 auto 极大地增强了代码的简洁性，同时遵循模板推导规则，可以合理地推导类型，减少冗余代码。但在使用时，仍需注意 const、引用和指针的影响，以避免意外的类型变更","link":"/2025/02/25/C++%E5%85%B3%E9%94%AE%E5%AD%97%E8%A7%A3%E6%9E%90/"},{"title":"在C++20的标准下实现自己的vector容器","text":"首先介绍一下vector的基本功能：vector是一个线性容器，他是一种动态数组，其内存管理是动态的，但元素的访问方式类似于静态数组（即通过索引直接访问） 相关知识介绍： std::allocator: 在所有的标准stl容器中，都是使用allocator来管理内存，这种管理方式只会申请原始内存，即没有初始化。（不同于new，申请内存的同时会在堆上构建 ==不使用new的原因是默认的new效率更低，同时使用allocator可以更好的控制对象的生命周期，允许在已分配的内存中按需构造析构对象==）。同时使用std::allocator_traits&lt;std::allocator&lt;T&gt;&gt;::construct和std::allocator_traits&lt;std::allocator&lt;T&gt;&gt;::destory来显示的构造或者析构对象。 类的基本知识：在C++ 11之后，新建一个类，哪怕没有声明任何一个函数，编译器会默认实现六个函数，分别是：默认构造函数，默认析构函数，拷贝构造函数，移动构造函数，拷贝赋值函数，移动赋值函数。 迭代器：在类中，再去定义一个迭代器类，来封装一个容器内对象类型的指针，同时重载一些运算符的实现 动态内存：vector在堆上新申请一片内存，当这个内存被用满之后，那么vector就要重新去申请一片内存，然后把之前的元素全部放入。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697#include &lt;memory&gt;#include &lt;stdexcept&gt;#include &lt;initializer_list&gt;#include &lt;algorithm&gt;#include &lt;iostream&gt;template &lt;typename T&gt;class Vector {private: T* data; size_t vec_size; size_t vec_capacity; std::allocator&lt;T&gt; allocator; // 扩容函数声明 void reserve(size_t new_capacity); // 快速排序函数声明 template&lt;typename Compare&gt; void quick_sort(typename Vector&lt;T&gt;::iterator first, typename Vector&lt;T&gt;::iterator last, Compare cmp);public: class iterator { T* ptr; public: explicit iterator(T* ptr) : ptr(ptr) {} T&amp; operator*() const { return *ptr; }//解引用操作符 T* operator-&gt;() const { return ptr; }//成员访问操作符 iterator&amp; operator++() { ++ptr; return *this; }//前缀加 iterator operator++(int) { iterator tmp = *this; ++(*this); return tmp; }//后缀加 iterator&amp; operator--() { --ptr; return *this; }//前缀减 iterator operator--(int) { iterator tmp = *this; --(*this); return tmp; }//后缀减 bool operator==(const iterator&amp; other) const { return ptr == other.ptr; } bool operator!=(const iterator&amp; other) const { return ptr != other.ptr; } iterator operator+(size_t n) const { return iterator(ptr + n); } iterator operator-(size_t n) const { return iterator(ptr - n); } }; class const_iterator : public iterator { public: explicit const_iterator(const T* ptr) : iterator(ptr) {} const T&amp; operator*() const { return iterator::operator*(); } const T* operator-&gt;() const { return iterator::operator-&gt;(); } }; // 构造函数声明 Vector() noexcept; explicit Vector(size_t n); Vector(size_t n, const T&amp; val); Vector(std::initializer_list&lt;T&gt; init); Vector(iterator begin, iterator end); Vector(const Vector&lt;T&gt;&amp; other); Vector(Vector&lt;T&gt;&amp;&amp; other) noexcept; // 赋值运算符声明 Vector&amp; operator=(const Vector&lt;T&gt;&amp; other); Vector&amp; operator=(Vector&lt;T&gt;&amp;&amp; other) noexcept; // 析构函数声明 ~Vector(); // 迭代器函数声明 iterator begin(); const_iterator const_begin() const; iterator end(); const_iterator const_end() const; // 访问元素函数声明 T&amp; operator[](size_t index); T&amp; at(size_t index); // 容量和大小函数声明 [[nodiscard]] size_t capacity() const; void set_capacity(size_t new_capacity); [[nodiscard]] bool empty() const; [[nodiscard]] size_t size() const; // 清空函数声明 void clear(); // 添加元素函数声明 void push_back(const T&amp; value); // 添加元素函数声明,移动添加 void push_back(T&amp;&amp; value); // 添加元素函数声明，直接构造 template&lt;typename... Args&gt; void emplace_back(Args&amp;&amp;... args); // 查找元素函数声明 const_iterator find(const T&amp; value) const; // 插入元素函数声明 void insert(iterator pos, const T&amp; value); // 删除元素函数声明 void erase(iterator pos); void pop_back(); // 访问首尾元素函数声明 T&amp; front() const; T&amp; back() const; // 交换函数声明 void swap(Vector&amp; other); // 友元函数声明 template &lt;typename U&gt; friend std::ostream&amp; operator&lt;&lt;(std::ostream&amp; os, const Vector&lt;U&gt;&amp; vec); // 快速排序函数声明 template&lt;typename Compare = std::less&lt;T&gt;&gt; void sort(iterator first, iterator last, Compare cmp = Compare()); // 函数重写 template&lt;typename Compare = std::less&lt;T&gt;&gt; void sort(Compare cmp = Compare());}; vector的私有属性1234T* data;//指向管理的数据的指针size_t vec_size;//容器内数据的数量size_t vec_capacity;//分配内容可容纳的对象的数量std::allocator&lt;T&gt; allocator;//容器内存管理器 vector的迭代器12345678910111213141516171819202122class iterator { T* ptr; public: explicit iterator(T* ptr) : ptr(ptr) {} T&amp; operator*() const { return *ptr; } T* operator-&gt;() const { return ptr; } iterator&amp; operator++() { ++ptr; return *this; }//前缀加 iterator operator++(int) { iterator tmp = *this; ++(*this); return tmp; }//后缀加 iterator&amp; operator--() { --ptr; return *this; }//前缀减 iterator operator--(int) { iterator tmp = *this; --(*this); return tmp; }//后缀减 bool operator==(const iterator&amp; other) const { return ptr == other.ptr; } bool operator!=(const iterator&amp; other) const { return ptr != other.ptr; } iterator operator+(size_t n) const { return iterator(ptr + n); } iterator operator-(size_t n) const { return iterator(ptr - n); }};class const_iterator : public iterator { public: explicit const_iterator(const T* ptr) : iterator(ptr) {} const T&amp; operator*() const { return iterator::operator*(); } const T* operator-&gt;() const { return iterator::operator-&gt;(); }}; 在C++11之后，除了iterator之后，还实现了const_iterator。迭代器内实现了各种常见指针操作的重载 vector的扩容操作在执行push_back，emplace_back, insert等操作后，vector可能需要扩容，此时需要调用reserve函数去堆上申请一块新的内存空间。在vector扩容的时候，通常扩充为之前的1.5~2倍大小 1234567891011121314151617181920212223template &lt;typename T&gt;void Vector&lt;T&gt;::set_capacity(size_t new_capacity) { if (new_capacity &lt;= vec_capacity) return; // 只在需要扩容时执行 reserve(new_capacity);}// 扩容函数实现template &lt;typename T&gt;void Vector&lt;T&gt;::reserve(size_t new_capacity) { if (new_capacity &lt;= vec_capacity) return; // 只在需要扩容时执行 T* new_data = std::allocator_traits&lt;std::allocator&lt;T&gt;&gt;::allocate(allocator, new_capacity); // 移动现有元素 for (size_t i = 0; i &lt; vec_size; i++) { std::allocator_traits&lt;std::allocator&lt;T&gt;&gt;::construct(allocator, &amp;new_data[i], std::move(data[i])); std::allocator_traits&lt;std::allocator&lt;T&gt;&gt;::destroy(allocator, &amp;data[i]); } // 释放旧内存 if (data) { std::allocator_traits&lt;std::allocator&lt;T&gt;&gt;::deallocate(allocator, data, vec_capacity); } data = new_data; vec_capacity = new_capacity;} vector的构造函数1234567Vector() noexcept;explicit Vector(size_t n);Vector(size_t n, const T&amp; val);Vector(std::initializer_list&lt;T&gt; init);Vector(iterator begin, iterator end);Vector(const Vector&lt;T&gt;&amp; other);Vector(Vector&lt;T&gt;&amp;&amp; other) noexcept; 首先是默认构造Vector() noexcept, noexcept表示不会抛出异常 然后是单参构造函数explicit Vector(size_t n),在C++11之前，对于单参构造函数，都要用explicit来避免隐式转化。在C++11之后，也可以堆多参构造函数使用 拷贝构造函数Vector(const Vector&lt;T&gt;&amp; other); 12345678template &lt;typename T&gt;Vector&lt;T&gt;::Vector(const Vector&lt;T&gt;&amp; other) : data(nullptr), vec_size(0), vec_capacity(0) { reserve(other.vec_size); for (size_t i = 0; i &lt; other.vec_size; ++i) { std::allocator_traits&lt;std::allocator&lt;T&gt;&gt;::construct(allocator, &amp;data[i], other.data[i]); } vec_size = other.vec_size;} 移动构造函数Vector&lt;T&gt;::Vector(Vector&lt;T&gt;&amp;&amp; other) noexcept : 123456789101112// 移动构造函数实现template &lt;typename T&gt;Vector&lt;T&gt;::Vector(Vector&lt;T&gt;&amp;&amp; other) noexcept : data(other.data), vec_size(other.vec_size), vec_capacity(other.vec_capacity), allocator(std::move(other.allocator)) { // 防止 other 析构时释放我们刚&quot;偷&quot;来的内存 other.data = nullptr; other.vec_size = 0; other.vec_capacity = 0;} 初始化列表构造 Vector(std::initializer_list&lt;T&gt; init);: 1234567891011// 初始化列表构造函数实现template &lt;typename T&gt;Vector&lt;T&gt;::Vector(std::initializer_list&lt;T&gt; init) : data(nullptr), vec_size(0), vec_capacity(0) { if (init.size() &gt; 0) { reserve(init.size()); for (size_t i = 0; i &lt; init.size(); ++i) { std::allocator_traits&lt;std::allocator&lt;T&gt;&gt;::construct(allocator, &amp;data[i], *(init.begin() + i)); } vec_size = init.size(); }} 迭代器构造函数Vector(iterator begin, iterator end); 12345678910// 迭代器构造函数实现template &lt;typename T&gt;Vector&lt;T&gt;::Vector(iterator begin, iterator end) : data(nullptr), vec_size(0), vec_capacity(0) { size_t count = end - begin; reserve(count); for (size_t i = 0; i &lt; count; ++i) { std::allocator_traits&lt;std::allocator&lt;T&gt;&gt;::construct(allocator, &amp;data[i], *(begin + i)); } vec_size = count;} vector的析构函数调用clear()函数，清空allocator分配的内存 123456789101112131415161718// 析构函数实现template &lt;typename T&gt;Vector&lt;T&gt;::~Vector() { clear();}// 清空函数实现template &lt;typename T&gt;void Vector&lt;T&gt;::clear() { for (size_t i = 0; i &lt; vec_size; i++) { std::allocator_traits&lt;std::allocator&lt;T&gt;&gt;::destroy(allocator, &amp;data[i]); } if (data) { std::allocator_traits&lt;std::allocator&lt;T&gt;&gt;::deallocate(allocator, data, vec_capacity); } data = nullptr; vec_size = 0; vec_capacity = 0;} vector添加元素的操作 push_back:有两种方法，一种是拷贝构造，一种是移动构造 12345678910111213141516171819template &lt;typename T&gt;void Vector&lt;T&gt;::push_back(const T&amp; value) {//拷贝原对象 if (vec_size == vec_capacity) { size_t new_capacity = (vec_capacity == 0) ? 1 : 2 * vec_capacity; reserve(new_capacity); } std::allocator_traits&lt;std::allocator&lt;T&gt;&gt;::construct(allocator, data+vec_size, value); ++vec_size;}template &lt;typename T&gt;void Vector&lt;T&gt;::push_back(T&amp;&amp; value) {//利用右值直接构造 if (vec_size == vec_capacity) { size_t new_capacity = (vec_capacity == 0) ? 1 : 2 * vec_capacity; reserve(new_capacity); } std::allocator_traits&lt;std::allocator&lt;T&gt;&gt;::construct(allocator, data+vec_size, std::move(value)); ++vec_size;} emplace_back 123456789101112131415161718// 添加元素函数实现，直接构造template &lt;typename T&gt;template&lt;typename... Args&gt;void Vector&lt;T&gt;::emplace_back(Args&amp;&amp;... args) { if (vec_size == vec_capacity) { size_t new_capacity = (vec_capacity == 0) ? 1 : 2 * vec_capacity; reserve(new_capacity); } // 使用完美转发构造新元素 std::allocator_traits&lt;std::allocator&lt;T&gt;&gt;::construct( allocator, data + vec_size, std::forward&lt;Args&gt;(args)... ); ++vec_size;} insert：利用迭代器实现了元素的定点插入 1234567891011121314// 插入元素函数实现template &lt;typename T&gt;void Vector&lt;T&gt;::insert(iterator pos, const T&amp; value) { size_t index = pos - begin(); if (vec_size == vec_capacity) { size_t new_capacity = (vec_capacity == 0) ? 1 : 2 * vec_capacity; reserve(new_capacity); } for (size_t i = vec_size; i &gt; index; --i) { std::allocator_traits&lt;std::allocator&lt;T&gt;&gt;::construct(allocator, &amp;data[i], std::move(data[i-1])); } std::allocator_traits&lt;std::allocator&lt;T&gt;&gt;::construct(allocator, &amp;data[index], value); ++vec_size;} vector中排序的使用这里使用了比较器模板，在 C++ 中，比较器模板允许你为算法（如排序、查找、优先级队列等）提供自定义的比较规则，同时保持代码的泛用性和高性能。以下是实现比较器模板的详细方法及示例： 比较器可以是 函数指针、函数对象（仿函数） 或 Lambda 表达式。它们需要满足以下条件： 接受两个相同类型的参数。 返回 bool 类型，表示两个元素的顺序关系。 这里在类中比较器模板的申明中，指定了Compare = std::less&lt;T&gt; 12345678910111213141516171819202122232425262728293031323334353637// 快速排序函数实现template &lt;typename T&gt;template &lt;typename Compare&gt;void Vector&lt;T&gt;::quick_sort(typename Vector&lt;T&gt;::iterator first, typename Vector&lt;T&gt;::iterator last, Compare cmp) { if (first &gt;= last) return; // 选择基准元素（此处选择中间元素） T pivot = *(first + (last - first) / 2); iterator left = first; iterator right = last - 1; // 分区操作 while (left &lt;= right) { while (cmp(*left, pivot)) ++left; while (cmp(pivot, *right)) --right; if (left &lt;= right) { std::swap(*left, *right); ++left; --right; } } // 递归排序 quick_sort(first, right + 1, cmp); quick_sort(left, last, cmp);}// 快速排序函数实现template &lt;typename T&gt;template &lt;typename Compare&gt;void Vector&lt;T&gt;::sort(iterator first, iterator last, Compare cmp) { quick_sort(first, last, cmp);}template &lt;typename T&gt;template &lt;typename Compare&gt;void Vector&lt;T&gt;::sort(Compare cmp) { quick_sort(begin(), end(), cmp);} ​","link":"/2025/05/02/C++%E5%AE%9E%E7%8E%B0Vector%E5%AE%B9%E5%99%A8/"},{"title":"C++智能指针和内存管理","text":"RAIIRAII即Resource Acquisition is Initialization（资源获取即初始化） 在智能指针中添加了引用计数的概念，引用计数这种计数是为了防止内存泄露而产生的。 基本想法是对于动态分配的对象，进行引用计数，每当增加一次对同一个对象的引用，那么引用对象的引用计数就会增加一次， 每删除一次引用，引用计数就会减一，当一个对象的引用计数减为零时，就自动删除指向的堆内存。 std::unique_ptrstd::unique_ptr 是一种智能指针，它通过指针持有并管理另一对象（对其负责），并在 unique_ptr 离开作用域时释放该对象。 在发生下列两者之一时，用关联的删除器释放对象：（总结就是这个unique_ptr不在指向这个对象） 管理它的 unique_ptr 对象被销毁。 通过 operator= 或 reset() 赋值另一指针给管理它的 unique_ptr 对象。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118#include &lt;cassert&gt;#include &lt;cstdio&gt;#include &lt;fstream&gt;#include &lt;iostream&gt;#include &lt;memory&gt;#include &lt;stdexcept&gt;// 用于下面运行时多态演示的辅助类struct B{ virtual ~B() = default; virtual void bar() { std::cout &lt;&lt; &quot;B::bar\\n&quot;; }};struct D : B{ D() { std::cout &lt;&lt; &quot;D::D\\n&quot;; } ~D() override{ std::cout &lt;&lt; &quot;D::~D\\n&quot;; } void bar() override { std::cout &lt;&lt; &quot;D::bar\\n&quot;; }};// 消费 unique_ptr 的函数能以值或以右值引用接收它std::unique_ptr&lt;D&gt; pass_through(std::unique_ptr&lt;D&gt; p){ p-&gt;bar(); return p;}// 用于下面自定义删除器演示的辅助函数void close_file(std::FILE* fp){ std::fclose(fp);}// 基于 unique_ptr 的链表演示struct List{ struct Node { int data; std::unique_ptr&lt;Node&gt; next; }; std::unique_ptr&lt;Node&gt; head; ~List() { // 循环按顺序销毁各列表节点，默认析构函数将会递归调用其 “next” 指针的析构函数， // 这在足够大的链表上可能造成栈溢出。 while (head) { auto next = std::move(head-&gt;next); head = std::move(next); } } void push(int data) { head = std::make_unique&lt;Node&gt;(data, std::move(head-&gt;next)); }};int main(){ std::cout &lt;&lt; &quot;1) 独占所有权语义演示\\n&quot;; { // 创建一个（独占）资源 std::unique_ptr&lt;D&gt; p = std::make_unique&lt;D&gt;(); // 转移所有权给 “pass_through”，而它再通过返回值将所有权转移回来 std::unique_ptr&lt;D&gt; q = pass_through(std::move(p)); // “p” 现在是已被移动的“空”状态，等于 nullptr assert(!p); } std::cout &lt;&lt; &quot;\\n&quot; &quot;2) 运行时多态演示\\n&quot;; { // 创建派生类资源并通过基类指向它 std::unique_ptr&lt;B&gt; p = std::make_unique&lt;D&gt;(); // 动态派发如期工作 p-&gt;bar(); } std::cout &lt;&lt; &quot;\\n&quot; &quot;3) 自定义删除器演示\\n&quot;; std::ofstream(&quot;demo.txt&quot;) &lt;&lt; 'x'; // 准备要读取的文件 { using unique_file_t = std::unique_ptr&lt;std::FILE, decltype(&amp;close_file)&gt;; unique_file_t fp(std::fopen(&quot;demo.txt&quot;, &quot;r&quot;), &amp;close_file); if (fp) std::cout &lt;&lt; static_cast&lt;char&gt;(std::fgetc(fp.get())) &lt;&lt; '\\n'; } // 在此调用 “close_file()”（如果 “fp” 为空） std::cout &lt;&lt; &quot;\\n&quot; &quot;4) 自定义 lambda 表达式删除器和异常安全性演示\\n&quot;; try { std::unique_ptr&lt;D, void(*)(D*)&gt; p(new D, [](D* ptr) { std::cout &lt;&lt; &quot;由自定义删除器销毁...\\n&quot;; delete ptr; }); throw std::runtime_error(&quot;&quot;); // “p” 是普通指针的情况下此处就会泄漏 } catch (const std::exception&amp;) { std::cout &lt;&lt; &quot;捕获到异常\\n&quot;; } std::cout &lt;&lt; &quot;\\n&quot; &quot;5) 数组形式的 unique_ptr 演示\\n&quot;; { std::unique_ptr&lt;D[]&gt; p(new D[3]); } // “D::~D()” 被调用 3 次} std::shared_ptrstd::shared_ptr 是一种智能指针，它能够记录多少个 shared_ptr 共同指向一个对象，从而消除显式的调用 delete，当引用计数变为零的时候就会将对象自动删除。 使用make_shared&lt;T&gt;(T&amp;&amp;... args),通过传入一个对象（make_shared内使用了完美转发）来获取这个对象类型的shared_ptr指针。 std::shared_ptr 可以通过 get() 方法来获取原始指针，通过 reset() 来减少一个引用计数， 并通过use_count()来查看一个对象的引用计数。 std::shared_ptr 是一种通过指针保持对象共享所有权的智能指针。多个 shared_ptr 对象可持有同一对象。下列情况之一出现时销毁对象并解分配其内存： 最后剩下的持有对象的 shared_ptr 被销毁； 最后剩下的持有对象的 shared_ptr 被通过 operator= 或 reset() 赋值为另一指针。 但是在下面代码，存在着内存泄漏的问题： 1234567891011121314151617181920212223#include &lt;memory&gt;#include &lt;iostream&gt;struct A;struct B;struct A { std::shared_ptr&lt;B&gt; pointer; ~A() { std::cout &lt;&lt; &quot;A 被销毁&quot; &lt;&lt; std::endl; }};struct B { std::shared_ptr&lt;A&gt; pointer; ~B() { std::cout &lt;&lt; &quot;B 被销毁&quot; &lt;&lt; std::endl; }};int main() { auto a = std::make_shared&lt;A&gt;(); auto b = std::make_shared&lt;B&gt;(); a-&gt;pointer = b; b-&gt;pointer = a;}//离开作用域的时候，std::shared_ptr都会被析构，但是Control block中的引用计数不为0，导致对象没有被析构从而引发内存泄漏 std::weak_ptrstd::weak_ptr 是一种智能指针，它持有被 std::shared_ptr 管理的对象的非拥有性“弱”引用。在访问引用的对象前必须先转换为 std::shared_ptr。（使用lock()） weak_ptr不持有对象的生命周期，不算入引用计数 但是可以用weak_ptr判断对象是否过期 std::weak_ptr 实现临时所有权：当某个对象只有存在时才需要被访问，且随时可能被他人删除时，可以使用 std::weak_ptr 来跟踪该对象，需要获得临时所有权时，将其转换为 std::shared_ptr。如果此时销毁了原始 std::shared_ptr，则对象的生命周期将被延长，直到临时 std::shared_ptr 也被销毁为止。 123456789101112131415161718192021222324252627282930#include &lt;memory&gt;#include &lt;iostream&gt;struct A;struct B;struct A { std::shared_ptr&lt;B&gt; pointer; void print() { std::cout &lt;&lt; &quot;A&quot; &lt;&lt;std::endl; } ~A() { std::cout &lt;&lt; &quot;A 被销毁&quot; &lt;&lt; std::endl; }};struct B { std::weak_ptr&lt;A&gt; pointer; void print() { std::cout &lt;&lt; &quot;B&quot; &lt;&lt;std::endl; } ~B() { std::cout &lt;&lt; &quot;B 被销毁&quot; &lt;&lt; std::endl; }};int main() { auto a = std::make_shared&lt;A&gt;(); auto b = std::make_shared&lt;B&gt;(); a-&gt;pointer-&gt;print(); //b-&gt;pointer-&gt;print(); error: base operand of '-&gt;' has non-pointer type 'std::weak_ptr&lt;A&gt;' b-&gt;pointer.lock()-&gt;print();} 引用计数的实现在cpp中，使用shared_ptr的时候，编译器会创建一个Control Block，控制块的实现思想主要是通过封装 引用计数 和 删除器 来确保对象的生命周期由多个智能指针共享时，能够安全、有效地管理资源的分配和释放。 控制块的概念 控制块是一个管理 shared_ptr 引用计数和其他元数据的结构。它包含了： 强引用计数（use_count）：追踪有多少个 shared_ptr 实例引用了这个对象。 弱引用计数（weak_count）：追踪有多少个 weak_ptr 引用了该对象，确保只有所有强引用计数为零时，控制块才会被销毁。 删除器（deleter）：负责销毁被管理的对象。当引用计数归零时，删除器会被调用来销毁对象。 分配器（allocator）：如果 shared_ptr 使用了自定义分配器，控制块也会包含该分配器的状态。 控制块的结构设计 控制块通常是一个独立的结构体或类，它和被管理对象的内存分开存储。这样设计的好处是能确保内存和对象的生命周期是独立管理的，避免了直接将对象和引用计数存在同一块内存中可能导致的效率问题。 下面是一个简单的control block的实现 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190#ifndef SHARED_PTR_H#define SHARED_PTR_H#pragma once#include &lt;iostream&gt;#include &lt;functional&gt;#include &lt;memory&gt;#include &lt;stdexcept&gt;// Forward declarationtemplate &lt;typename T&gt;class shared_ptr;struct ControlBlock { size_t ref_count; void* ptr; std::function&lt;void(void*)&gt; deleter; ControlBlock() : ref_count(0), ptr(nullptr), deleter([](void*){}) {} ControlBlock(size_t ref_count, void* ptr) : ref_count(ref_count), ptr(ptr), deleter([](void* p) {}) {} ControlBlock(size_t ref_count, void* ptr, std::function&lt;void(void*)&gt; d) : ref_count(ref_count), ptr(ptr), deleter(std::move(d)) {} ~ControlBlock() = default;};template &lt;typename T&gt;class shared_ptr { ControlBlock* control_block; T* ptr; void release();public: // Constructors shared_ptr() noexcept : control_block(nullptr), ptr(nullptr) {} explicit shared_ptr(T* p); shared_ptr(const shared_ptr&amp; other) noexcept; shared_ptr(shared_ptr&amp;&amp; other) noexcept; template &lt;typename... Args&gt; static shared_ptr&lt;T&gt; make_shared(Args&amp;&amp;... args); // Destructor ~shared_ptr(); // Assignment operators shared_ptr&amp; operator=(const shared_ptr&amp; other) noexcept; shared_ptr&amp; operator=(shared_ptr&amp;&amp; other) noexcept; // Pointer operations T&amp; operator*() const; T* operator-&gt;() const; T* get() const noexcept; void reset(T* p = nullptr); [[nodiscard]] size_t use_count() const noexcept; // Type conversion explicit operator bool() const noexcept; // Swap two smart pointers void swap(shared_ptr&amp; other) noexcept; // Comparison operations bool operator==(const shared_ptr&amp; other) const noexcept; bool operator!=(const shared_ptr&amp; other) const noexcept;};template &lt;typename T&gt;shared_ptr&lt;T&gt;::shared_ptr(T* p) : control_block(new ControlBlock(1, p)), ptr(p) {}template &lt;typename T&gt;shared_ptr&lt;T&gt;::shared_ptr(const shared_ptr&amp; other) noexcept : control_block(other.control_block), ptr(other.ptr) { if (control_block) { control_block-&gt;ref_count++; }}template &lt;typename T&gt;shared_ptr&lt;T&gt;::shared_ptr(shared_ptr&amp;&amp; other) noexcept : control_block(other.control_block), ptr(other.ptr) { other.control_block = nullptr; other.ptr = nullptr;}template &lt;typename T&gt;template &lt;typename... Args&gt;shared_ptr&lt;T&gt; shared_ptr&lt;T&gt;::make_shared(Args&amp;&amp;... args) { return shared_ptr&lt;T&gt;(new T(std::forward&lt;Args&gt;(args)...));}template &lt;typename T&gt;shared_ptr&lt;T&gt;::~shared_ptr() { release();}template &lt;typename T&gt;void shared_ptr&lt;T&gt;::release() { if (control_block) { control_block-&gt;ref_count--; if (control_block-&gt;ref_count == 0) { if (ptr) { control_block-&gt;deleter(ptr); } delete control_block; } }}template &lt;typename T&gt;shared_ptr&lt;T&gt;&amp; shared_ptr&lt;T&gt;::operator=(const shared_ptr&amp; other) noexcept { if (this != &amp;other) { release(); control_block = other.control_block; ptr = other.ptr; if (control_block) { control_block-&gt;ref_count++; } } return *this;}template &lt;typename T&gt;shared_ptr&lt;T&gt;&amp; shared_ptr&lt;T&gt;::operator=(shared_ptr&amp;&amp; other) noexcept { if (this != &amp;other) { release(); control_block = other.control_block; ptr = other.ptr; other.control_block = nullptr; other.ptr = nullptr; } return *this;}template &lt;typename T&gt;T&amp; shared_ptr&lt;T&gt;::operator*() const { // Dereference operator if (ptr == nullptr) { throw std::runtime_error(&quot;Attempting to dereference a null pointer&quot;); } return *ptr;}template &lt;typename T&gt;T* shared_ptr&lt;T&gt;::operator-&gt;() const { // Arrow operator for accessing members return ptr;}template &lt;typename T&gt;T* shared_ptr&lt;T&gt;::get() const noexcept { return ptr;}template &lt;typename T&gt;void shared_ptr&lt;T&gt;::reset(T* p) { release(); ptr = p; control_block = new ControlBlock(1, p, [](void* p) { delete static_cast&lt;T*&gt;(p); });}template &lt;typename T&gt;size_t shared_ptr&lt;T&gt;::use_count() const noexcept { if(control_block) { return control_block-&gt;ref_count; } return 0;}template &lt;typename T&gt;bool shared_ptr&lt;T&gt;::operator==(const shared_ptr&amp; other) const noexcept { return ptr == other.ptr;}template &lt;typename T&gt;bool shared_ptr&lt;T&gt;::operator!=(const shared_ptr&amp; other) const noexcept { return ptr != other.ptr;}template &lt;typename T&gt;shared_ptr&lt;T&gt;::operator bool() const noexcept { return ptr != nullptr;}template &lt;typename T&gt;void shared_ptr&lt;T&gt;::swap(shared_ptr&amp; other) noexcept { std::swap(control_block, other.control_block); std::swap(ptr, other.ptr);}#endif //SHARED_PTR_H","link":"/2025/05/02/C++%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88%E5%92%8C%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/"},{"title":"C++编译与内存相关","text":"1.cpp文件从解析到执行发生了什么？ 预处理：.cpp文件经过预处理生成文本文件.i格式的文件。在这个过程中，对原始的cpp文件中删除注释，展开宏等等。以方便进行下一步处理 编译+汇编：依据在预处理阶段生成的.i文件，进行词法、语法分析和语义检查，之后使用机器字进行替代，转为由汇编语言组成的.o文件 链接：根据编译阶段生成的.o文件，以及静态链接库.a或者动态链接库.so。这由链接方式决定。将.o文件和其执行所需要的库文件进行链接，生成最终的可执行文件。此时也是在这个阶段，.o文件被组合为一个单独的可执行文件，并且生成一个ELF格式的文件。这个ELF文件包括了：可执行代码（.text段），数据（.data段），未初始化数据（.bss段），动态链接信息（如果需要），调试信息（如果启用）。**最终可执行文件的格式就是ELF文件。**ELF文件中保存的内容是编译后运行前生成的内容 加载：在程序执行时，操作系统的加载器会将ELF文件加载到内存中。加载器会根据ELF文件的头部信息（如程序头表和节区头表）确定各个段（如 .text、.data等）的内存位置，并将它们加载到内存中。随后，程序开始执行。 2.函数调用过程中内存发生了什么？现有如下代码： 12345678910void foo(int a) { int b = a + 1; // 函数执行完毕}int main() { int x = 10; foo(x); // 调用foo函数 return 0;} 栈帧： 栈帧是每个函数调用时在栈中分配的内存区域，它包含了函数的返回地址、调用者的栈帧指针、局部变量、参数等信息。栈帧的管理是栈内存结构的核心，每次发生新的函数调用，都会由新的栈帧被创建。通常存在寄存器 %rbp中 栈顶： 栈顶指向的是栈内存顶部的区域，它是栈中当前活动的地址位置。通常存在寄存器 %rsp中 发生函数调用时：首先新创建一个新的栈帧，然后将调用者调用的函数结束后的下一条指令的地址压入栈中（返回地址）。然后在将调用者的栈帧的栈指针压入栈中，以及一些上下文的寄存器状态。之后在从右到左依次向栈中压入函数参数，之后在压入一些局部变量。遵循着这样的顺序。 3.申请堆内存产生的内存碎片 由于程序申请堆内存空间是动态的，而堆内存的管理是操作系统或者内存管理程序分配或者回收的，因此不可避免的会产生内存碎片。 如何解决内存碎片： 内存池技术：提前分配好内存，用内存池来管理 垃圾回收机制：标记和整理内存来回收未使用的内存，以此来减少碎片 最佳适配算法：动态分配时选择最适合需求大小的内存块，避免过多的小碎片 合并内存空间：释放内存时，尝试将相邻的空闲内存块合并成更大的块 4.CPP的内存对齐 每种数据类型都有一个对齐要求，即它的起始地址必须是该对齐值的倍数。 要求内存对其可以减少访问内存的延时，来提升性能。 5.智能指针的介绍与使用 std::unique_ptr:是一种独占式的智能指针，意味着同一时刻只能有一个 unique_ptr 指向某个对象。同时 unique_ptr不允许赋值，只能通过 std::move转移所有权。当独占式指针超出作用域后，会自动销毁。 std::share_ptr:是一种共享的只能指针，多个 shared_ptr 可以共同拥有同一个对象，智能指针内部会使用引用计数来追踪有多少 shared_ptr 指向同一个对象。当这个引用计数为0的时候，就会释放掉共享指针 std::weak_ptr：是一种弱指针，std::weak_ptr 不影响对象的引用计数，它用于观察一个由 shared_ptr 管理的对象。用于避免由于循环引用（指两个struct中互相有指针互相引用，导致互相持有无法释放，用 weak_ptr就可以解决这个问题）导致 shared_ptr无法释放 总结：std::unique_ptr通过判断在不在作用域来销毁，而 std::share_ptr通过内部的引用计数来判断是否需要销毁。 在使用智能指针的时候，尽量避免手动new，这样会需要两次手动内存分配 6.大端与小端 大端存储：高字节在高位，符合人类手写习惯。适用于网络通讯协议 小端存储：低字节在低位，更适合计算机的运算。常见于x86_64机器 7.内存泄漏 内存泄漏：指的是程序动态分配的内存未被释放，导致内存长期占用，最终可能导致内存耗尽、程序崩溃等问题。比如new了一个堆空间，但是一直没有delete 如何避免内存泄漏： 避免手动管理内存，使用智能指针（C++） 使用 RAII 资源管理（C++）：将资源（内存、文件、锁、数据库连接等）与对象的生命周期绑定，确保资源在对象销毁时自动释放，防止资源泄漏。 解决循环引用问题和避免悬垂指针 8.include include “ “和include&lt;&gt;的区别：include “ “首先从当前源文件所在目录或用户指定的目录中搜索头文件，如果找不到，则去库文件中寻找。而include&lt;&gt;则是直接去库文件中寻找对应的头文件","link":"/2025/05/02/C++%E7%BC%96%E8%AF%91%E4%B8%8E%E5%86%85%E5%AD%98%E7%9B%B8%E5%85%B3/"},{"title":"","text":"1.并行基础 std::thread：比较原始的多线程使用方法，在申明的时候传入 std::jthread","link":"/2025/05/02/C++%E5%B9%B6%E8%A1%8C%E5%92%8C%E5%B9%B6%E5%8F%91/"},{"title":"C++语言特性相关","text":"1.左值引用右值引用左值（Lvalue，Locator Value）指的是可以被取地址的值，即在表达式结束后仍然存在的对象。例如，变量、数组元素、对象等都是左值。 左值引用用于绑定左值，并且通常用于传递和修改可变对象。 123int a = 10;int&amp; ref = a; // ref 绑定到 aref = 20; // 修改 ref 也会影响 a 右值（Rvalue，Right-hand value）指的是无法取地址的临时值，通常是表达式计算的结果，如字面量、临时变量等。 右值引用使用 &amp;&amp; 语法，用于绑定右值，使得右值可以被高效地移动，而不是复制。 12int&amp;&amp; rref = 10; // 10 是右值，可以绑定到右值引用std::cout &lt;&lt; rref &lt;&lt; std::endl; // 输出 10 左值引用 vs 右值引用 左值引用 &amp; 右值引用 &amp;&amp; 绑定对象 只能绑定左值 只能绑定右值 修改对象 可以修改 可以修改 适用场景 传递可变对象 移动语义、避免拷贝 常见用法 普通变量引用、函数参数 移动构造、移动赋值 2.左值引用和右值引用的转化 std::move():是一个转换工具，用于将左值强制转换为右值，从而触发移动语义 std::forward&lt;T&gt;():主要用于泛型编程，保证在模板参数传递时，保留左右值的原始属性，实现完美转发。 std::move_if_noexcept():在某些情况下，如果移动构造可能抛出异常，我们可能更希望使用拷贝构造。std::move_if_noexcept 可用于这种情况 3.指针的大小与用法 指针的大小和编译器的目标平台的位数，而与所指向的数据类型无关。如果是32位的机器，则指针的大小则是4Byte，如果是64位机器，那么指针的大小是8Byte。 指针存储变量的内存地址，使用 &amp; 获取地址，使用 * 解引用指针以访问数据。 指针作为函数参数：实现传址调用，允许函数直接修改原始数据。函数指针：用于回调机制或策略模式等 4.指针和引用的区别总结对比表 特性 指针 引用 是否需要初始化 不需要，可以为空 必须初始化 是否能重新指向 可以 不可以 是否可为空 可以指向 nullptr 不可以 是否有独立内存 是，占用内存存储地址 否，与原变量共用内存 是否可修改值 通过 * 解引用后可修改 可修改（除非 const 修饰） 典型应用场景 动态内存分配、数据结构 参数传递、引用更安全的别名 5.指针常量和常量指针常量指针（const T*）：指向的值不能修改，但指针本身的指向可以更改。（即只能读，不能修改） 指针常量（T* const）：指针本身的指向不能更改，但指向的值可以修改。 6.函数指针的定义函数指针 (Function Pointer) 是指向函数的地址的指针。与普通指针不同，函数指针指向的是可执行代码段中的函数入口地址，而非数据 函数指针的基本语法 定义函数指针的一般形式为： 1返回类型 (*指针变量名)(参数类型列表); 7.CPP中函数传递参数的方法在 C++ 中，函数传递参数的方式主要有以下几种： 值传递（Pass by Value） 形参是实参的副本，在函数内对参数的修改不会影响原始数据。 适用于基本数据类型，但对于大对象会导致不必要的拷贝开销。 1void func(int x) { x = 10; } 引用传递（Pass by Reference） 形参是实参的引用，函数内的修改会直接影响原始数据。 适用于需要修改参数的情况，或者避免拷贝大对象以提升效率。 1void func(int&amp; x) { x = 10; } 指针传递（Pass by Pointer） 形参是指向实参的指针，可以在函数内修改原数据。 需要检查指针是否为空，避免空指针访问错误。 1void func(int* x) { if (x) *x = 10; } 常量引用传递（Pass by Const Reference） 适用于大对象的只读传递，既避免了拷贝，又保证了数据不会被修改。 1void func(const std::string&amp; str) { std::cout &lt;&lt; str; } 右值引用传递（Pass by Rvalue Reference）（C++11及以上） 允许传递右值（临时对象），通常用于移动语义（move semantics），提高效率。 1void func(std::string&amp;&amp; str) { std::cout &lt;&lt; str; } 智能指针传递（Pass by Smart Pointer）（C++11及以上） 通过 std::shared_ptr 或 std::unique_ptr 传递对象，管理内存生命周期。 1void func(std::shared_ptr&lt;int&gt; ptr) { std::cout &lt;&lt; *ptr; } 不同的方式适用于不同的场景，应根据性能需求和数据安全性来选择合适的参数传递方式。 8.迭代器迭代器（Iterator）是 C++ STL（标准模板库） 中用于遍历容器（如 vector、list、map 等）的一种通用接口。迭代器提供了一种类似指针的方式来访问容器中的元素，同时又能适应不同类型的容器。 C++ 提供了 五种迭代器，分别适用于不同类型的容器和操作： 迭代器类型 说明 适用容器 输入迭代器 (InputIterator) 只能 从前向后读取 数据 istream_iterator 输出迭代器 (OutputIterator) 只能 向前写入 数据 ostream_iterator 前向迭代器 (ForwardIterator) 可读可写，可单向移动 forward_list 双向迭代器 (BidirectionalIterator) 可读可写，可双向移动 list、map、set 随机访问迭代器 (RandomAccessIterator) 可读可写，可随机跳转 vector、deque 常见 STL 容器的迭代器 容器 begin() end() 迭代器类型 vector vector&lt;int&gt;::iterator vector&lt;int&gt;::iterator 随机访问 list list&lt;int&gt;::iterator list&lt;int&gt;::iterator 双向 map map&lt;int, int&gt;::iterator map&lt;int, int&gt;::iterator 双向 set set&lt;int&gt;::iterator set&lt;int&gt;::iterator 双向 9.野指针和悬空指针野指针 vs 悬空指针 类别 定义 产生原因 如何修正 野指针 未初始化的指针，指向未知地址 1. 没有初始化 2. 释放后未置空 3. 超出作用域 初始化指针为 nullptr 悬空指针 指向已释放的无效内存 1. 释放后仍然访问 2. 作用域结束后访问 3. 二次释放 释放后将指针置空 10.类型转化static_cast vs dynamic_cast 特性 static_cast dynamic_cast 转换时间 编译时 运行时 是否安全检查 ❌ 无检查 ✅ 运行时检查 适用范围 基本类型、多态类型、void* 仅适用于多态类型 转换失败时 未定义行为 返回 nullptr（指针）/ 抛异常（引用） 速度 ⚡ 高效 🐢 慢（因运行时检查） 四种转换方式对比 转换类型 转换方式 运行时检查 适用范围 推荐使用情况 static_cast 编译时转换 ❌ 无 兼容类型转换 ✅ 用于安全转换，如 int → double dynamic_cast 运行时转换 ✅ 有 多态类型（有虚函数） ✅ 适用于父子类转换，确保安全 const_cast 移除/添加 const ❌ 无 指针/引用 ✅ 需要修改 const 变量时 reinterpret_cast 低级转换 ❌ 无 指针/整数/位级转换 ⚠️ 极少使用，仅用于底层编程","link":"/2025/02/25/C++%E8%AF%AD%E8%A8%80%E7%89%B9%E6%80%A7%E7%9B%B8%E5%85%B3/"},{"title":"C++语言运行期的强化","text":"lambda表达式 基础：lambda表达式的基本语法如下： 123[捕获列表](参数列表) mutable(可选) 异常属性 -&gt; 返回类型 {// 函数体} 在其中，捕获列表起到了传递外部数据的作用，根据传递的行为，捕获列表可以分为以下几种： 值捕获：与参数传值类似，值捕获的前提是变量可以拷贝，不同之处则在于，被捕获的变量在 Lambda 表达式被创建时拷贝， 而非调用时才拷贝。（在Lambda表达式被传建的时候，会对捕获的变量保存一个内部的拷贝，在修改捕获变量的值不会影响结果） 1234567891011void lambda_value_capture() { int value = 1; auto copy_value = [value] { return value; }; value = 100; auto stored_value = copy_value(); std::cout &lt;&lt; &quot;stored_value = &quot; &lt;&lt; stored_value &lt;&lt; std::endl; // 这时, stored_value == 1, 而 value == 100. // 因为 copy_value 在创建时就保存了一份 value 的拷贝} 引用捕获：引用捕获保存的是引用，获取最新的捕目标的值 1234567891011void lambda_reference_capture() { int value = 1; auto copy_value = [&amp;value] { return value; }; value = 100; auto stored_value = copy_value(); std::cout &lt;&lt; &quot;stored_value = &quot; &lt;&lt; stored_value &lt;&lt; std::endl; // 这时, stored_value == 100, value == 100. // 因为 copy_value 保存的是引用} 隐式捕获：让编译器自己去猜测要捕获的变量 [] 空捕获列表 [name1, name2, …] 捕获一系列变量 [&amp;] 引用捕获, 从函数体内的使用确定引用捕获列表 [=] 值捕获, 从函数体内的使用确定值捕获列表 函数对象包装器 std::function：std::function 是一种通用、多态的函数封装， 它的实例可以对任何可以调用的目标实体进行存储、复制和调用操作， 它也是对 C++ 中现有的可调用实体的一种类型安全的包裹（相对来说，函数指针的调用不是类型安全的）， 换句话说，就是函数的容器。 std::bind和 std::placeholder,std::bind 则是用来绑定函数调用的参数的， 它解决的需求是我们有时候可能并不一定能够一次性获得调用某个函数的全部参数，通过这个函数， 我们可以将部分调用参数提前绑定到函数身上成为一个新的对象，然后在参数齐全后，完成调用。而 std::placeholder则是占位函数，用于表明调用时用户来提供函数 123456789101112131415161718192021#include &lt;iostream&gt;#include &lt;functional&gt;class MyClass {public: void print(int x) { std::cout &lt;&lt; &quot;Value: &quot; &lt;&lt; x &lt;&lt; std::endl; }};int main() { MyClass obj; // 绑定成员函数，需要提供实例对象 auto boundFunc = std::bind(&amp;MyClass::print, &amp;obj, std::placeholders::_1); // 调用绑定的函数，相当于 obj.print(42) boundFunc(42); return 0;} 右值引用 左值：左值是表达式（不一定是赋值表达式）后依然存在的持久对象 右值：右值指表达式结束后就不再存在的临时对象 纯右值：纯粹的右值，要么是纯粹的字面量，例如 10, true； 要么是求值结果相当于字面量或匿名临时对象，例如 1+2。非引用返回的临时变量、运算表达式产生的临时变量、 原始字面量、Lambda 表达式都属于纯右值 将亡值：即将被销毁、却能够被移动的值 右值引用和左值引用: 要拿到一个将亡值，就需要用到右值引用：T &amp;&amp;，其中 T 是类型。 右值引用的声明让这个临时值的生命周期得以延长、只要变量还活着，那么将亡值将继续存活 1234567891011121314151617181920212223242526272829#include &lt;iostream&gt;#include &lt;string&gt;void reference(std::string&amp; str) { std::cout &lt;&lt; &quot;左值&quot; &lt;&lt; std::endl;}void reference(std::string&amp;&amp; str) { std::cout &lt;&lt; &quot;右值&quot; &lt;&lt; std::endl;}int main(){ std::string lv1 = &quot;string,&quot;; // lv1 是一个左值 // std::string&amp;&amp; r1 = lv1; // 非法, 右值引用不能引用左值 std::string&amp;&amp; rv1 = std::move(lv1); // 合法, std::move可以将左值转移为右值 std::cout &lt;&lt; rv1 &lt;&lt; std::endl; // string, const std::string&amp; lv2 = lv1 + lv1; // 合法, 常量左值引用能够延长临时变量的生命周期 // lv2 += &quot;Test&quot;; // 非法, 常量引用无法被修改 std::cout &lt;&lt; lv2 &lt;&lt; std::endl; // string,string, std::string&amp;&amp; rv2 = lv1 + lv2; // 合法, 右值引用延长临时对象生命周期 rv2 += &quot;Test&quot;; // 合法, 非常量引用能够修改临时变量 std::cout &lt;&lt; rv2 &lt;&lt; std::endl; // string,string,string,Test reference(rv2); // 输出左值 return 0;} 完美转发在作参数转发的时候，保证左值和右值可以被正确的传递 1234567891011121314151617181920212223242526272829#include &lt;iostream&gt;#include &lt;utility&gt;void reference(int&amp; v) { std::cout &lt;&lt; &quot;左值引用&quot; &lt;&lt; std::endl;}void reference(int&amp;&amp; v) { std::cout &lt;&lt; &quot;右值引用&quot; &lt;&lt; std::endl;}template &lt;typename T&gt;void pass(T&amp;&amp; v) { std::cout &lt;&lt; &quot; 普通传参: &quot;; reference(v); std::cout &lt;&lt; &quot; std::move 传参: &quot;; reference(std::move(v)); std::cout &lt;&lt; &quot; std::forward 传参: &quot;; reference(std::forward&lt;T&gt;(v)); std::cout &lt;&lt; &quot;static_cast&lt;T&amp;&amp;&gt; 传参: &quot;; reference(static_cast&lt;T&amp;&amp;&gt;(v));}int main() { std::cout &lt;&lt; &quot;传递右值:&quot; &lt;&lt; std::endl; pass(1); std::cout &lt;&lt; &quot;传递左值:&quot; &lt;&lt; std::endl; int v = 1; pass(v); return 0;} 无论传递参数为左值还是右值，普通传参都会将参数作为左值进行转发； 由于类似的原因，std::move 总会接受到一个左值，从而转发调用了 reference(int&amp;&amp;) 输出右值引用。 唯独 std::forward 即没有造成任何多余的拷贝，同时完美转发(传递)了函数的实参给了内部调用的其他函数","link":"/2025/05/02/C++%E8%AF%AD%E8%A8%80%E8%BF%90%E8%A1%8C%E6%9C%9F%E7%9A%84%E5%BC%BA%E5%8C%96/"},{"title":"用hexo+icarus搭建个人博客","text":"如何用Hexo+Icarus建立一个个人网站前置准备在开始建立个人网站前，需要安装以下工具： Node.js 和 npm 下载地址：Node.js官网 安装后，在终端运行以下命令验证安装成功：12node -vnpm -v Git 下载地址：Git官网 安装后，在终端运行以下命令验证安装成功：1git --version GitHub账号 如果你打算部署到GitHub Pages，需要一个GitHub账号 注册地址：GitHub 安装Hexo 全局安装Hexo-CLI 1npm install -g hexo-cli 创建Hexo项目 123hexo init my-blogcd my-blognpm install 安装必要的插件 12npm install hexo-renderer-inferno --savenpm install hexo-deployer-git --save 安装Icarus主题 安装Icarus主题 1npm install hexo-theme-icarus --save 启用Icarus主题 在根目录下的 _config.yml中修改主题设置：1theme: icarus 或者使用以下命令自动创建主题配置文件：1hexo config theme icarus 个性化配置基本配置 修改 _config.yml文件 站点名称、作者、URL等基本信息 1234567title: 你的网站标题subtitle: '副标题'description: '网站描述'keywords: 关键词author: 你的名字language: zh-CNtimezone: 'Asia/Shanghai' 配置部署信息 ==注意，这里的repo必须为github仓库中以github.io结尾的仓库名字== 1234deploy: type: git repo: git@github.com:用户名/用户名.github.io.git branch: master Icarus主题配置 修改 _config.icarus.yml文件 ==注意，在publish文件下的内容全部是自动生成的内容，对这个文件下的内容做的所有修改都是无效的。以及所有_config.icarus.yml中的相对寻址路径都是在public下去寻找的。如果要添加自己的图片，请在source下新建img文件，放入图片，你会在publish对应的文件夹下面看见你放入的文件。更多详情请见icarus和hexo的官方文档== 配置网站logo和图标 123logo: /img/logo.svghead: favicon: /img/favicon.svg #在public下的img文件夹中去寻找图标 配置导航菜单 1234567navbar: menu: 首页: / 归档: /archives 分类: /categories 标签: /tags 关于: /about 配置侧边栏 12345678910111213141516171819202122232425262728sidebar: left: sticky: true right: sticky: truewidgets: - position: left type: profile author: 你的名字 author_title: 你的职位 location: 你的位置 avatar: /img/avatar.jpg - position: left type: toc - position: left type: categories - position: left type: recent_posts - position: left type: archives - position: left type: tags 调整主栏宽度 如果想让主栏更宽，可以将所有widget放在同一侧（如左侧）。可以参考常见问题 - Icarus (ppoffice.github.io) 配置Gitalk评论系统 如果你没有有自己的OAuth应用：注册GitHub OAuth应用 访问 https://github.com/settings/applications/new 填写应用名称（如”博客评论”） 主页URL：你的博客地址 回调URL：与主页URL相同 点击”Register application” 如果你已经有自己的OAuth应用：查看已创建的OAuth应用 GitHub头像 -&gt; Settings -&gt; Developer settings -&gt; OAuth Apps 配置Gitalk 在 _config.icarus.yml中添加： 12345678comment: type: gitalk client_id: 你的client_id client_secret: 你的client_secret repo: 用户名.github.io owner: GitHub用户名 admin: - GitHub用户名 初始化评论 部署网站后，以管理员身份登录并访问每篇文章，初始化对应的GitHub Issue 创建内容 创建新文章 1hexo new &quot;文章标题&quot; 文章格式 123456789101112131415---title: 文章标题date: 2023-03-18categories: - 分类1 - 分类2tags: - 标签1 - 标签2excerpt: 这是文章摘要，会显示在首页。---&lt;!-- more --&gt;这里是文章正文内容... 本地预览 启动本地服务器 1hexo server 访问本地预览 浏览器打开 http://localhost:4000 部署网站 生成静态文件 12hexo clean hexo generate #或者直接 hexo g 部署到GitHub Pages 1hexo deploy #或者直接 hexo d 自定义域名（可选） 在 source目录下创建 CNAME文件，内容为你的域名 在域名提供商处设置DNS解析到GitHub Pages 常见问题解决 主题配置问题 确保YAML格式正确，注意缩进 使用在线YAML验证工具检查格式 图片显示问题 将图片放在 source/img/目录下 路径使用 /img/图片名.jpg Gitalk初始化问题 确保client_id和client_secret正确 检查repo名称是否正确 需要管理员登录GitHub并访问文章页面初始化评论 参考资源 Hexo官方文档 Icarus主题文档 Gitalk文档","link":"/2025/05/02/%E7%94%A8hexo+icarus%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/"},{"title":"C++面向对象","text":"1.面向对象的三大特性：封装，继承，多态 2.重载、**重写 和 **隐藏 对比项 重载（Overloading） 重写（Overriding） 隐藏（Hiding） 作用域 同一个类 继承体系（子类 vs. 父类） 继承体系（子类 vs. 父类） 函数名 相同 相同 相同 参数列表 必须不同 必须相同 可相同或不同 返回类型 可以不同，但不影响重载 不能改变（C++11 允许协变返回类型） 可以不同 访问方式 直接调用 通过基类指针或引用调用 直接调用 虚函数 无关 必须是 virtual 无关 影响 编译期选择不同方法 运行时调用子类方法（动态绑定） 隐藏父类同名方法，必须使用 Base::func() 访问 重载（Overloading） 发生在同一个类，参数不同，返回值可以不同，属于编译期多态。 重写（Overriding） 发生在继承体系，子类重写基类的虚函数，必须函数签名（用于在重载时标识不同的函数）一致，属于运行时多态。 隐藏（Hiding） 发生在继承体系，但不是虚函数重写，而是子类定义了同名函数，隐藏了父类版本，调用父类方法需要 Base::func()。 在实践中，虚函数重写是 OOP 里最重要的特性，它允许多态行为，而隐藏可能导致代码难以维护，因此建议避免让子类的方法隐藏父类的方法，除非有特殊需求。 3.多态及其实现办法 多态分为运行时多态（通过虚函数实现）和编译时多态（通过函数重载和模板实现）。 运行时多态执行的核心步骤 （运行时多态，虚函数必须为 virtual,否则可能会引起内存泄漏） 对象构造时初始化虚函数指针（vptr，存储在对象的实例内存中） 当对象被构造时，编译器会隐式地在对象内存中插入一个指向**虚函数表（vtable）**的指针（vptr）。 vptr 的值由对象的实际类型决定。例如： Base 类型的对象，vptr 指向 Base 的虚函数表。 Derived 类型的对象，vptr 指向 Derived 的虚函数表。 虚函数表（vtable）的结构 （存储在只读数据段中，并且全局唯一） 每个有虚函数的类都有一个对应的虚函数表（静态存储区）。 虚函数表是一个函数指针数组，每个条目指向该类的虚函数实现。 若派生类覆盖了基类的虚函数，则虚函数表中对应的条目会被替换为派生类的函数地址。 通过基类指针或引用调用虚函数 当通过基类指针或引用调用虚函数时，编译器会生成代码： 从对象的 vptr 找到对应的虚函数表。 根据虚函数在表中的索引（由编译器确定）找到函数地址。 调用该函数地址指向的实现。 4.虚函数和纯虚函数在虚函数中，基类需要提供默认实现，并且基类是可以实例化的。但是在纯虚函数中，基类不提供实现（但是可以定义，但是使用必须显示的使用），同时基类不允许被实例化，并且派生类必须覆盖，要给出纯虚函数的实现，否则仍然是抽象类。（只要类中有一个纯虚函数，那么这个类就不能被初始化） 纯虚函数更多的应用在接口之中，来实现接口和实现的分离，充分体现面向对象的特性。此外，纯虚函数也和虚函数一样，要指定虚构函数，并且为`virtual` 为什么纯虚类的构造函数必须是`virtual`的：因为多态对象的析构是从派生类开始到基类结束的，只有这样才能保证内存被正确的释放。在析构时，需要动态调用来保证资源的全部释放。 5.多继承在 CPP中，与 Java不同的一点是 CPP允许多继承。 123class Derived : public Base1, public Base2 { // ...}; 但是在多继承中，常见的问题是二义性问题，和棱形问题 菱形问题： 当一个派生类从两个或多个基类继承，而这些基类又共同继承自同一个基类时，会导致二义性 和数据冗余 。用虚继承可以解决这个问题 二义性问题： 如果多个基类有同名成员，直接访问会引发编译错误。用显式指定基类的作用域可以解决这个问题。 6.深拷贝和浅拷贝 深拷贝：会重新复制内容并且分配内存，并且每个对象独立管理其对应的内存（类似于 unique_ptr） 浅拷贝：只会复制指针的地址，并且多个对象共享同一块内存。但是可能会导致double free，悬垂指针的问题。 此外资源管理类 必须遵循”Rule of Three “： 如果定义了析构函数、拷贝构造函数或赋值运算符中的任意一个，通常需定义全部三个 7.Base* ptr = new Derived()的一些理解 首先是Base* ptr，这表明ptr是静态类型Base*,并且是保存在栈空间上的 然后ptr指向的是堆空间上的Derive()对象。这表明动态类型是Derived() 这里，由于Derived是继承的Base，因此在Derived的堆空间中，结构是这样的（如果Base有虚函数），同时Base中的属性也会被继承下来（无论是否private）只不过在Derived中无法访问。 12345678堆上的 Derived 对象：+------------------+| vptr(指向Derived) |+------------------+| base_data |+------------------+| derived_data |+------------------+ 注意，这里的Base* ptr只能访问Base类中的属性和方法。当访问Base中的虚函数时，编译器会因为访问虚函数，因此触发动态调用，使用虚函数表指针去虚函数表中寻找 8.单继承和多继承的虚函数表单继承 只有 1 张 vtable，对象中只有 1 个 vptr。 调用虚函数时，vptr 访问 vtable，跳转到函数地址。 多继承 每个 Base 类有独立的 vtable，Derived 有多个 vptr。 访问 Base1 相关函数时，走 vptr1 → vtable_for_Base1。 访问 Base2 相关函数时，走 vptr2 → vtable_for_Base2。 9.如何禁止构造函数的使用 方法 适用场景 是否允许子类实例化 = delete 彻底禁止构造 ❌ private 构造函数 外部不能创建对象，但 friend 可创建 ❌ protected 构造函数 允许子类创建对象，但基类不可实例化 ✅ static 方法 通过 static 方法创建对象（单例模式） ❌ 抽象类（纯虚函数） 作为基类强制继承 ✅ 10.什么是默认构造函数默认构造函数是没有参数或所有参数都有默认值的构造函数。如果程序员没有显式定义构造函数，编译器会自动提供一个默认构造函数。 没有参数 或者 所有参数都有默认值。 用于创建对象时自动调用，初始化对象的成员变量。 如果没有显式定义，编译器会自动生成一个（但不会初始化成员变量）。 如果定义了其它带参数的构造函数，编译器不会再提供默认构造函数（C++11 之后）。 11.如何提高构造函数的效率使用成员初始化列表构造效率最高的原因：避免了默认构造和赋值的双重开销，而是直接调用构造函数 1234567891011class Example { std::string s;public: // 初始化列表：直接调用 std::string 的构造函数 Example() : s(&quot;Hello&quot;) {} // 构造函数体内赋值：先默认构造 s，再赋值 Example() { s = &quot;Hello&quot;; // 生成临时字符串对象，再赋值给 s }}; 优势从上面就显而易见 优化方法 适用场景 优化点 使用成员初始化列表 =&gt; A() : x(10), y(3.14) {} 成员变量的初始化 避免默认构造 + 赋值 避免不必要的构造 =&gt; void foo(A a) { } // ❌ void foo(const A&amp; a) { } // ✅ 传参、返回值 传引用、RVO 优化 使用 explicit 防止隐式转换 避免额外构造 避免 new 动态分配 资源管理 使用栈分配或智能指针 优化容器初始化 std::vector 等容器 直接初始化，避免扩容 使用 = default 编译器优化 让编译器自动优化 使用 std::move 资源移动优化 避免不必要的拷贝 12.类对象初始化顺序首先按照继承的顺序进行基类的初始化 –&gt; 然后按照成员变量的申明顺序初始化，和构造函数初始化列表中的顺序无关 –&gt; 然后进行构造函数体的执行 构造函数初始化列表指的是： 123Derived() : m2(&quot;m2&quot;), m1(&quot;m1&quot;) { // 初始化列表顺序：m2 → m1（实际顺序仍按声明） cout &lt;&lt; &quot;Derived constructor\\n&quot;;} 13.友元函数的作用和使用场景 运算符重载：当需要重载 &lt;&lt;或者 &gt;&gt;的时候，由于左操作数是 ostream 或 istream 跨类访问私有成员 工具函数需要访问私有数据 需要注意的是： 友元函数的注意事项 破坏封装性友元函数会暴露类的内部实现，需谨慎使用，避免过度依赖。 友元关系不可传递若类 A 是类 B 的友元，类 B 是类 C 的友元，类 A 不会自动成为 类 C 的友元。 友元声明的位置友元函数的声明必须出现在类的内部（通常在 public 或 private 区域，但权限不影响友元的访问能力）。 友元函数不是成员函数 友元函数不属于类的成员，没有 this 指针。 调用时直接通过函数名，而非对象（如 exchange(a, b)）。 友元类可以将整个类声明为友元： 123class A { friend class B; // 类 B 的所有成员函数都可以访问 A 的私有成员}; 14.静态绑定和动态绑定 绑定时机 编译时 运行时 函数类型 非虚函数、重载函数、模板函数 虚函数（virtual functions） 性能 无额外开销 需查虚函数表，有轻微开销 灵活性 固定，无法动态改变行为 灵活，支持多态 15.cpp模板编程C++ 模板编程是泛型编程的核心技术，允许你编写与类型无关的通用代码。模板编程也是一种多态 函数模板：用于创建通用函数，自动推导参数类型 类模板：用于创建通用类（如容器） 模板特化：为特定类型提供定制化实现 模板元编程：在编译期执行计算，例如计算阶乘 12345678910template &lt;int N&gt;struct Factorial { static const int value = N * Factorial&lt;N-1&gt;::value;};template &lt;&gt;struct Factorial&lt;0&gt; { // 终止条件 static const int value = 1;};// 使用std::cout &lt;&lt; Factorial&lt;5&gt;::value; // 输出 120（编译期计算） 16.如何避免不必要的拷贝来提高效率 使用引用或者指针来传递值 -&gt; 避免不必要的大型对象拷贝 针对资源管理类使用 std::move来移动所属权 尽可能的避免使用临时对象 17.实例化一个对象需要哪几个阶段 阶段 描述 1. 分配内存 在栈上或堆上分配存储空间 2. 调用构造函数 初始化对象、调用基类构造函数 3. 执行初始化 初始化成员变量，拷贝/移动构造等 4. 使用对象 调用方法、访问成员变量 5. 调用析构函数 释放资源，执行清理操作 对象的实例化并不仅仅是构造函数的调用，而是一个完整的生命周期管理过程 18.如何让类中的函数无法访问类的成员变量 方法 是否能访问成员变量 适用场景 static 成员函数 ❌ 无法访问 工具类、无状态函数 内部 private 类 ❌ 无法访问 数据封装，防止误操作 PIMPL 设计模式 ❌ 无法访问 API 设计，隐藏实现细节 friend 友元类 ✅ 友元可访问 需要控制访问权限 如果目标是让类的普通成员函数无法访问数据成员，最佳方案是使用 static 方法 或 隐藏数据（PIMPL、内部类）。 19.怎么限制类的对象只能创建在栈上或者堆上 限制在堆上： 将构造函数以及析构函数设为私有，同时提供一个静态的工厂函数用来返回在堆上创建的对象。（注意，这样做必须要手动释放堆空间，调用delete()直接delete this即可） 限制在栈上： 删除 new和 delete关键字，来禁止在堆上创建 12void* operator new(size_t) = delete; // 禁止 newvoid operator delete(void*) = delete; // 禁止 delete 20.类的默认私有继承和公有继承在继承中，父类的所有属性和操作都会被继承到子类中，但是由于继承的默认是私有继承，导致无法直接访问父类的方法。（在下面的代码中，如果是 class Test : Derived那么Test的实例t无法直接调用 t.Derived::foo()）。而在类中的 private,protected,public修饰的操作或者属性，仅仅用于类的不同访问者的访问权限。 123456789101112131415161718192021222324252627282930313233#include &lt;iostream&gt;using namespace std;class Base {public: virtual void foo() = 0; virtual void bar() = 0; virtual ~Base() = default;};class Derived : Base { // 需要 public 继承public: void foo() override { // override 关键字增强可读性 cout &lt;&lt; &quot;Derived::foo&quot; &lt;&lt; endl; } void bar() final { // 需要 override 来表明继承自 Base cout &lt;&lt; &quot;Derived::bar&quot; &lt;&lt; endl; }};class Test : public Derived{ // 需要 public 继承public: void foo() override { cout &lt;&lt; &quot;Test::foo&quot; &lt;&lt; endl; }};int main() { Derived d; d.foo(); d.bar(); Test t; t.foo(); t.Derived::foo(); // 这行仍然是合法的，但没有必要 return 0;}","link":"/2025/02/25/C++%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"}],"tags":[{"name":"C++","slug":"C","link":"/tags/C/"},{"name":"关键字","slug":"关键字","link":"/tags/%E5%85%B3%E9%94%AE%E5%AD%97/"},{"name":"sizeof","slug":"sizeof","link":"/tags/sizeof/"},{"name":"const","slug":"const","link":"/tags/const/"},{"name":"static","slug":"static","link":"/tags/static/"},{"name":"volatile","slug":"volatile","link":"/tags/volatile/"},{"name":"Template","slug":"Template","link":"/tags/Template/"},{"name":"RAII","slug":"RAII","link":"/tags/RAII/"},{"name":"shared_ptr","slug":"shared-ptr","link":"/tags/shared-ptr/"},{"name":"内存管理","slug":"内存管理","link":"/tags/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/"},{"name":"编译原理","slug":"编译原理","link":"/tags/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/"},{"name":"性能优化","slug":"性能优化","link":"/tags/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"},{"name":"左值右值","slug":"左值右值","link":"/tags/%E5%B7%A6%E5%80%BC%E5%8F%B3%E5%80%BC/"},{"name":"引用","slug":"引用","link":"/tags/%E5%BC%95%E7%94%A8/"},{"name":"模板","slug":"模板","link":"/tags/%E6%A8%A1%E6%9D%BF/"},{"name":"语言特性","slug":"语言特性","link":"/tags/%E8%AF%AD%E8%A8%80%E7%89%B9%E6%80%A7/"},{"name":"lambda表达式","slug":"lambda表达式","link":"/tags/lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F/"},{"name":"并发编程","slug":"并发编程","link":"/tags/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"},{"name":"运行时特性","slug":"运行时特性","link":"/tags/%E8%BF%90%E8%A1%8C%E6%97%B6%E7%89%B9%E6%80%A7/"},{"name":"C++11&#x2F;14&#x2F;17","slug":"C-11-14-17","link":"/tags/C-11-14-17/"},{"name":"Hexo","slug":"Hexo","link":"/tags/Hexo/"},{"name":"Icarus","slug":"Icarus","link":"/tags/Icarus/"},{"name":"博客搭建","slug":"博客搭建","link":"/tags/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"},{"name":"GitHub Pages","slug":"GitHub-Pages","link":"/tags/GitHub-Pages/"},{"name":"Gitalk","slug":"Gitalk","link":"/tags/Gitalk/"},{"name":"封装","slug":"封装","link":"/tags/%E5%B0%81%E8%A3%85/"},{"name":"继承","slug":"继承","link":"/tags/%E7%BB%A7%E6%89%BF/"},{"name":"多态","slug":"多态","link":"/tags/%E5%A4%9A%E6%80%81/"},{"name":"类与对象","slug":"类与对象","link":"/tags/%E7%B1%BB%E4%B8%8E%E5%AF%B9%E8%B1%A1/"}],"categories":[{"name":"C++","slug":"C","link":"/categories/C/"},{"name":"STL","slug":"STL","link":"/categories/STL/"},{"name":"point","slug":"point","link":"/categories/point/"},{"name":"编程基础","slug":"C/编程基础","link":"/categories/C/%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/"},{"name":"语言基础","slug":"C/语言基础","link":"/categories/C/%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/"},{"name":"语言特性","slug":"C/语言特性","link":"/categories/C/%E8%AF%AD%E8%A8%80%E7%89%B9%E6%80%A7/"},{"name":"现代C++","slug":"C/现代C","link":"/categories/C/%E7%8E%B0%E4%BB%A3C/"},{"name":"博客教程","slug":"博客教程","link":"/categories/%E5%8D%9A%E5%AE%A2%E6%95%99%E7%A8%8B/"},{"name":"memory","slug":"point/memory","link":"/categories/point/memory/"},{"name":"面向对象编程","slug":"C/面向对象编程","link":"/categories/C/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B/"},{"name":"网站建设","slug":"博客教程/网站建设","link":"/categories/%E5%8D%9A%E5%AE%A2%E6%95%99%E7%A8%8B/%E7%BD%91%E7%AB%99%E5%BB%BA%E8%AE%BE/"}],"pages":[]}